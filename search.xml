<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APP读取按键的几种方式</title>
    <url>/2024/01/07/APP%E8%AF%BB%E5%8F%96%E6%8C%89%E9%94%AE%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="app读取按键值">1.APP读取按键值</h2>
<h3 id="app读取按键的-4-种方法">1.1 APP读取按键的 4 种方法</h3>
<h4 id="查询方式">1.1.1 查询方式</h4>
<figure>
<img src="../images/APP读取按键的几种方式/image-20240102195020502.png"
alt="image-20240102195020502" />
<figcaption aria-hidden="true">image-20240102195020502</figcaption>
</figure>
<p>驱动程序中构造、注册一个 file_operations 结构体，里面提供有对应的
open,read 函数。</p>
<p>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置 GPIO
为输入引脚。</p>
<p>APP 调用 read 时，导致驱动中对应的 read 函数被
调用，它读取寄存器，把读取时刻的引脚状态直接返回给 APP。</p>
<h4 id="休眠-唤醒方式">1.1.2 休眠-唤醒方式</h4>
<figure>
<img src="../images/APP读取按键的几种方式/image-20240102195113570.png"
alt="image-20240102195113570" />
<figcaption aria-hidden="true">image-20240102195113570</figcaption>
</figure>
<p>驱动程序中构造、注册一个 file_operations 结构体，里面提供有对应的
open,read 函数。</p>
<ol type="1">
<li>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置 GPIO
为输入引脚；并且注册 GPIO 的中断处理函数。</li>
<li>APP 调用 read 时，导致驱动中对应的 read
函数被调用，如果有按键数据则直接返回给 APP；否则 APP 在内核态休眠。</li>
</ol>
<p>当用户按下按键时，GPIO
中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，并唤醒休眠中的
APP。APP 被唤醒后继续在内核态运行，即继续执行驱动代码，把按键数据返回给
APP(的用户空间)。</p>
<h4 id="poll-方式">1.1.3 poll 方式</h4>
<figure>
<img src="../images/APP读取按键的几种方式/image-20240102195621091.png"
alt="image-20240102195621091" />
<figcaption aria-hidden="true">image-20240102195621091</figcaption>
</figure>
<p>驱动程序中构造、注册一个 file_operations 结构体，里面提供有对应的
open,read,poll 函数。</p>
<ol type="1">
<li>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置 GPIO
为输入引脚；并且注册 GPIO 的中断处理函数。</li>
<li>APP 调用 poll 或 select 函数，意图是“查询”是否有数据，这 2
个函数都可以指定一个超时时间，即在这段时间内没有数据的话就返回错误。这会导致驱动中对应的
poll 函数被调用，如果有按键数据则直接返回给 APP；否则 APP
在内核态休眠一段时间。</li>
</ol>
<p>当用户按下按键时，GPIO 中断被触发，导致驱动程序之前注册的中断服务
程序被执行。它会记录按键数据，并唤醒休眠中的
APP；如果用户没按下按键，但是超时时间到了，内核也会唤醒 APP。被唤醒的
APP 在内核态继续运行，即继续执行驱动代码，把“状态”返回给
APP(的用户空间)。</p>
<p>APP 得到 poll/select 函数的返回结果后，如果确认是有数据的，则再调 用
read 函数，这会导致驱动中的 read 函数被调用，这时驱动程序中含有数据，
会直接返回数据。</p>
<h4 id="异步通知方式">1.1.4 异步通知方式</h4>
<figure>
<img src="../images/APP读取按键的几种方式/image-20240102200346995.png"
alt="image-20240102200346995" />
<figcaption aria-hidden="true">image-20240102200346995</figcaption>
</figure>
<p>异步通知的实现原理是：内核给 APP 发信号。信号有很多种，这里发的是
SIGIO。 驱动程序中构造、注册一个 file_operations
结构体，里面提供有对应的 open,read,fasync 函数。</p>
<ol type="1">
<li>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置 GPIO
为输入引脚；并且注册 GPIO 的中断处理函数。</li>
<li>APP 给信号 SIGIO 注册自己的处理函数：my_signal_fun。</li>
<li>APP 调用 fcntl 函数，把驱动程序的 flag 改为
FASYNC，这会导致驱动程序的 fasync 函数被调用，它只是简单记录进程
PID。</li>
<li>当用户按下按键时，GPIO
中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，然后给进程
PID 发送 SIGIO 信号。</li>
<li><strong>APP
收到信号后会被打断，先执行信号处理函数：在信号处理函数中可以去调用 read
函数读取按键值。</strong></li>
<li>信号处理函数返回后，APP 会继续执行原先被打断的代码。</li>
</ol>
<h4 id="驱动程序提供能力不提供策略">1.1.4
驱动程序提供能力，不提供策略</h4>
<p>我们的驱动程序可以实现上述 4 种提供按键的方法，但是驱动程序不应该限制
APP 使用哪种方法。</p>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY辉光管时钟记录</title>
    <url>/2023/08/31/DIY%E8%BE%89%E5%85%89%E7%AE%A1%E6%97%B6%E9%92%9F%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><img
src="../images/DIY辉光管时钟记录/QQ图片20240127103711.jpg" /></p>
<h2 id="功能">1.功能</h2>
<ul>
<li>4位时间/日期显示</li>
<li>4位温湿度显示</li>
<li>蜂鸣器播放歌曲</li>
<li>WiFi联网时间校正</li>
<li>可编程氛围灯</li>
</ul>
<h2 id="硬件选型">2. 硬件选型</h2>
<ul>
<li>主控：stm32f103c8t6</li>
<li>辉光管：in14</li>
<li>辉光管主控：HV57708</li>
<li>温湿度：GXHT30</li>
<li>时钟芯片：DS1302</li>
<li>氛围灯：WS2812C</li>
<li>WiFi模块：ESP-12F</li>
<li>蜂鸣器：5020贴片蜂鸣器</li>
</ul>
<h2 id="设计">3.设计</h2>
<h3 id="pcb设计">3.1 PCB设计</h3>
<p>PCB 使用立创EDA-标准版进行设计的，整体的 PCB 布局如下：</p>
<figure>
<img src="../images/DIY辉光管时钟记录/image-20240127093429446.png"
alt="image-20240127093429446" />
<figcaption aria-hidden="true">image-20240127093429446</figcaption>
</figure>
<figure>
<img src="../images/DIY辉光管时钟记录/image-20240127093444620.png"
alt="image-20240127093444620" />
<figcaption aria-hidden="true">image-20240127093444620</figcaption>
</figure>
<h4 id="基于max668的升压方案">3.1.1 基于MAX668的升压方案</h4>
<p>辉光管时钟的PCB设计大致可以分为主控的外围电路，传感器外围电路和升压电路三部分。前两部分基本上都有非常简单而且成熟电路可以参考，萌新的第一块成品板就是STM32最小系统板，所以这一块问题倒是不大。最难的还是170伏升压电路的设计，由于缺乏电路知识和设计经验，所以直接不求甚解拿来主义。为了能够方便直接使用Type-C进行供电，并没有选择用的非常多的MAX1771升压方案（该方法需要12V的输入电压），使用下面这位作者的方案：</p>
<blockquote>
<p><a
href="https://oshwhub.com/kratosxs?tab=home&amp;page=1">kratosxs(考研停更中)
- 嘉立创EDA开源硬件平台 (oshwhub.com)</a></p>
</blockquote>
<figure>
<img src="../images/DIY辉光管时钟记录/image-20231217111401377.png"
alt="image-20231217111401377" />
<figcaption aria-hidden="true">image-20231217111401377</figcaption>
</figure>
<h5 id="出现的问题">3.1.1.1 出现的问题</h5>
<p>上面那位作者已经删除了该工程，不过在另一位作者的博客中我找到了类似的设计，甚至连出现的问题都是类似的，都是升压电路的输出电压远达不到170V，仅有60~70V。</p>
<blockquote>
<p><a
href="https://zhangshuqiao.org/2023-04/基于MAX668的辉光管升压方案/">基于
MAX668 的辉光管升压方案 | 米米的博客 (zhangshuqiao.org)</a></p>
</blockquote>
<p>我的升压电路PCB设计如下：</p>
<figure>
<img src="../images/DIY辉光管时钟记录/image-20231217113053411.png"
alt="image-20231217113053411" />
<figcaption aria-hidden="true">image-20231217113053411</figcaption>
</figure>
<p>至于设计中存在的问题，还是得找学电路的朋友帮忙看看。</p>
<h4 id="wifi模块的pcb设计">3.1.2 WiFi模块的PCB设计</h4>
<figure>
<img src="../images/DIY辉光管时钟记录/image-20231217113735334.png"
alt="image-20231217113735334" />
<figcaption aria-hidden="true">image-20231217113735334</figcaption>
</figure>
<p>在WiFi模块的设计中，主要存在的问题有两个：</p>
<ol type="1">
<li>设计上想使用UART来发送AT指令来驱动WiFi模块的，但是接线的时候按理来说WiFi模块和STM32的TXD和RXD应该叉接的，结果我把TXD连TXD、RXD连RXD了，设计的时候太不走心了。</li>
<li>在主供电<code>3.3V</code>和WiFi模块供电<code>3.3V_WiFi</code>之间使用了一个二极管来进行隔离，本意是想要在WiFi模块烧写程序时插针的供电不会影响到其他模块，但是问题是实际使用主供电时，在该二极管的两侧会产生约0.8V的压降，从而导致WiFi模块的供电电压过低无法驱动。之前一直以为二极管正向导通，反向断开，把它看成了一个理想元件，实际上二极管正向导通时会产生部分压降的，对于高压电路而言可以忽略，但是对于
3.3V 而言就不能忽视了。去掉这个二极管，短接引脚之后就没有问题了。</li>
</ol>
<p>作为萌新的第二块成品板，还是有点复杂了，最终打板测试的时候出现了很多问题，有的是连线失误，有的就是完全缺乏电路知识背景，在设计之初就完全没有考虑到的问题。即使在立创的开源社区中有很多的可参考设计，但是涉及到复杂的电路部分（像这次的升压电路），我想，下一次还是选择成品模块进行直接贴片吧。毕竟没有相关知识，出现了问题调试起来是真的无从下手。</p>
<h3 id="程序设计">3.2 程序设计</h3>
<p>主控是 STM32F103C8T6，基于STM32 的标准库进行开发。</p>
<h4 id="辉光管驱动-hv57708">3.2.1 辉光管驱动-HV57708</h4>
<p>比较复杂的就是辉光管的驱动芯片的编码，所以先来进行介绍。</p>
<p>HV57708 是一个可以承受高电压的高速串行转并行输出的芯片，最高支持 64
个通道的输出。对于每个 in14 辉光管而言有 12 个控制引脚，则一个 HV57708
芯片可以控制 4 个全功能的辉光管，6 个可以输出所有数字的辉光管。</p>
<p>HV57708的几个功能引脚的作用如下：</p>
<ul>
<li><p><span
class="math inline">\(\overline{LE}\)</span>：移位寄存器的锁存信号，低电平有效，锁存时无论输入如何变化，寄存器的值不会发生变化</p></li>
<li><p><span
class="math inline">\(\overline{BL}\)</span>：翻译过来叫“消隐”信号，看功能图当该信号处于低电平时，无论输入电平如何都不会影响输出电平，显示该信号应该设置为高电平</p></li>
<li><p><span
class="math inline">\(\overline{POL}\)</span>：极性控制信号，低电平有效，此时芯片工作于反向模式，即写
1 输出 0，写 0 输出
1。辉光管本身是共阳极的结构，共阳极接170V的电压，当数字引脚电压为0V，产生170V的压降，对应的数字被点亮。因此，应该设置
<span class="math inline">\(\overline{POL}\)</span> 为低电平，实现写逻辑
1 点亮辉光管，写逻辑 0 熄灭辉光管。</p></li>
<li><p><span class="math inline">\(DIR\)</span>： <span
class="math inline">\(DIR\)</span> 为低电平时，移位寄存器移位方向 <span
class="math inline">\(Q_N → Q_{N-1}\)</span>，引脚编号 pin41 对应
HVOUT1，引脚<span
class="math inline">\(D_{I/O}1-4B\)</span>为串行输入引脚；<span
class="math inline">\(DIR\)</span> 为高电平时，移位寄存器移位方向 <span
class="math inline">\(Q_N → Q_{N+1}\)</span>，引脚编号 pin41 对应
HVOUT64，引脚<span class="math inline">\(D_{I/O}1-4A\)</span>
为串行输入引脚。如下表：</p>
<figure>
<img src="../images/DIY辉光管时钟记录/image-20240126134819893.png"
alt="image-20240126134819893" />
<figcaption aria-hidden="true">image-20240126134819893</figcaption>
</figure></li>
</ul>
<p>在 PCB 设计中，<span class="math inline">\(DIR\)</span>
的电平为高电平，且辉光管引脚连接如下：</p>
<figure>
<img src="../images/DIY辉光管时钟记录/image-20240126162647567.png"
alt="image-20240126162647567" />
<figcaption aria-hidden="true">image-20240126162647567</figcaption>
</figure>
<p>HV57708 的内部功能简图如下：</p>
<figure>
<img src="../images/DIY辉光管时钟记录/image-20240126131452797.png"
alt="image-20240126131452797" />
<figcaption aria-hidden="true">image-20240126131452797</figcaption>
</figure>
<p>总共有 4 个移位寄存器，每一个寄存器控制右边 16
个引脚的输出，我们需要消耗一些时间来写满这 4
个寄存器。参考时序图，在每一个时钟信号的低电平期间修改数据，在时钟信号的高电平期间数据会被写入移位寄存器中，重复
16 次即可写满这 4 个寄存器。</p>
<p>为了方便 64
位数据在程序上方便写入，每一个移位寄存器所控制的引脚并非连续的，如图 SR4
对应的引脚就是 4, 8, 12..., 64。举个例子，我们有一个 64
位数据，我们从高位到低位进行写入。第一次循环，移位寄存器移位一次 (<span
class="math inline">\(Q_N→Q_{N+1}\)</span>) 随后
64位写入SR4，63位写入SR3，...，61位写入SR1。第二次循环，64到61位被移一位后，60到57位分别被写入SR4到SR1；重复这个过程，最后数据的64位就会被移动到HVOUT64，63位会被移动到HVOUT63，...，61位会被移动到HVOUT61，数据的每一位正好和HVOUT的标号对应。</p>
<p>当所有的串行数据都被写入到移位寄存器中之后，就可以拉高 <span
class="math inline">\(\overline{LE}\)</span> 将数据写入锁存器中。</p>
<p>结合原理图，<span class="math inline">\(DIR\)</span>
为高电平，芯片从右下角顺时针引脚为HVOUT1<span
class="math inline">\(\sim\)</span>HVOUT64，辉光管的管编号对应为1$$4，在PCB中的设置顺序为从左到右，因此我们可以考虑分两步实现：</p>
<ol type="1">
<li><p>将每一个辉光管需要显示的数据 <code>u8 data[4]</code> 映射为一个
64 位的数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * void HV57708_Display(u8 *data)</span></span><br><span class="line"><span class="comment"> * 简介：在辉光管上显示数据</span></span><br><span class="line"><span class="comment"> * 功能：在辉光管上显示数据</span></span><br><span class="line"><span class="comment"> * 输入：data，数组从0开始，对应PCB板上从左开始的辉光管</span></span><br><span class="line"><span class="comment">		 data的元素0~9对应相应的显示数字，元素10对应左小数点，11对应右小数点，12对应不显示</span></span><br><span class="line"><span class="comment"> * 输出：无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HV57708_Display</span><span class="params">(u8 *data)</span></span><br><span class="line">&#123;	</span><br><span class="line">	u8 hvout_x, i, temp;  	</span><br><span class="line">	u32 LSB = <span class="number">0</span>, MSB = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="comment">//首先修改data[i]的值，使之与PCB设计的引脚排列对应</span></span><br><span class="line">		<span class="keyword">if</span> (data[i] == <span class="number">12</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(data[i] &gt;= <span class="number">1</span> &amp;&amp; data[i] &lt;= <span class="number">9</span>) temp = data[i];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (data[i] == <span class="number">0</span>) temp = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (data[i] == <span class="number">10</span>) temp = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> temp = <span class="number">11</span>;</span><br><span class="line">        <span class="comment">//确定辉光管显示数字对应HV57708的HVOUT(x), 0~63</span></span><br><span class="line">		hvout_x = i * <span class="number">12</span> + temp;</span><br><span class="line">	    <span class="keyword">if</span>(hvout_x &lt; <span class="number">32</span>)   LSB |= <span class="number">1</span> &lt;&lt; hvout_x;</span><br><span class="line">		<span class="keyword">else</span>               MSB |= <span class="number">1</span> &lt;&lt; (hvout_x - <span class="number">32</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	HV57708_SendData(MSB, LSB);</span><br><span class="line">	HV57708_OutputData();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将 64 位数据分 16
次写入移位寄存器中，最后将4个移位寄存器的数据进行锁存，从而完成整个串行到并行的输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * void HV57708_SendData(u32 datapart1, u32 datapart2)</span></span><br><span class="line"><span class="comment"> * 简介：向 HV57708 发送数据</span></span><br><span class="line"><span class="comment"> * 功能：向 HV57708 发送 64 位的数据</span></span><br><span class="line"><span class="comment"> * 输入：</span></span><br><span class="line"><span class="comment"> *       datapart1 - 低32位数据</span></span><br><span class="line"><span class="comment"> *       datapart2 - 高32位数据</span></span><br><span class="line"><span class="comment"> * 输出：无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HV57708_SendData</span><span class="params">(u32 datapart2, u32 datapart1)</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 i;</span><br><span class="line">	u32 tmp;</span><br><span class="line">	tmp = datapart2;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		HV57708_CLK = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		HV57708_DI4 = (tmp &amp; <span class="number">0x80000000</span>);</span><br><span class="line">		tmp = tmp &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		HV57708_DI3 = (tmp &amp; <span class="number">0x80000000</span>);</span><br><span class="line">		tmp = tmp &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		HV57708_DI2 = (tmp &amp; <span class="number">0x80000000</span>);</span><br><span class="line">		tmp = tmp &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		HV57708_DI1 = (tmp &amp; <span class="number">0x80000000</span>);</span><br><span class="line">		tmp = tmp &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		Delay(<span class="number">20</span>);</span><br><span class="line">		HV57708_CLK = <span class="number">1</span>;</span><br><span class="line">		Delay(<span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	tmp = datapart2;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		HV57708_CLK = <span class="number">0</span>;</span><br><span class="line">		HV57708_DI4 = (tmp &amp; <span class="number">0x80000000</span>);</span><br><span class="line">		tmp = tmp &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		HV57708_DI3 = (tmp &amp; <span class="number">0x80000000</span>);</span><br><span class="line">		tmp = tmp &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		HV57708_DI2 = (tmp &amp; <span class="number">0x80000000</span>);</span><br><span class="line">		tmp = tmp &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		HV57708_DI1 = (tmp &amp; <span class="number">0x80000000</span>);</span><br><span class="line">		tmp = tmp &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		Delay(<span class="number">20</span>);</span><br><span class="line">		HV57708_CLK = <span class="number">1</span>;</span><br><span class="line">		Delay(<span class="number">20</span>);</span><br><span class="line">		HV57708_CLK = <span class="number">0</span>;</span><br><span class="line">		Delay(<span class="number">20</span>);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>锁存寄存器数据，完成并行数据输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * void HV57708_OutputData(void)</span></span><br><span class="line"><span class="comment"> * 简介：将 HV57708 寄存器中的数据输出至引脚</span></span><br><span class="line"><span class="comment"> * 功能：将 HV57708 寄存器中的数据输出至引脚</span></span><br><span class="line"><span class="comment"> * 输入：无</span></span><br><span class="line"><span class="comment"> * 输出：无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HV57708_OutputData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HV57708_LE = <span class="number">1</span>;  <span class="comment">//数据写入锁存器</span></span><br><span class="line">	Delay(<span class="number">50</span>);</span><br><span class="line">	HV57708_LE = <span class="number">0</span>;  <span class="comment">//数据锁存</span></span><br><span class="line">	Delay(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="与wifi模块的通信">3.2.2 与WiFi模块的通信</h4>
<p>本身最初设计上是想让STM32使用UART发送AT指令驱动WiFi模块的，让WiFi模块基于NTP协议来获取网络时间，从而纠正
DS1302
时间长之后可能会出现的计时误差。但是一不注意没有将二者的串口引脚交叉相接，等焊好测试的时候才发现这个问题，硬件上已经没有办法补救了，只能从软件上考虑能不能救一下了。</p>
<p>好在是当初为了防止WiFi模块的AT固件可能出现问题，预留了WiFi模块的程序下载接口。既然如此，那就直接对这块
ESP8266 进行编程吧，将两个端口作为普通 IO
口来使用，一个作为时间信号，一个作为数据信号。</p>
<p>设计上，一个IO口作为时钟信号来触发STM32的外部中断，当该中断发生时，将另一个
IO
口上的电平状态作为一位数据进行读入，相当于实现了一个非常简陋的“通信协议”。由于
DS1302 一年也就存在约一分钟的计时误差，所以仅在上电之后 ESP8266
会发送一次网络时间数据给 STM32 来纠正计时误差。</p>
<p>另外，基于Arduino 平台对 ESP8266 进行编程，顺便还使用了一下
WiFiManager 这个库来让用户完成对家中 WiFi 的名称和密码的配置。</p>
<h4 id="其他模块">3.2.3 其他模块</h4>
<p>其他模块相对而言都比较常见了。</p>
<ul>
<li><p>温湿度模块 GXHT30 芯片基于 I2C 协议与 STM32 进行通信</p></li>
<li><p>时钟模块 DS1302 使用非常类似于 I2C 的通信时序与 STM32
进行通信</p></li>
<li><p>氛围灯 WS2812
使用一位数据线，串行发送24bit颜色数据。使用不同占空比的高低电平表示逻辑高低电平。因此使用定时器的输出比较功能不断输出这两种占空比的
PWM 波 （为了减少 MCU 资源占用，还可以使用 DMA 来完成比较寄存器 CCR
的值的快速重装）</p>
<figure>
<img src="../images/DIY辉光管时钟记录/image-20240126185326865.png"
alt="image-20240126185326865" />
<figcaption aria-hidden="true">image-20240126185326865</figcaption>
</figure></li>
</ul>
<p>最后是无源蜂鸣器5050，为了能整点花样，让蜂鸣器来演奏一些和辉光管比较搭配的音乐。同样是使用定时器的输出比较功能来产生
PWM 波。不同占空比的 PWM 波能激发蜂鸣器发出不同的音符，控制 PWM
波的输出时间能控制每一个音符的持续时间，这样就能够简单演奏一首音乐了。</p>
<h2 id="外观">4. 外观</h2>
<h3 id="pcb外观">4.1 PCB外观</h3>
<figure>
<img src="../images/DIY辉光管时钟记录/image-20240127093929564.png"
alt="image-20240127093929564" />
<figcaption aria-hidden="true">image-20240127093929564</figcaption>
</figure>
<figure>
<img src="../images/DIY辉光管时钟记录/image-20240127094712433.png"
alt="image-20240127094712433" />
<figcaption aria-hidden="true">image-20240127094712433</figcaption>
</figure>
<p>设计上将几乎所有元器件都放在了背面，使得正面看起来还是非常简洁大方的。使用黑色漆加上沉金工艺，整体的搭配还是非常好看的。</p>
<h3 id="外壳">4.2 外壳</h3>
<figure>
<img src="../images/DIY辉光管时钟记录/image-20240127100332350.png"
alt="image-20240127100332350" />
<figcaption aria-hidden="true">image-20240127100332350</figcaption>
</figure>
<p>外壳就简单使用 CAD
绘制了上下两张亚克力板，在淘宝随便找一家加工一下就行，上板使用 3.6mm
的透明亚克力板，下板使用 4.5mm
的黑色不透明的亚克力板。实际效果还是略厚的，两块板子完全可以在降低一个档位的厚度。</p>
<h3 id="整体效果">4.3 整体效果</h3>
<p><img
src="../images/DIY辉光管时钟记录/QQ图片20240127103734.jpg" /></p>
<p><img
src="../images/DIY辉光管时钟记录/QQ图片20240127103739.jpg" /></p>
<h2 id="总结">5.总结</h2>
<p>之前本科时就想学画 PCB，以为画
PCB需要先把电路三件套都学完才能会画吧。实际体验了整个绘制流程，这个想法既对也不对，从零开始自己设计电路的每一个细节确实非常需要电路知识，而现在网上开源的电路设计非常多，如果只是将这些设计进行简单拼接以实现自己的目标，那还是相对容易的。在没有精力学电路知识之前，未来还是就这样站在巨人的肩膀上，达成自己的目标，相比这一次可能会更加减少自己的
PCB 设计部分吧 （因为出了问题是真的不会解决:(
）。此外，立创EDA较低的使用门槛，立创开源广场上众多开发者的开源设计，嘉立创的白嫖打板券都在本次的作品中为我提供了非常大的帮助，必须要致以诚挚的感谢！</p>
<p>辉光管时钟是我自看了石头门之后一直想做的作品，只是碍于大学时种种原因一直未能如愿。在研究生阶段，终于是定下心来决定学习不会的知识，将其实现出来。在这约半年的时间里，一直饱受科研做实验的折磨，并没有过多的心力来推进项目的进展，以至于拖得周期非常长，在最后并没有尽善尽美的把它做好，稍有一些遗憾。</p>
<p>我本人更想要一款更具有实用意义的伪辉光管时钟，所以这款真辉光管时钟的设计上特意添加了很多苏联的元素，是送给一位"精苏"的朋友的，也是缅怀那个因崇高理想而创建的伟大国家。</p>
<h2 id="参考链接">6.参考链接</h2>
<p>我的开源：<a
href="https://github.com/krocz/My_NixieClock/tree/main">krocz/My_NixieClock
(github.com)</a></p>
<blockquote>
<p>软硬件参考：</p>
<p><a
href="https://github.com/zzx0226/IN14_NIXIEClock">zzx0226/IN14_NIXIEClock
(github.com)</a></p>
<p><a
href="https://oshwhub.com/mmjx/ji-yu-wu-lian-wang-de-hui-guang-">基于物联网的辉光管时钟系统
- 嘉立创EDA开源硬件平台 (oshwhub.com)</a></p>
<p><a
href="https://oshwhub.com/xzfs/hui-guang-guan-sheng-ya-2333">辉光管升压2333
- 嘉立创EDA开源硬件平台 (oshwhub.com)</a></p>
<p><a href="https://www.zhihu.com/question/34564116">如何自己制作一个
divergense meter（辉光管时钟）？ - 知乎 (zhihu.com)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>电子DIY记录</category>
      </categories>
      <tags>
        <tag>stm32</tag>
        <tag>DIY</tag>
      </tags>
  </entry>
  <entry>
    <title>I2C应用编程</title>
    <url>/2023/10/13/IIC%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="i2c协议">1. I2C协议</h2>
<figure>
<img src="../images/IIC应用编程/image-20231013195434388.png"
alt="image-20231013195434388" />
<figcaption aria-hidden="true">image-20231013195434388</figcaption>
</figure>
<ul>
<li>起始信号</li>
<li>停止信号</li>
<li>传输1Bit数据时的信号</li>
<li>应答信号（<strong>0：应答，1：非应答</strong>）</li>
</ul>
<h3 id="i2c写操作">1.1 I2C写操作</h3>
<figure>
<img src="../images/IIC应用编程/image-20231013200107130.png"
alt="image-20231013200107130" />
<figcaption aria-hidden="true">image-20231013200107130</figcaption>
</figure>
<p>（白色背景：主→从；灰色背景：从→主）</p>
<h3 id="i2c读操作">1.2 I2C读操作</h3>
<figure>
<img src="../images/IIC应用编程/image-20231013200321711.png"
alt="image-20231013200321711" />
<figcaption aria-hidden="true">image-20231013200321711</figcaption>
</figure>
<h3 id="i2c引脚的硬件设计">1.3 I2C引脚的硬件设计</h3>
<figure>
<img src="../images/IIC应用编程/image-20231013200615311.png"
alt="image-20231013200615311" />
<figcaption aria-hidden="true">image-20231013200615311</figcaption>
</figure>
<p>真值表：</p>
<table>
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
<th>SDA</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<ul>
<li><p>使用开漏电路，可以防止设备引脚存在电压差时短路的出现</p></li>
<li><p>使用上拉电路，可以在设备都没有拉低信号时，保证引线不浮空</p></li>
<li><p>SCL采用同样的设计，是因为SCL不仅仅由主设备进行控制，在少数情况下也可能由从设备进行控制，<strong>如从设备需要主设备等待自己时，可能会选择将SCL拉低</strong>。</p></li>
</ul>
<h2 id="smbus协议system-management-bus">2.SMBus协议(System Management
Bus)</h2>
<p>SMBus
最初的目的是为智能电池、充电电池、其他微控制器之间的通信链路而定义的。
SMBus 也被用来连接各种设备，包括电源相关设备，系统传感器，EEPROM
通讯设备等。<strong>SMBus 是基于 I2C 协议的，SMBus 要求更严格，SMBus 是
I2C 协议的子集。</strong></p>
<h3 id="与i2c的区别">2.1 与I2C的区别</h3>
<ul>
<li><p>VDD 的极限值不一样</p>
<ul>
<li>I2C 协议：范围很广，甚至讨论了高达 12V 的情况</li>
<li>SMBus：1.8V~5V</li>
</ul></li>
<li><p>最小时钟频率、最大的 Clock Stretching</p>
<ul>
<li><strong>Clock
Stretching</strong>：某个设备需要更多时间进行内部的处理时，它可以把 SCL
拉低占住 I2C 总线</li>
<li>I2C ：时钟频率最小值无限制，Clock Stretching 时长也没有限制</li>
<li>SMBus ：时钟频率最小值是 10KHz，Clock Stretching
的最大时间值也有限制</li>
</ul></li>
<li><p>地址回应(Address Acknowledge)：一个 I2C
设备接收到它的设备地址后， 是否必须发出回应信号？</p>
<ul>
<li>I2C：没有强制要求必须发出回应信号</li>
<li>SMBus：强制要求必须发出回应信号，这样对方才知道该设备的状态：
busy，failed，或是被移除了</li>
</ul></li>
<li><p>SMBus 协议明确了数据的传输格式</p>
<ul>
<li>I2C
：它只定义了怎么传输数据，但是并没有定义数据的格式，这完全由设备来定义</li>
<li>SMBus：定义了几种数据格式</li>
</ul></li>
<li><p>REPEATED START Condition(重复发出 S 信号)</p>
<ul>
<li>在连续的写/读之间，可以不发出 P 信号，而是直接发出 S 信号：这个 S
信号就是 REPEATED START</li>
</ul>
<figure>
<img src="../images/IIC应用编程/image-20231013205135864.png"
alt="image-20231013205135864" />
<figcaption aria-hidden="true">image-20231013205135864</figcaption>
</figure></li>
<li><p>SMBus Low Power Version：SMBus 也有低功耗的版本</p></li>
</ul>
<h3 id="smbus-协议分析">2.2 SMBus 协议分析</h3>
<p><code>Functionality flag</code> 是 Linux 的某个 I2C
控制器驱动所支持的功能。比如
<code>Functionality flag: I2C_FUNC_SMBUS_QUICK</code>，表示需要 I2C
控制器支持 SMBus Quick Command。</p>
<h4 id="smbus-quick-command">(1) SMBus Quick Command</h4>
<figure>
<img src="../images/IIC应用编程/image-20231013205740269.png"
alt="image-20231013205740269" />
<figcaption aria-hidden="true">image-20231013205740269</figcaption>
</figure>
<p>只是用来发送一位数据：R/W#本意是用来表示读或写，但是在 SMBus
里可以用来表示其他含义；比如某些开关设备，可以根据这一位来决定是打开还是关闭。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Functionality flag: I2C_FUNC_SMBUS_QUICK</span><br></pre></td></tr></table></figure>
<h4 id="smbus-receive-byte">(2) SMBus Receive Byte</h4>
<figure>
<img src="../images/IIC应用编程/image-20231013210229543.png"
alt="image-20231013210229543" />
<figcaption aria-hidden="true">image-20231013210229543</figcaption>
</figure>
<p>和I2C读取字节相同，对应I2C-tools
中的函数：<code>i2c_smbus_read_byte()</code>。读取一个字节，Host adapter
接收到一个字节后不需要发出回应信号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Functionality flag: I2C_FUNC_SMBUS_READ_BYTE</span><br></pre></td></tr></table></figure>
<h4 id="smbus-send-byte">(3) SMBus Send Byte</h4>
<figure>
<img src="../images/IIC应用编程/image-20231013210406105.png"
alt="image-20231013210406105" />
<figcaption aria-hidden="true">image-20231013210406105</figcaption>
</figure>
<p>和I2C写字节相同，对应I2C-tools
中的函数：<code>i2c_smbus_write_byte()</code>。发送一个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Functionality flag: I2C_FUNC_SMBUS_WRITE_BYTE</span><br></pre></td></tr></table></figure>
<h4 id="smbus-read-byte">(4) SMBus Read Byte</h4>
<figure>
<img src="../images/IIC应用编程/image-20231013210539307.png"
alt="image-20231013210539307" />
<figcaption aria-hidden="true">image-20231013210539307</figcaption>
</figure>
<p>I2C-tools 中的函数：<code>i2c_smbus_read_byte_data()</code>。先发出
Command Code(它一般表示芯片内部的寄存器地址)，再读取一个字节的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Functionality flag: I2C_FUNC_SMBUS_READ_BYTE_DATA</span><br></pre></td></tr></table></figure>
<h4 id="smbus-read-word">(5) SMBus Read Word</h4>
<figure>
<img src="../images/IIC应用编程/image-20231013210747692.png"
alt="image-20231013210747692" />
<figcaption aria-hidden="true">image-20231013210747692</figcaption>
</figure>
<p>I2C-tools 中的函数：<code>i2c_smbus_read_word_data()</code>。先发出
Command Code(它一般表示芯片内部的寄存器地址)，再读取 2 个字节的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Functionality flag: I2C_FUNC_SMBUS_READ_WORD_DATA</span><br></pre></td></tr></table></figure>
<h4 id="smbus-write-byte">(6) SMBus Write Byte</h4>
<figure>
<img src="../images/IIC应用编程/image-20231013210922202.png"
alt="image-20231013210922202" />
<figcaption aria-hidden="true">image-20231013210922202</figcaption>
</figure>
<p>I2C-tools 中的函数：<code>i2c_smbus_write_byte_data()</code>。先发出
Command Code(它一般表示芯片内部的寄存器地址)，再发出 1 个字节的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Functionality flag: I2C_FUNC_SMBUS_WRITE_BYTE_DATA</span><br></pre></td></tr></table></figure>
<h4 id="smbus-write-word">(7) SMBus Write Word</h4>
<figure>
<img src="../images/IIC应用编程/image-20231013211028442.png"
alt="image-20231013211028442" />
<figcaption aria-hidden="true">image-20231013211028442</figcaption>
</figure>
<p>I2C-tools 中的函数：<code>i2c_smbus_write_word_data()</code>。先发出
Command Code(它一般表示芯片内部的寄存器地址)，再发出 2
个字节的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Functionality flag: I2C_FUNC_SMBUS_WRITE_WORD_DATA</span><br></pre></td></tr></table></figure>
<h4 id="smbus-block-read">(8) SMBus Block Read</h4>
<figure>
<img src="../images/IIC应用编程/image-20231013211214615.png"
alt="image-20231013211214615" />
<figcaption aria-hidden="true">image-20231013211214615</figcaption>
</figure>
<p>I2C-tools 中的函数：<code>i2c_smbus_read_block_data()</code>。先发出
Command Code(它一般表示芯片内部的寄存器地址)，再发起度操作：</p>
<ul>
<li>先读到一个字节(Block Count)，表示后续要读的字节数</li>
<li>然后读取全部数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Functionality flag: I2C_FUNC_SMBUS_READ_BLOCK_DATA</span><br></pre></td></tr></table></figure>
<h5 id="psi2c-block-read">PS：I2C Block Read</h5>
<p>在一般的 I2C 协议中，也可以连续读出多个字节。它跟 SMBus Block Read
的差别在于从设备发出的第 1 个数据不是长度 N，如下图所示：</p>
<figure>
<img src="../images/IIC应用编程/image-20231013211836310.png"
alt="image-20231013211836310" />
<figcaption aria-hidden="true">image-20231013211836310</figcaption>
</figure>
<p>I2C-tools
中的函数：<code>i2c_smbus_read_i2c_block_data()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Functionality flag: I2C_FUNC_SMBUS_READ_I2C_BLOCK</span><br></pre></td></tr></table></figure>
<h4 id="smbus-block-write">(9) SMBus Block Write</h4>
<figure>
<img src="../images/IIC应用编程/image-20231013211357246.png"
alt="image-20231013211357246" />
<figcaption aria-hidden="true">image-20231013211357246</figcaption>
</figure>
<p>I2C-tools 中的函数：<code>i2c_smbus_write_block_data()</code>。先发出
Command Code(它一般表示芯片内部的寄存器地址)，再发出 1 个字节的 Byte
Conut(表示后续要发出的数据字节数)，最后发出全部数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Functionality flag: I2C_FUNC_SMBUS_WRITE_BLOCK_DATA</span><br></pre></td></tr></table></figure>
<h5 id="psi2c-block-write">PS：I2C Block Write</h5>
<p>在一般的 I2C 协议中，也可以连续发出多个字节。它跟 SMBus Block Write
的差别在于发出的第 1 个数据不是长度 N，如下图所示：</p>
<figure>
<img src="../images/IIC应用编程/image-20231013211534690.png"
alt="image-20231013211534690" />
<figcaption aria-hidden="true">image-20231013211534690</figcaption>
</figure>
<p>I2C-tools
中的函数：<code>i2c_smbus_write_i2c_block_data()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Functionality flag: I2C_FUNC_SMBUS_WRITE_I2C_BLOCK</span><br></pre></td></tr></table></figure>
<h4 id="smbus-block-write---block-read-process-call">(10) SMBus Block
Write - Block Read Process Call</h4>
<figure>
<img src="../images/IIC应用编程/image-20231013212003873.png"
alt="image-20231013212003873" />
<figcaption aria-hidden="true">image-20231013212003873</figcaption>
</figure>
<p>先写一块数据，再读一块数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Functionality flag: I2C_FUNC_SMBUS_BLOCK_PROC_CALL</span><br></pre></td></tr></table></figure>
<h4 id="packet-error-checking-pec">(11) Packet Error Checking (PEC)</h4>
<p>PEC 是一种错误校验码，如果使用 PEC，那么在 P
信号之前，数据发送方要发送一个字节的 PEC 码(<strong>它是 CRC-8
码</strong>)。以 SMBus Send Byte 为例，下图中， 一个未使用
PEC，另一个使用 PEC：</p>
<figure>
<img src="../images/IIC应用编程/image-20231013212158627.png"
alt="image-20231013212158627" />
<figcaption aria-hidden="true">image-20231013212158627</figcaption>
</figure>
<h4 id="ps">PS：</h4>
<p>因为很多设备都实现了 SMBus，而不是更宽泛的 I2C 协议，所以优先使用
SMBus。即使 I2C 控制器没有实现 SMBus，软件方面也是可以使用 I2C 协议来
模拟 SMBus。所以：<strong>Linux 建议优先使用 SMBus</strong>。</p>
<h2 id="linux系统中i2c的软件框架">3.Linux系统中I2C的软件框架</h2>
<figure>
<img src="../images/IIC应用编程/image-20231013201531293.png"
alt="image-20231013201531293" />
<figcaption aria-hidden="true">image-20231013201531293</figcaption>
</figure>
<ul>
<li>怎么理解I2C Device Driver和I2C Controller Driver
<ul>
<li>I2C Device Driver用于针对每一种I2C设备编写相应的数据收发格式</li>
<li>I2C Controller Driver用于通用的产生I2C协议的各类信号</li>
</ul></li>
<li>APP 可以通过两类驱动程序访问设备
<ul>
<li>I2C 设备自己的驱动程序</li>
<li>内核自带的 i2c-dev.c 驱动程序，它是 i2c
控制器驱动程序暴露给用户空间的驱动程序(i2c-dev.c)</li>
</ul></li>
<li>I2C Device Driver
<ul>
<li>I2C 设备自己的驱动程序</li>
<li>内核自带的 i2c-dev.c 驱动程序，它是 i2c
控制器驱动程序暴露给用户空间的驱动程序(i2c-dev.c)</li>
</ul></li>
<li>I2C Controller Driver
<ul>
<li>芯片 I2C 控制器的驱动程序(称为 adapter)</li>
<li>使用 GPIO 模拟的 I2C 控制器驱动程序(i2c-gpio.c)</li>
</ul></li>
</ul>
<h2 id="i2c应用编程">4. I2C应用编程</h2>
<h3 id="重要结构体">4.1 重要结构体</h3>
<figure>
<img src="../images/IIC应用编程/image-20231017195937671.png"
alt="image-20231017195937671" />
<figcaption aria-hidden="true">image-20231017195937671</figcaption>
</figure>
<p>参考I2C硬件结构体，每一个I2C
Controller使用<code>i2c_adapter</code>来表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span>		  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">	<span class="type">void</span> *algo_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_lock_operations</span> *<span class="title">lock_ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">mux_lock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">	<span class="type">int</span> retries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the adapter device */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> nr;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">48</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中重要的成员：</p>
<ul>
<li><code>algo</code>：指定控制器传输数据使用的函数，用来收发I2C数据</li>
<li><code>nr</code>：第几个I2C Controller</li>
</ul>
<p><code>i2c_algorithm</code>结构体原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">	<span class="comment">/* If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">	   to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">	   smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">	   using common I2C messages */</span></span><br><span class="line">	<span class="comment">/* master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">	   processed, or a negative value on error */</span></span><br><span class="line">	<span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">			   <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*smbus_xfer) (<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">			   <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">			   u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">	u32 (*functionality) (<span class="keyword">struct</span> i2c_adapter *);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="type">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line">	<span class="type">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从结构体<code>i2c_algorithm</code>中发现和I2C从设备相关的结构体<code>i2c_client</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*flags for the client struct: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_PEC		0x04	<span class="comment">/* Use Packet Error Checking */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_TEN		0x10	<span class="comment">/* we have a ten bit chip address */</span></span></span><br><span class="line">					<span class="comment">/* Must equal I2C_M_TEN below */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_SLAVE	0x20	<span class="comment">/* we are the slave */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_WAKE		0x80	<span class="comment">/* for board_info; true iff can wake */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CLIENT_SCCB		0x9000	<span class="comment">/* Use Omnivision SCCB protocol */</span></span></span><br><span class="line">					<span class="comment">/* Must match I2C_M_STOP|IGNORE_NAK */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> flags;		<span class="comment">/* div., see below		*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> addr;		<span class="comment">/* chip address - <span class="doctag">NOTE:</span> 7bit	*/</span></span><br><span class="line">					<span class="comment">/* addresses are stored in the	*/</span></span><br><span class="line">					<span class="comment">/* _LOWER_ 7 bits		*/</span></span><br><span class="line">	<span class="type">char</span> name[I2C_NAME_SIZE];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>	<span class="comment">/* the adapter we sit on	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the device structure		*/</span></span><br><span class="line">	<span class="type">int</span> irq;			<span class="comment">/* irq issued by device		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">detected</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="type">i2c_slave_cb_t</span> slave_cb;	<span class="comment">/* callback for slave mode	*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在该结构体中最重要的成员：</p>
<ul>
<li><code>addr</code>：表示该I2C设备的设备地址</li>
<li><code>adapter</code>：表示该I2C设备挂载在哪个I2C Controller下</li>
</ul>
<p>结构体<code>i2c_msg</code>封装了需要传输的数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">	__u16 addr;	<span class="comment">/* slave address			*/</span></span><br><span class="line">	__u16 flags;        <span class="comment">/* 表示读或写 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RD		0x0001	<span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line">					<span class="comment">/* I2C_M_RD is guaranteed to be 0x0001! */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_TEN		0x0010	<span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RECV_LEN		0x0400	<span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NO_RD_ACK		0x0800	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_IGNORE_NAK	0x1000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_REV_DIR_ADDR	0x2000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NOSTART		0x4000	<span class="comment">/* if I2C_FUNC_NOSTART */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_STOP		0x8000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line">	__u16 len;		<span class="comment">/* msg length				*/</span></span><br><span class="line">	__u8 *buf;		<span class="comment">/* pointer to msg data			*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>flags</code>：该字段为0表示写，为<code>I2C_M_RD</code>表示读</li>
</ul>
<h3 id="使用i2c-tools访问i2c设备">4.2 使用I2C-Tools访问I2C设备</h3>
<figure>
<img src="../images/IIC应用编程/image-20231023194336992.png"
alt="image-20231023194336992" />
<figcaption aria-hidden="true">image-20231023194336992</figcaption>
</figure>
<h4 id="体验i2c-tools可执行程序">4.2.1 体验I2C-Tools可执行程序</h4>
<h5 id="i2cdectect-列出设备上i2c设备的信息">(1)
i2cdectect-列出设备上I2C设备的信息</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 列出当前的 I2C Adapter(或称为 I2C Bus、I2C Controller) </span><br><span class="line">i2cdetect -l </span><br><span class="line"></span><br><span class="line">// 打印某个 I2C Adapter 的 Functionalities, I2CBUS 为 0、1、2 等整数 </span><br><span class="line">i2cdetect -F I2CBUS </span><br><span class="line"></span><br><span class="line">// 看看有哪些 I2C 设备, I2CBUS 为 0、1、2 等整数 </span><br><span class="line">// --表示没有该地址对应的设备,UU表示有该设备并且它已经有驱动程序,数值表示有该设备但是没有对应的设备驱动</span><br><span class="line">i2cdetect -y -a I2CBUS </span><br></pre></td></tr></table></figure>
<h5 id="i2cget-读数据">(2) i2cget-读数据</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 读一个字节: I2CBUS 为 0、1、2 等整数, 表示 I2C Bus; CHIP-ADDRESS 表示设备地址 </span><br><span class="line">i2cget -f -y I2CBUS CHIP-ADDRESS </span><br><span class="line"></span><br><span class="line">// 读某个地址上的一个字节: </span><br><span class="line">// I2CBUS 为 0、1、2 等整数, 表示 I2C Bus </span><br><span class="line">// CHIP-ADDRESS 表示设备地址 </span><br><span class="line">// DATA-ADDRESS: 芯片上寄存器地址 </span><br><span class="line">// MODE：有 2 个取值:</span><br><span class="line">// b:使用`SMBus Read Byte`先发出 DATA-ADDRESS, 再读一个字节, 中间无 P 信号 </span><br><span class="line">// c:先 write byte, 在 read byte，中间有 P 信号 </span><br><span class="line">i2cget -f -y I2CBUS CHIP-ADDRESS DATA-ADDRESS MODE</span><br></pre></td></tr></table></figure>
<h5 id="i2cset-写数据">(3) i2cset-写数据</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 写一个字节: I2CBUS 为 0、1、2 等整数, 表示 I2C Bus; CHIP-ADDRESS 表示设备地址 </span><br><span class="line">// DATA-ADDRESS 就是要写的数据 </span><br><span class="line">i2cset -f -y I2CBUS CHIP-ADDRESS DATA-ADDRESS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 给 address 写 1 个字节或者 1 个字(address, value): </span><br><span class="line">// I2CBUS 为 0、1、2 等整数, 表示 I2C Bus; CHIP-ADDRESS 表示设备地址 </span><br><span class="line">// DATA-ADDRESS: 8 位芯片寄存器地址; </span><br><span class="line">// VALUE: 8 位数值 或者 16 位数据</span><br><span class="line">// MODE: b表示写字节，w表示写字</span><br><span class="line">i2cset -f -y I2CBUS CHIP-ADDRESS DATA-ADDRESS VALUE b or w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// SMBus Block Write：给 address 写 N 个字节的数据 </span><br><span class="line">// 发送的数据有：address, N, value1, value2, ..., valueN </span><br><span class="line">// 跟`I2C Block Write`相比, 需要发送长度 N </span><br><span class="line">// I2CBUS 为 0、1、2 等整数, 表示 I2C Bus; CHIP-ADDRESS 表示设备地址 </span><br><span class="line">// DATA-ADDRESS: 8 位芯片寄存器地址; </span><br><span class="line">// VALUE1~N: N 个 8 位数值 </span><br><span class="line">// MODE: s </span><br><span class="line">i2cset -f -y I2CBUS CHIP-ADDRESS DATA-ADDRESS VALUE1 ... VALUEN s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// I2C Block Write：给 address 写 N 个字节的数据 </span><br><span class="line">// 发送的数据有：address, value1, value2, ..., valueN </span><br><span class="line">// 跟`SMBus Block Write`相比, 不需要发送长度 N</span><br><span class="line">// I2CBUS 为 0、1、2 等整数, 表示 I2C Bus; CHIP-ADDRESS 表示设备地址 </span><br><span class="line">// DATA-ADDRESS: 8 位芯片寄存器地址; </span><br><span class="line">// VALUE1~N: N 个 8 位数值 </span><br><span class="line">// MODE: i </span><br><span class="line">i2cset -f -y I2CBUS CHIP-ADDRESS DATA-ADDRESS VALUE1 ... VALUEN i</span><br></pre></td></tr></table></figure>
<h5 id="i2ctransfer-基于i2c协议传输数据">(4)
i2ctransfer-基于I2C协议传输数据</h5>
<p>i2ctransfer命令的使用说明如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Usage: i2ctransfer [-f] [-y] [-v] [-V] [-a] I2CBUS DESC [DATA] [DESC [DATA]]...</span><br><span class="line">  I2CBUS is an integer or an I2C bus name</span><br><span class="line">  DESC describes the transfer in the form: &#123;r|w&#125;LENGTH[@address]</span><br><span class="line">    1) read/write-flag 2) LENGTH (range 0-65535, or &#x27;?&#x27;)</span><br><span class="line">    3) I2C address (use last one if omitted)</span><br><span class="line">  DATA are LENGTH bytes for a write message. They can be shortened by a suffix:</span><br><span class="line">    = (keep value constant until LENGTH)</span><br><span class="line">    + (increase value by 1 until LENGTH)</span><br><span class="line">    - (decrease value by 1 until LENGTH)</span><br><span class="line">    p (use pseudo random generator until LENGTH with value as seed)</span><br></pre></td></tr></table></figure>
<p>使用例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Example (bus 0, read 8 byte at offset 0x64 from EEPROM at 0x50): </span><br><span class="line"># i2ctransfer -f -y 0 w1@0x50 0x64 r8 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Example (bus 0, write 3 byte at offset 0x64 from EEPROM at 0x50): </span><br><span class="line"># i2ctransfer -f -y 0 w9@0x50 0x64 val1 val2 val3 </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// Example：first: (bus 0, write 3 byte at offset 0x64 from EEPROM at 0x50) </span><br><span class="line">// and then: (bus 0, read 3 byte at offset 0x64 from EEPROM at 0x50) </span><br><span class="line"># i2ctransfer -f -y 0 w9@0x50 0x64 val1 val2 val3 r3@0x50 </span><br><span class="line"># i2ctransfer -f -y 0 w9@0x50 0x64 val1 val2 val3 r3 //如果设备地址不变,后面的设备地址可 省略</span><br></pre></td></tr></table></figure>
<h4 id="i2c-tools访问i2c设备的2种方式">4.2.2
I2C-Tools访问I2C设备的2种方式</h4>
<p>I2C-Tools可以通过SMBus来访问I2C设备，也可以使用一般的I2C协议来访问I2C设备。</p>
<h5 id="使用i2c方式">(1) 使用I2C方式</h5>
<p>示例代码：i2ctransfer.c</p>
<figure>
<img src="../images/IIC应用编程/image-20231023200031632.png"
alt="image-20231023200031632" />
<figcaption aria-hidden="true">image-20231023200031632</figcaption>
</figure>
<h5 id="使用smbus方式">(2) 使用SMBus方式</h5>
<p>示例代码：i2cget.c、i2cset.c</p>
<figure>
<img src="../images/IIC应用编程/image-20231023200102753.png"
alt="image-20231023200102753" />
<figcaption aria-hidden="true">image-20231023200102753</figcaption>
</figure>
<h4 id="使用i2c-tools读取温湿度传感器aht10的数据">4.2.3
使用I2C-Tools读取温湿度传感器AHT10的数据</h4>
<figure>
<img src="../images/IIC应用编程/image-20231023194745114.png"
alt="image-20231023194745114" />
<figcaption aria-hidden="true">image-20231023194745114</figcaption>
</figure>
<p>分析数据手册中提供的时序图，AHT10使用的通信协议中“读取温湿度数据”部分并不符合SMBus协议中规定的格式；因此，”触发测量数据“部分使用SMBus方式，“读取温湿度数据”部分使用I2C方式。</p>
<figure>
<img src="../images/IIC应用编程/image-20231023200937458.png"
alt="image-20231023200937458" />
<figcaption aria-hidden="true">image-20231023200937458</figcaption>
</figure>
<p>传感器在采集时需要时间,主机发出测量指令（0xAC）
后,延时75毫秒以上再读取转换后的数据并判断返回的状
态位是否正常。若状态比特位[Bit7]为0代表数据可正常读取,为1时传感器为忙状态,主机需要等待数据处理完成。</p>
<h5 id="代码">代码</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;i2cbusses.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;i2c/smbus.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c-dev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> N = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> read_buffer[<span class="number">6</span>], dev_addr = <span class="number">0x38</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_rdwr_ioctl_data</span> <span class="title">rdwr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">char</span> filename[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> fd, ret;</span><br><span class="line">    <span class="type">float</span> temper, humid;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> t, h;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;read AHT10: %s &lt;i2c_bus_number&gt; string\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;    </span><br><span class="line">    <span class="comment">// 打开I2C Controller</span></span><br><span class="line">    fd = open_i2c_dev(argv[<span class="number">1</span>][<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>, filename, <span class="keyword">sizeof</span>(filename), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open %s\n&quot;</span>, filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置从机地址</span></span><br><span class="line">    <span class="keyword">if</span> (set_slave_addr(fd, dev_addr, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t set slave address\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入传感器触发测量的命令</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//写入字：先写低8位,再写高8位</span></span><br><span class="line">        ret = i2c_smbus_write_word_data(fd, <span class="number">0xAC</span>, <span class="number">0x33</span>); </span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i2c_smbus_write_word_data error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环监测传感器设备是否忙</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        ret = i2c_smbus_read_byte(fd);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i2c_smbus_read_byte error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line">    &#125; <span class="keyword">while</span> (ret &amp; <span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过ioctl函数读取I2C设备文件</span></span><br><span class="line">    msg.addr = dev_addr;</span><br><span class="line">    msg.flags = I2C_M_RD;</span><br><span class="line">    msg.len = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">memset</span>(read_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_buffer));</span><br><span class="line">    msg.buf = read_buffer;</span><br><span class="line">    rdwr.msgs = &amp;msg;</span><br><span class="line">    rdwr.nmsgs = <span class="number">1</span>;</span><br><span class="line">    ret = ioctl(fd, I2C_RDWR, &amp;rdwr);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;ioctl_read_error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数据转换为实际温湿度</span></span><br><span class="line">	h = ((<span class="type">uint32_t</span>)read_buffer[<span class="number">1</span>] &lt;&lt; <span class="number">12</span>) | ((<span class="type">uint32_t</span>)read_buffer[<span class="number">2</span>] &lt;&lt; <span class="number">4</span>) | (read_buffer[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>);</span><br><span class="line">	t = ((<span class="type">uint32_t</span>)(read_buffer[<span class="number">3</span>] &amp; <span class="number">0x0f</span>) &lt;&lt; <span class="number">16</span>) | ((<span class="type">uint32_t</span>)read_buffer[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | read_buffer[<span class="number">5</span>];</span><br><span class="line">	temper = <span class="number">-50.0</span> + <span class="number">200.0</span> * (<span class="type">float</span>)t / N;</span><br><span class="line">	humid = <span class="number">100.0</span> * h / N;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;temper=%f, humid=%f \n&quot;</span>, temper, humid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LED驱动程序</title>
    <url>/2023/10/30/LED%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="学会看芯片手册">1.学会看芯片手册</h2>
<h3 id="gpio的通用操作方法">1.1 GPIO的通用操作方法</h3>
<p>参考stm32的GPIO引脚的使用过程：</p>
<ol type="1">
<li>使能GPIOx时钟</li>
<li>设置GPIOx引脚的工作模式（输入、输出、复用、<strong>重定向</strong>）</li>
<li>读取/设置GOPIOx引脚的电平</li>
</ol>
<p>一般的，芯片GPIO引脚使能的操作如下：</p>
<ol type="1">
<li>芯片手册一般有相关章节，用来介绍：power/clock
可以设置对应寄存器使能某个 GPIO 模块(Module) 。有些芯片的 GPIO
是没有使能开关的，即它总是使能的</li>
<li>一个引脚可以用于 GPIO、串口、USB 或其他功能，
有对应的寄存器来选择引脚的功能</li>
<li>对于已经设置为 GPIO
功能的引脚，有方向寄存器用来设置它的方向：输出、输入</li>
<li>对于已经设置为 GPIO
功能的引脚，有数据寄存器用来写、读引脚电平状态</li>
</ol>
<p>对于GPIO写电平状态根据硬件也有两种方式：</p>
<ol type="1">
<li>仅有GPIO数据寄存器：先读，设置位，再写</li>
<li>使用<code>set-and-clear protocol</code>：这种方式，硬件上有三个寄存器<code>set_reg,clr_eg,data_reg</code>，对于置位和复位寄存器，均是在相应位写1执行置位/复位功能，然后由硬件来完成置位/复位。</li>
</ol>
<h3 id="操作imx6ull的gpio点亮led">1.2 操作IMX6ULL的GPIO点亮LED</h3>
<p>在本节，通过查询开发板原理图和芯片手册来获取点亮LED所需要的所有编程所需信息</p>
<h4 id="查看led对应的gpio引脚">1.2.1 查看LED对应的GPIO引脚</h4>
<figure>
<img src="../images/LED驱动程序/image-20231030205647245.png"
alt="image-20231030205647245" />
<figcaption aria-hidden="true">image-20231030205647245</figcaption>
</figure>
<p>在原理图中发现，LED2对应引脚GPIO5_3</p>
<h4 id="gpio的整体框图">1.2.2 GPIO的整体框图</h4>
<figure>
<img src="../images/LED驱动程序/image-20231106193130990.png"
alt="image-20231106193130990" />
<figcaption aria-hidden="true">image-20231106193130990</figcaption>
</figure>
<p>第一次没看懂，当了解完图中的每一个模块后，再来解读图中所表达的内容。</p>
<p>这张图描述了如何定义一个引脚(PAD)的功能。</p>
<ul>
<li>IOMUXC(IO Mulitplexing Control)用来定义每一个PAD的功能
<ul>
<li>IOMUX作为一个cell用来控制一个PAD的多路复用</li>
<li>通过配置寄存器<code>SW_MUX_CTL_PAD_*</code>来定义PAD选择哪一路功能</li>
<li>通过配置寄存器<code>SW_PAD_CTL_PAD_*</code>来定义有关PAD的具体设置，例如引脚的边沿速率，驱动能力等</li>
</ul></li>
<li>GPIO(General-purpose IO)
<ul>
<li>GPIO.DR：数据寄存器，输出模式下用来控制引脚输出电平，输入模式下可以用来读取输入电平</li>
<li>GPIO.GDIR(GPIO direction register)：用来控制GPIO的输入输出方向</li>
<li>GPIO.PSR(Pad status register)：用来读取引脚的电平状态</li>
</ul></li>
<li>CCM(Clock Control Manage)
<ul>
<li>主要就是使能IOMUXC和GPIO模块</li>
</ul></li>
</ul>
<h4 id="iomuxc">1.2.3 IOMUXC</h4>
<blockquote>
<p>IOMUX控制器（IOMUXC）与IOMUX一起使IC能够共享一个焊盘到多个功能块。这种共享是通过多路复用焊盘的输入和输出信号来实现的。每个模块都需要特定的焊盘设置（如上拉或保持器），每个焊盘最多有8个多路复用选项（称为ALT模式）。极板设置参数由IOMUXC控制。IOMUX仅由几个基本IOMUX单元组合而成的组合逻辑组成。每个基本IOMUX单元仅处理一个焊盘信号的复用。</p>
</blockquote>
<h5 id="iomux_cell">（1）IOMUX_cell</h5>
<p>IOMUX由多个（大约是SoC中焊盘的数量）基本IOMUX_cell单元组成。如果特定焊盘<strong>只需要一种功能模式，则不需要IOMUX，并且信号可以直接从模块连接到I/O</strong>。每当特定焊盘需要两个或多个功能模式时，或者当需要一个功能模式和一个测试模式时，都需要IOMUX单元。iomux_cell的基本设计允许两个级别的HW信号控制（在ALT6和ALT7模式下，ALT7获得最高优先级），如图32-2所示。</p>
<p>ALT7和ALT6扩展复用模式允许系统中的任何信号（如保险丝、焊盘输入、JTAG或软件寄存器）覆盖任何软件配置并强制ALT6/ALT7复用模式。它还允许IOMUX软件寄存器控制一组焊盘。</p>
<figure>
<img src="../images/LED驱动程序/image-20231101122916164.png"
alt="image-20231101122916164" />
<figcaption aria-hidden="true">image-20231101122916164</figcaption>
</figure>
<h5 id="寄存器">（2）寄存器</h5>
<p><strong>多路复用控制寄存器</strong></p>
<figure>
<img src="../images/LED驱动程序/image-20231106113954556.png"
alt="image-20231106113954556" />
<figcaption aria-hidden="true">image-20231106113954556</figcaption>
</figure>
<ul>
<li><code>4-SION</code>：<strong>该位用于配置引脚的loopback回环模式，在测试时可以使能方便调试。使能之后会强制将引脚的真实电平状态输入到相应寄存器中，例如GPIOx_PSR寄存器。</strong></li>
<li>这个引脚的多路复用仅有功能<code>ALT5</code>，一般会有<code>ALT0</code>~<code>ALT7</code>八路复用可选。</li>
</ul>
<p><strong>引脚控制寄存器</strong></p>
<figure>
<img src="../images/LED驱动程序/image-20231106114027051.png"
alt="image-20231106114027051" />
<figcaption aria-hidden="true">image-20231106114027051</figcaption>
</figure>
<figure>
<img src="../images/LED驱动程序/image-20231106114042999.png"
alt="image-20231106114042999" />
<figcaption aria-hidden="true">image-20231106114042999</figcaption>
</figure>
<ul>
<li><p><code>16-Hysteresis</code>：输入方式，施密特触发器或者CMOS输入模式。</p></li>
<li><p><code>13-pull/Keep Enable Field</code>：拉电阻/保持电阻，拉电阻就是上拉或者下拉。保持电阻是在引脚浮空时能够使引脚保持在引脚上一时刻的电平状态。</p></li>
<li><p><code>5-3-Drive Strength Field</code>：用于控制输出引脚的驱动能力。驱动能力指的是芯片输出引脚能够提供的电流或功率，它决定了该引脚可以驱动外部电路的能力。</p></li>
<li><p><code>0-Slew Rate Field</code>：用于配置输出引脚的边沿速率（slew
rate）。边沿速率指的是输出信号在从一个电压状态迅速变化到另一个电压状态时的变化速度。</p></li>
</ul>
<h4 id="gpio">1.2.4 GPIO</h4>
<p>GPIO通用框图：</p>
<figure>
<img src="../images/LED驱动程序/image-20231030212700304.png"
alt="image-20231030212700304" />
<figcaption aria-hidden="true">image-20231030212700304</figcaption>
</figure>
<ul>
<li>Data register (GPIO_DR)</li>
<li>Pad status register (GPIO_PSR)</li>
<li>GPIO direction register (GPIO_GDIR)</li>
<li>Edge select register (GPIO_EDGE_SEL)</li>
<li>Interrupt control registers (GPIO_ICR1, GPIO_ICR2)</li>
<li>Interrupt mask register (GPIO_IMR)</li>
<li>Interrupt status register (GPIO_ISR)</li>
</ul>
<p>查询GPIO寄存器的基地址：</p>
<figure>
<img src="../images/LED驱动程序/image-20231129163423384.png"
alt="image-20231129163423384" />
<figcaption aria-hidden="true">image-20231129163423384</figcaption>
</figure>
<h5 id="gpiox_gdir">(1) GPIOx_GDIR</h5>
<figure>
<img src="../images/LED驱动程序/image-20231101120322237.png"
alt="image-20231101120322237" />
<figcaption aria-hidden="true">image-20231101120322237</figcaption>
</figure>
<h5 id="gpiox_dr">(2) GPIOx_DR</h5>
<p>读取DR位的结果取决于IOMUXC输入模式设置和相应的GDIR位，如下所示：</p>
<ul>
<li>如果设置了GDIR[n]，并且IOMUXC输入模式为GPIO，则读取DR[n]将返回DR[n]的内容。</li>
<li>如果设置了GDIR[n]，并且IOMUXC输入模式不是GPIO，则读取DR[n]将返回DR[n]的内容。</li>
<li>如果GDIR[n]被清除，IOMUXC输入模式为GPIO，则读取DR[n]返回相应的输入信号值。</li>
<li>如果GDIR[n]被清除，并且IOMUXC输入模式不是GPIO，那么读取DR[n]总是返回零。</li>
</ul>
<figure>
<img src="../images/LED驱动程序/image-20231129170159399.png"
alt="image-20231129170159399" />
<figcaption aria-hidden="true">image-20231129170159399</figcaption>
</figure>
<h5 id="gpiox_psr">(3) GPIOx_PSR</h5>
<p>GPIO_PSR是一个只读寄存器。每个比特存储对应的输入信号的值（如在IOMUX中配置的）。<strong>此寄存器使用ipg_clk_s时钟进行计时，这意味着只有在访问此位置时才会对输入信号进行采样。每当访问此寄存器进行同步时，都需要两种等待状态。</strong></p>
<figure>
<img src="../images/LED驱动程序/image-20231106202237538.png"
alt="image-20231106202237538" />
<figcaption aria-hidden="true">image-20231106202237538</figcaption>
</figure>
<figure>
<img src="../images/LED驱动程序/image-20231106120228246.png"
alt="image-20231106120228246" />
<figcaption aria-hidden="true">image-20231106120228246</figcaption>
</figure>
<h4 id="ccm">1.2.5 CCM</h4>
<h5 id="gpio使能">(1) GPIO使能</h5>
<figure>
<img src="../images/LED驱动程序/image-20231030215135900.png"
alt="image-20231030215135900" />
<figcaption aria-hidden="true">image-20231030215135900</figcaption>
</figure>
<h5 id="iomuxc使能">(2) IOMUXC使能</h5>
<figure>
<img src="../images/LED驱动程序/image-20231106202806993.png"
alt="image-20231106202806993" />
<figcaption aria-hidden="true">image-20231106202806993</figcaption>
</figure>
<h5 id="如何操作ccgr寄存器">(3) 如何操作CCGR寄存器</h5>
<p>对于每一个<code>CGx</code>配置值及其对应功能如下：</p>
<figure>
<img src="../images/LED驱动程序/image-20231106203816118.png"
alt="image-20231106203816118" />
<figcaption aria-hidden="true">image-20231106203816118</figcaption>
</figure>
<p>例如CCGR1：</p>
<figure>
<img src="../images/LED驱动程序/image-20231106203915142.png"
alt="image-20231106203915142" />
<figcaption aria-hidden="true">image-20231106203915142</figcaption>
</figure>
<p><strong>还可以知道默认几乎所有模块的时钟再上电时都是打开的</strong></p>
<h4 id="总结配置过程">1.2.6 总结配置过程</h4>
<ol type="1">
<li>在CCG模块中使能GPIO和IOMUXC模块的时钟（默认已经使能）</li>
<li>在IOMUXC模块中设置GPIO5_3(SNVS_TAMPER3)焊盘的多路复用和焊盘本身相关配置</li>
<li>在GPIP模块的寄存器GPIOx_GDIR中配置GPIO是输出模式还是输入模式</li>
<li>配置GPIO模块的寄存器GPIOx_DR，配置引脚的电平状态</li>
</ol>
<h2 id="编写led驱动程序">2.编写LED驱动程序</h2>
<p>根据上一篇“编写第一个驱动程序“了解了驱动程序的基本框架，本篇先通过阅读数据手册得知如何配置寄存器才能够点亮LED灯。现在还差的是：如何在驱动程序中读写寄存器。</p>
<h3 id="如何在驱动程序中读写寄存器">2.1 如何在驱动程序中读写寄存器</h3>
<p><strong>将寄存器物理地址映射到虚拟地址</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* GPIO5_GDIR 地址：0x020AC000 + 0x04 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO5_GDIR;</span><br><span class="line"><span class="comment">/* ioremap：将寄存器的物理地址映射为虚拟地址 */</span></span><br><span class="line">GPIO5_GDIR = ioremap(<span class="number">0x020AC000</span> + <span class="number">0x04</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* iounmap：取消虚拟地址的映射 */</span></span><br><span class="line">iounmap(GPIO5_GDIR);</span><br></pre></td></tr></table></figure>
<p><strong>根据虚拟地址读写寄存器</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*GPIO5_GDIR |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h4 id="问题">2.1.1 问题</h4>
<p><strong>问题1：为什么需要将寄存器物理地址映射为虚拟地址？</strong></p>
<p>在Linux系统中，驱动程序在读写硬件寄存器时通常需要将寄存器的物理地址映射成虚拟地址。这涉及到操作系统的虚拟内存管理机制和硬件访问的相关性。</p>
<ol type="1">
<li><strong>抽象硬件访问：</strong>
操作系统的设计目标之一是提供对硬件的抽象，使应用程序和驱动程序能够在不同硬件平台上运行而无需修改。通过将物理地址映射为虚拟地址，驱动程序可以使用虚拟地址来访问硬件资源，而不必担心底层硬件的物理地址。</li>
<li><strong>虚拟内存隔离：</strong>
操作系统使用虚拟内存来提供对内存的隔离和保护。将硬件寄存器的物理地址映射到虚拟地址空间中，使得驱动程序可以利用虚拟内存管理机制，确保不会越界访问或者非法修改其他进程的内存。</li>
<li><strong>内存映射：</strong>
内存映射是一种将文件或设备映射到进程地址空间的技术。通过内存映射，驱动程序可以将硬件寄存器映射到自己的地址空间中，从而使得访问硬件寄存器就像访问内存一样简单。</li>
<li><strong>缓存管理：</strong>
操作系统可以通过虚拟内存管理来优化对硬件寄存器的访问，例如使用缓存。虚拟内存管理可以确保合适的缓存策略用于访问硬件寄存器，提高数据访问的效率。</li>
</ol>
<p>总体而言，将硬件寄存器的物理地址映射为虚拟地址是为了提供更高层次的抽象和隔离，使得驱动程序能够以更安全和通用的方式访问硬件资源。这也有助于确保驱动程序的可移植性和可维护性。</p>
<p><strong>问题2：地址指针为什么需要使用<code>volatile</code>关键字进行修饰？</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO5_GDIR;</span><br></pre></td></tr></table></figure>
<p>在这个声明中，<code>volatile</code>
关键字的作用是告诉编译器，该指针所指向的内存位置的值是可以在程序的控制之外被改变的，因此编译器在优化时应该小心处理这个指针所指向的内存。</p>
<p>在嵌入式系统和驱动程序开发中，经常会涉及到与硬件直接交互的情况。<strong>硬件寄存器的值可能会在程序的正常控制流程之外被外部因素更改，比如中断服务程序、其他设备或者直接由硬件</strong>。使用
<code>volatile</code>
关键字<strong>告诉编译器不要对这些变量的读写进行优化，以确保编译器不会在代码中插入不必要的优化</strong>，例如缓存变量的值，而直接使用缓存中的值，而不是每次都从内存中读取。</p>
<p>在上述代码中，<code>GPIO5_GDIR</code>
是一个指向寄存器的指针，这个寄存器的值可能会被硬件或者中断服务程序在程序的控制之外修改。因此，使用
<code>volatile</code>
关键字是为了确保编译器不会对这个指针进行过度的优化，从而保证读写该寄存器的操作是可见且正确的。</p>
<h3 id="代码">2.2 代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm/io.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm/uaccess.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/printk.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/stddef.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span>	<span class="comment">/* guess what */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/firmware.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span>	<span class="comment">/* For put_user and get_user */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_open</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_close</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* registers */</span></span><br><span class="line"><span class="comment">// IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 地址：0x02290000 + 0x14</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;</span><br><span class="line"><span class="comment">// IOMUXC_SNVS_SW_PAD_CTL_PAD_SNVS_TAMPER3 地址：0x02290000 + 0x58</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SNVS_SW_PAD_CTL_PAD_SNVS_TAMPER3;</span><br><span class="line"><span class="comment">// GPIO5_GDIR 地址：0x020AC000 + 0x04</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO5_GDIR;</span><br><span class="line"><span class="comment">// GPIO5_DR 地址：0x020AC000 + 0x00</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIO5_DR;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局变量 */</span></span><br><span class="line"><span class="type">int</span> major;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">myled_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">myled_fops</span> =</span> &#123;</span><br><span class="line">	.owner		= THIS_MODULE,</span><br><span class="line">    .open = led_drv_open,</span><br><span class="line">    .write = led_drv_write,</span><br><span class="line">	.release = led_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当前所在的源代码文件的文件名 当前所在的函数的名称 代码行号</span></span><br><span class="line">    printk(<span class="string">&quot;file:%s  func:%s  line:%d\n&quot;</span>, __FILE__ , __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="comment">// 注意修改寄存器的值时不要影响其他位</span></span><br><span class="line">	*IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 &amp;= ~<span class="number">0xf</span>; <span class="comment">//先清除</span></span><br><span class="line">	*IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 |= <span class="number">0x5</span>;  <span class="comment">//再赋值，失能测试模式，配置复用为ALT5</span></span><br><span class="line">	*GPIO5_GDIR |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);  <span class="comment">// 配置引脚为输出模式</span></span><br><span class="line">	*GPIO5_DR |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);    <span class="comment">// 先熄灭LED</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_close</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;file:%s  func:%s  line:%d\n&quot;</span>, __FILE__ , __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">//当前所在的源代码文件的文件名 当前所在的函数的名称 代码行号</span></span><br><span class="line">    printk(<span class="string">&quot;file:%s  func:%s  line:%d\n&quot;</span>, __FILE__ , __FUNCTION__, __LINE__);</span><br><span class="line">	ret = copy_from_user(&amp;c, buf, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">		<span class="comment">/* set led on*/</span></span><br><span class="line">		*GPIO5_DR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="comment">/* set led off */</span></span><br><span class="line">		*GPIO5_DR |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init_driver</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;file:%s  func:%s  line:%d\n&quot;</span>, __FILE__ , __FUNCTION__, __LINE__);</span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;myled&quot;</span>, &amp;myled_fops);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* ioremap：将寄存器的物理地址映射为虚拟地址 */</span></span><br><span class="line">	IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(<span class="number">0x02290000</span> + <span class="number">0x14</span>, <span class="number">4</span>);</span><br><span class="line">	IOMUXC_SNVS_SW_PAD_CTL_PAD_SNVS_TAMPER3 = ioremap(<span class="number">0x02290000</span> + <span class="number">0x58</span>, <span class="number">4</span>);</span><br><span class="line">	GPIO5_GDIR = ioremap(<span class="number">0x020AC000</span> + <span class="number">0x04</span>, <span class="number">4</span>);</span><br><span class="line">	GPIO5_DR = ioremap(<span class="number">0x020AC000</span> + <span class="number">0x00</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	myled_class = class_create(THIS_MODULE, <span class="string">&quot;myled&quot;</span>);</span><br><span class="line">    device_create(myled_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;myled&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit_driver</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* iounmap：取消虚拟地址的映射 */</span></span><br><span class="line">	iounmap(IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3);</span><br><span class="line">	iounmap(IOMUXC_SNVS_SW_PAD_CTL_PAD_SNVS_TAMPER3);</span><br><span class="line">	iounmap(GPIO5_DR);</span><br><span class="line">	iounmap(GPIO5_GDIR);</span><br><span class="line">	</span><br><span class="line">	device_destroy(myled_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(myled_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;myled&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init_driver);</span><br><span class="line">module_exit(led_exit_driver);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>然后，简单编写一个APP用来测试：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/myled&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open error &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;input one char (1:led on, q:quit, other: led off):&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;q&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ret = write(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;write error &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统基本知识</title>
    <url>/2023/09/01/Linux%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="根目录结构fsh标准">1.根目录结构（FSH标准）</h2>
<ul>
<li><p>/bin：<strong>所有用户</strong>都可以使用的、<strong>基本的</strong>命令</p></li>
<li><p>/boot：启动文件，比如内核等</p></li>
<li><p>/dev：以文件的形式保存 Linux 所有的设备及接口设备</p></li>
<li><p>/etc：配置文件</p></li>
<li><p>/home：家目录</p></li>
<li><p>/root：root用户的家目录</p></li>
<li><p>/lib：主要放置系统开机使用的、/bin 和 /sbin
目录下的命令使用的库函数</p></li>
<li><p>/media：插上U盘等外设会挂在到该目录上</p></li>
<li><p>/mnt：用来挂载其他文件系统</p></li>
<li><p>/opt：第三方软件放置的目录</p></li>
<li><p>/proc：这个目录是一个虚拟文件系统，它放置的数据都是在内存当中，例如进程、外部设备状态、网络状态等</p></li>
<li><p>/sbin：该目录下放置开机过程中需要的命令，包括开机、修复、还原系统等</p></li>
<li><p>/sys：用来挂载虛拟的sys文件系统，可以查看系统信息:比如设备信息</p></li>
<li><p>/tmp：置文件的地方</p></li>
<li><p>/var：放置常态化变动的文件，例如缓存、登录日志文件、软件运行产生的文件等</p></li>
<li><p>/usr：<code>Unix Software Resource</code>，存放可分享的与<strong>不可变动</strong>的数据</p>
<ul>
<li>/bin：绝大部分的用户可使用指令都放在这里(与开机无关)，/bin中的命令跟开机有关</li>
<li>/include：C/C++的头文件和包含文件</li>
<li>/lib：库</li>
<li>/local：系统管理员在本机自行下载的软件</li>
<li>/usr/src/：源码放置的地方</li>
<li>/usr/share/：放置共享文件的地方</li>
<li>/usr/sbin/：非系统正常运行需要的系统命令</li>
</ul></li>
</ul>
<h3 id="shell的执行">1.1 Shell的执行</h3>
<ol type="1">
<li>解析用户输入(以空格分割字符串)</li>
<li>第一个参数为需要待执行程序的名称（<strong>在指定路径或者环境变量包含路径中寻找</strong>）</li>
<li>其余参数为传递给该程序的参数</li>
</ol>
<ul>
<li><p>举例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hello.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> ac, <span class="type">char</span>*av[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(ac &gt;= <span class="number">2</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, av[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Hello wrold\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下命令编译并执行，则在当前目录下寻找可执行文件hello：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc hello.c -o hello</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./hello Krocz</span></span><br></pre></td></tr></table></figure>
<p>如果使用如下命令执行，则会在环境变量保存的所有路径中寻找可执行文件hello：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hello Krocz</span></span><br></pre></td></tr></table></figure>
<p>可以选择将文件hello放到PATH保存的某个路径中，例如<code>/usr/bin</code>；也可以为环境变量PATH添加新路径</p></li>
</ul>
<h3 id="为环境变量path添加新路径">1.2 为环境变量PATH添加新路径</h3>
<h4 id="查看path">1.2.1 查看PATH</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>
<h4 id="设置">1.2.2 设置</h4>
<p>以在PATH添加/home/book目录为例：</p>
<ul>
<li><p>永久设置(对所有用户有效)：方法1</p>
<p>修改/etc/environment，添加/home/book路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/book&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>永久设置(只对当前用户有效)：方法2</p>
<p>修改~/.bashrc，在行尾添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/home/book</span><br></pre></td></tr></table></figure></li>
<li><p>临时设置</p>
<p>在终端执行如下命令，只对当前终端有效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/home/book</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="文件的目录属性">2.文件的目录属性</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-rw-r-- 1 zhaoyan zhaoyan 1497 11月 12 14:08 a.txt</span><br><span class="line">drwxrwxr-x 3 zhaoyan zhaoyan 4096 10月  9 18:39 C</span><br></pre></td></tr></table></figure>
<ul>
<li>模式(mode):首位表示文件类型
<ul>
<li><code>-</code>：普通文件</li>
<li><code>d</code>：目录</li>
<li><code>c</code>：字符设备文件</li>
<li><code>b</code>：块设备文件</li>
<li><code>l</code>：链接文件</li>
<li><code>s</code>：套接字文件</li>
<li><code>p</code>：管道文件</li>
<li></li>
</ul></li>
<li>链接数(links):指该文件被引用的次数</li>
<li>文件所有者(owner):</li>
<li>组(group):文件所有者所在的组</li>
<li>大小(size):显示文件的大小，单位是字节，目录所占空间是以块(每块512字节)为单位进行分配的，所以目录的大小经常是相等的</li>
<li>最后修改时间(last-modified)</li>
<li>文件名(name)</li>
</ul>
<h2 id="常用命令">3.常用命令</h2>
<ul>
<li>ctrl + c：清空命令并且换行；还可以用来强制中止进程运行</li>
<li>ctrl + z：挂起一个进程</li>
<li>ctrl + u：清空当前命令行</li>
<li>转义：
<ul>
<li>命名含有空格：需要加上<code>\</code>转义，例如：<code>mkdir ac\ wing</code></li>
<li>正则表达式中<code>.</code>通常表示任意<strong>单</strong>字符，因此如果想让点号作为其本意，也需要<code>\</code>转义</li>
</ul></li>
<li>ls：蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</li>
</ul>
<h3 id="压缩解压缩命令">3.1 压缩/解压缩命令</h3>
<h4 id="gzipbzip2">3.1.1 gzip/bzip2</h4>
<ul>
<li><p>gzip/bzip2常用选项：</p>
<ul>
<li>-l（list）：列出压缩文件的内容</li>
<li>-k（keep）：在压缩或解压时，保留输入文件</li>
<li>-d（decopress）：将压缩文件进行解压缩(仅gzip有该参数)</li>
</ul></li>
<li><p>举例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gzip -l a.txt.gz        //查看压缩文件信息</span><br><span class="line">gzip -k a.txt           //压缩该文件</span><br><span class="line">gzip -kd a.txt.gz       //解压缩</span><br></pre></td></tr></table></figure></li>
<li><p>注意：</p>
<ul>
<li>gzip/bzip2仅能压缩单个文件，<strong>不能压缩目录</strong></li>
<li>一般情况下，小文件使用gzip来压缩，大文件使用bzip2来压缩。bzip2的压缩率更高</li>
<li>gzip压缩的后缀是<code>.gz</code>，bzip2的压缩后缀是<code>.bz2</code></li>
</ul></li>
</ul>
<h4 id="tar">3.1.2 tar</h4>
<ul>
<li><p>tar 常用选项：</p>
<ul>
<li>-c(create)：表示创建用来生成文件包 。</li>
<li>-x：表示提取，从文件包中提取文件。</li>
<li>-t：可以查看压缩的文件。</li>
<li>-z：使用 gzip
方式进行处理，它与”c“结合就表示压缩，与”x“结合就表示解压缩。</li>
<li>-j：使用 bzip2
方式进行处理，它与”c“结合就表示压缩，与”x“结合就表示解压缩。</li>
<li>-v(verbose)：详细报告 tar 处理的信息。</li>
<li>-f(file)：表示文件，后面接着一个文件名。</li>
<li>-C <指定目录> 解压到指定目录。</li>
</ul></li>
<li><p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar czvf dira.tar.gz dira            //把目录 dira 压缩、打包为 dira.tar.gz 文件</span><br><span class="line">tar tvf dira.tar.gz                  //查看压缩文件</span><br><span class="line">tar xzvf diar.tar.gz -C /home/book   //解压到/home/book</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="查找搜索命令">3.2 查找/搜索命令</h3>
<h4 id="查找文件-find">3.2.1 查找文件-find</h4>
<ul>
<li><p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /home/book/dira/ -name &quot;dir or file name&quot;  // 在指定目录下按名称查找</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="搜索文件内容-grep">3.2.2 搜索文件内容-grep</h4>
<ul>
<li><p>grep常用选项：</p>
<ul>
<li>-r：递归</li>
<li>-n：显示目标位置的行号</li>
<li>-w：完全匹配所给字符串</li>
</ul></li>
<li><p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -nw &quot;abc&quot; test1.txt        //在文件test1.txt中查找并完全匹配字符串&quot;abc&quot;</span><br><span class="line">grep -rn &quot;abc&quot; * | grep &quot;\.h&quot;  //在当前文件夹下查找字符串&quot;abc&quot;，并通过管道将查找结果传给第2个命令 </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="改变文件权限-chmod">3.3 改变文件权限-chmod</h3>
<ul>
<li><p>权限对应数字：<code>r:4   w:2   x:1</code></p></li>
<li><p>用户组对应字母：<code>user:u   group:g    others:o</code>，<code>a</code>表示all，即所有组</p></li>
<li><p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 .bashrc</span><br><span class="line">chmod -r u=rwx,go=rx dir</span><br><span class="line">chmod a-x .bashrc         </span><br><span class="line">chmod a+w .bashrc</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="文件传输-scp">3.4 文件传输-scp</h3>
<h4 id="基本用法">3.4.1 基本用法</h4>
<p>命令格式： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp source destination</span><br></pre></td></tr></table></figure>
将<code>source</code>路径下的文件复制到<code>destination</code>中
**注意服务器的地址应该写为：<code>user@ip:XXX</code></p>
<h4 id="举例">3.4.2 举例</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r ~/tmp user@ip:/home/acs/</span><br></pre></td></tr></table></figure>
<ul>
<li>将本地家目录中的<code>tmp</code>文件夹复制到<code>user@ip</code>服务器中的<code>/home/acs/</code>目录下。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r user@ip:homework . </span><br></pre></td></tr></table></figure>
<ul>
<li>将<code>user@ip</code>服务器中的<code>~/homework/</code>文件夹复制到本地的当前路径下。</li>
</ul>
<h3 id="进程状态-ps">3.5 进程状态-ps</h3>
<p>ps(process status)用于显示当前进程的状态。</p>
<ul>
<li>常用参数：
<ul>
<li>-A：列出所有进程</li>
<li>-ef：使用System V风格列出进程信息</li>
<li>-u：跟用户名参数，显示该用户的进程信息</li>
<li>-T：查看线程</li>
</ul></li>
</ul>
<h4 id="举例-1">3.5.1 举例</h4>
<ul>
<li>分页显示所有进程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | more</span><br></pre></td></tr></table></figure>
<figure>
<img src="../images/Linux系统基本知识/image-20230905211714592.png"
alt="image-20230905211714592" />
<figcaption aria-hidden="true">image-20230905211714592</figcaption>
</figure>
<p>列出信息每字段的含义：</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th>列</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>UID</td>
<td>用户的ID ，但输出的是用户名</td>
</tr>
<tr class="even">
<td>PID</td>
<td>进程的ID</td>
</tr>
<tr class="odd">
<td>PPID</td>
<td>父进程的ID</td>
</tr>
<tr class="even">
<td>C</td>
<td>进程占用CPU的百分比</td>
</tr>
<tr class="odd">
<td>STIME</td>
<td>进程启用到现在的时间</td>
</tr>
<tr class="even">
<td>TTY</td>
<td>该进程在哪个终端上运行，若与终端无关，则显示？，若为pts/0等，则表示由网络连接主机进程</td>
</tr>
<tr class="odd">
<td>TIME</td>
<td>该进程实际使用CPU运行的时间</td>
</tr>
<tr class="even">
<td>CMD</td>
<td>命令的名称和参数</td>
</tr>
</tbody>
</table>
<ul>
<li>显示指定用户的进程，通过grep命令筛选</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -u root | grep nfs</span><br></pre></td></tr></table></figure>
<h3 id="终止进程命令-kill">3.6 终止进程命令-kill</h3>
<p><code>kill -n</code>：n表示信号编号</p>
<ul>
<li><p><code>kill pid</code>、<code>kill -15 pid</code></p>
<p>系统会发送一个SIGTERM的信号给对应的程序。当程序接收到该signal后，将会发生以下的事情：</p>
<ol type="1">
<li>程序立刻停止</li>
<li>当程序释放相应资源后再停止</li>
<li>程序可能仍然继续运行，例如程序正在等待IO，可能就不会立马做出相应</li>
</ol>
<p>也就是说，SIGTERM多半是会被阻塞的、忽略。</p></li>
<li><p><code>kill -9 pid</code></p>
<p>系统会发送一个SIGKILL的信号给对应的程序。用来强制尽快终止一个进程。绝大部分程序收到后都会立刻终止。</p></li>
</ul>
<h3 id="编译命令-make">3.7 编译命令-make</h3>
<ul>
<li><p>常见参数</p>
<table>
<colgroup>
<col style="width: 35%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>-c DIR</code> or <code>--directory=DIR</code></td>
<td>在读取 Makefile 之前，进入到目录 DIR，然后执行 make。</td>
</tr>
<tr class="even">
<td><code>-f FILE</code> or <code>--file=FILE</code></td>
<td>指定文件 "FILE" 为 make 执行的 Makefile 文件</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table></li>
</ul>
<h3 id="内核模块命令">3.8 内核模块命令</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insmod hello_drv.ko    //安装内核驱动模块</span><br><span class="line">cat /proc/devices     // 查看/proc/devices文件,该文件列出字符和块设备的主设备号,以及分配到这些设备号的设备名称</span><br><span class="line">lsmod                // 列出所有已安装的内核模块</span><br><span class="line">ls /dev/hello -l     // 查看设备节点是否存在</span><br><span class="line">rmmod hello_drv      // 卸载内核驱动模块</span><br><span class="line">dmesg                // 查看内核输出的打印信息</span><br></pre></td></tr></table></figure>
<h3 id="查看进程的内存映射区域">3.9 查看进程的内存映射区域</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cat /proc/&lt;进程PID&gt;/maps</span><br></pre></td></tr></table></figure>
<p>每行的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address  perms offset  dev   inode   pathname</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>address（地址范围）：</strong>
表示映射的虚拟地址范围。这是一个区间，以十六进制表示，包括起始地址和结束地址。例如，<code>08048000-08056000</code>
表示一个从 <code>0x08048000</code> 到 <code>0x08056000</code>
的地址范围。</li>
<li><strong>perms（权限标志）：</strong>
表示对该内存区域的访问权限。常见的权限标志包括：
<ul>
<li><code>r</code>：可读（read）</li>
<li><code>w</code>：可写（write）</li>
<li><code>x</code>：可执行（execute）</li>
<li><code>p</code>：私有（private） -
表示该区域是进程私有的，对其他进程不可见。</li>
<li><code>s</code>：共享 （share）</li>
</ul></li>
<li><strong>offset（文件偏移量）：</strong>
对于映射的文件来说，表示在文件中的偏移量。对于非文件映射，这通常是0。</li>
<li><strong>dev（设备标识）：</strong>
表示映射的文件所在的设备。它由两个十六进制数表示，分别表示主设备号和次设备号。</li>
<li><strong>inode（节点号）：</strong>
表示映射的文件在文件系统中的索引节点号。</li>
<li><strong>pathname（文件路径）：</strong>
表示映射的文件的路径。如果是匿名映射（例如堆、栈等），可能显示为<code>[stack]</code>、<code>[heap]</code>等。</li>
</ul>
<h2 id="记录环境搭建过程">4. 记录环境搭建过程</h2>
<ol type="1">
<li><p>在Ubuntu上安装基本开发环境</p></li>
<li><p>通过repo命令下载BSP：</p>
<ol type="1">
<li><p>板级支持包-Board Support
Package：构建嵌入式操作系统所需的引导程序(Bootloader)、内核(Kernel)、根文件系统(Rootfs)和工具链(Toolchain)
提供完整的软件资源包。</p></li>
<li><p>```shell ~/100ask_imx6ull_mini-sdk$ ../repo/repo init -u
https://gitee.com/weidongshan/manifests.git -b linux-sdk -m
imx6ull/100ask_imx6ull_mini_linux4.9.88_release.xml --no-repo-verify</p>
<p>~/100ask_imx6ull_mini-sdk$ ../repo/repo sync -j4
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   3. `../repo/repo init`: 这是命令本身，指示系统执行repo工具进行初始化操作。</span><br><span class="line"></span><br><span class="line">   4. `-u https://gitee.com/weidongshan/manifests.git`: `-u`选项指定了远程仓库的URL。在这个命令中，远程仓库的URL是`https://gitee.com/weidongshan/manifests.git`，即来自Gitee平台的`manifests.git`仓库。</span><br><span class="line"></span><br><span class="line">   5. `-b linux-sdk`: `-b`选项指定了要下载的分支。在这个命令中，分支是`linux-sdk`。</span><br><span class="line"></span><br><span class="line">   6. `-m imx6ull/100ask_imx6ull_mini_linux4.9.88_release.xml`: `-m`选项指定了清单文件的路径。在这个命令中，清单文件的路径是`imx6ull/100ask_imx6ull_mini_linux4.9.88_release.xml`。</span><br><span class="line"></span><br><span class="line">   7. `--no-repo-verify`: 这是一个额外的选项，用于跳过对repo的验证。如果仓库包含了repo和.git/ repo目录已经被修改或破坏，这个选项可以防止运行`repo init`时出现错误。</span><br><span class="line"></span><br><span class="line">   8. `./repo/repo sync`: 这是命令本身，指示系统执行repo工具进行代码仓库的同步操作。</span><br><span class="line"></span><br><span class="line">   9. `-j4`: `-j`选项用于指定并行任务的数量，后面的数字4表示同时执行4个任务。这个选项可以根据系统性能和网络环境进行调整，以加快代码同步的速度。</span><br><span class="line"></span><br><span class="line">3. 配置交叉编译工具链(仅对当前用户有效)：</span><br><span class="line"></span><br><span class="line">   1. ```shell</span><br><span class="line">      1.在 ~/.bashrc中添加：</span><br><span class="line">      export ARCH=arm </span><br><span class="line">      export CROSS_COMPILE=arm-buildroot-linux-gnueabihf-</span><br><span class="line">      export PATH=$PATH:/home/book/100ask_imx6ull_mini-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin</span><br><span class="line">      </span><br><span class="line">      2.设置完成之后执行 source ~/.bashrc</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行了<code>source ~/.bashrc</code>命令，它会重新加载你对<code>~/.bashrc</code>文件的修改，使得刚才添加的环境变量生效。</p></li>
</ol></li>
<li><p><a
href="https://blog.csdn.net/thisway_diy/article/details/127556249">在Windows使用VSCode搭建嵌入式Linux开发环境_韦东山的博客-CSDN博客</a></p>
<ol type="1">
<li><p>安装bear：<code>sudo apt-get install bear</code>.</p>
<ul>
<li>Bear是一种生成代码注释的工具。它可以扫描源代码文件，并根据函数、类、变量等的定义自动生成注释模板。通过使用Bear，开发人员可以快速地为自己的代码添加注释，提高代码的可读性和可维护性。注释可以在代码中提供有关功能、参数、返回值等的说明，帮助开发人员理解代码的作用和使用方法。</li>
<li>Bear的用法：<code>bear make [其他make命令的参数]</code>，bear会记录make编译文件过程中被调用的编译器命令，以便生成编译数据库。编译数据库(compile_commands.json文件)在后续的代码分析和语义补全等开发工具中可以使用。</li>
</ul></li>
<li><p>编译内核：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /home/book/100ask_imx6ull-sdk/Linux-4.9.88</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make 100ask_imx6ull_defconfig</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">bear make zImage -j4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>100ask_imx6ull_defconfig是Linux内核提供的一个配置文件，用于设置编译选项和配置信息，从而能够编译出与开发板相对应的配置</li>
<li>使用 make 工具执行 <code>zImage</code> 目标，该目标用于编译 Linux
内核。</li>
</ul></li>
</ol></li>
</ol>
<h2 id="linux系统的环境变量">5. Linux系统的环境变量</h2>
<p>在配置和使用交叉编译器时，我使用了如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">配置：</span><br><span class="line">export ARCH=arm </span><br><span class="line">export CROSS_COMPILE=arm-buildroot-linux-gnueabihf-</span><br><span class="line">export PATH=$PATH:/home/book/100ask_imx6ull_mini-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin</span><br><span class="line">使用：</span><br><span class="line">arm-buildroot-linux-gnueabihf-gcc -o hello hello.c</span><br></pre></td></tr></table></figure>
<h3 id="配置命令解读">5.1 配置命令解读</h3>
<p><code>ARCH</code>,<code>CROSS_COMPILE</code>,<code>PATH</code>是Linux系统中被广泛使用的特定环境变量。</p>
<ol type="1">
<li><code>ARCH=arm</code>：指定编译的目标架构为ARM，这是为了告诉系统你将使用ARM架构的交叉编译工具链。</li>
<li><code>CROSS_COMPILE=arm-buildroot-linux-gnueabihf-</code>：这个变量指定了交叉编译工具链的前缀。<code>CROSS_COMPILE</code>是一个特定环境变量，用以命令补全。</li>
<li><code>arm-buildroot-linux-gnueabihf-gcc -o hello hello.c</code>使用该工具链中的gcc编译器进行编译，如果想编译Java文件，则应使用<code>arm-buildroot-linux-gnueabihf-javac</code></li>
<li><code>PATH=$PATH:/home/book/100ask_imx6ull_mini-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin</code>：将交叉编译工具链的路径添加到系统的<code>PATH</code>环境变量中，从而可以寻找到命令的可执行文件。</li>
</ol>
<h3 id="交叉编译工具链">5.2 交叉编译工具链</h3>
<ul>
<li><p>交叉编译器前缀之所以设置为<code>arm-buildroot-linux-gnueabihf</code>，这是由于工具链的<strong>命名约定</strong>。不同的交叉编译器前缀对应不同的架构和操作系统。</p></li>
<li><p>例如，"arm-buildroot-linux-gnueabihf-"前缀表示编译器适用于ARM架构，并且在Linux环境下使用GNUEABI的标准。<code>eabi</code>表示嵌入式应用二进制接口，<code>hf</code>表示硬浮点支持，<code>buildroot</code>表示交叉编译器是基于<strong>Buildroot嵌入式Linux构建系统</strong>生成的。</p></li>
<li><p>常见的交叉编译器前缀示例：</p>
<ul>
<li>arm-linux-gnueabi-：用于ARM架构的Linux环境下的GNUEABI标准。</li>
<li>arm-linux-gnueabihf-：用于ARM架构的Linux环境下的GNUEABIHF标准，支持硬浮点运算。</li>
<li>arm-none-linux-gnueabi-：用于ARM架构的无操作系统或裸机环境下的GNUEABI标准。</li>
<li>arm-none-eabi-：用于ARM架构的无操作系统或裸机环境下的EABI（嵌入式应用程序接口）标准。</li>
<li>mips-linux-gnu-：用于MIPS架构的Linux环境下的GNU标准。</li>
<li>powerpc-linux-gnu-：用于PowerPC架构的Linux环境下的GNU标准。</li>
<li>x86_64-linux-gnu-：用于x86_64架构的Linux环境下的GNU标准。</li>
</ul></li>
</ul>
<h3 id="linux中常用环境变量">5.3 Linux中常用环境变量</h3>
<ol type="1">
<li><code>PATH</code>：这是一个包含可执行文件路径的环境变量。当你输入一个命令时，Shell会在<code>PATH</code>中定义的路径中搜索可执行文件。</li>
<li><code>HOME</code>：表示当前用户的主文件夹路径。当你打开终端或使用文件系统路径时，它可以帮助系统定位到当前用户的主文件夹。</li>
<li><code>USER</code>：表示当前登录用户的用户名。</li>
<li><code>TERM</code>：此变量定义了终端类型。它告诉系统如何正确处理和显示终端上的输出，以确保兼容性和正确的显示。</li>
<li><code>PS1</code>：这是Shell提示符的设置。它定义了你在命令行中看到的用户提示符的样式和内容。</li>
<li><code>LANG</code>和<code>LC_ALL</code>：这些环境变量用于指定系统的语言和地区设置。它们对于国际化和本地化非常重要，帮助系统在正确的语言环境下运行和显示信息。</li>
<li><code>SHELL</code>：表示当前使用的Shell。当你同时安装了多个Shell时，这个变量可以帮助系统确定正在使用的默认Shell。</li>
</ol>
<ul>
<li>环境变量配置文件的位置：
<ul>
<li>~/.bash_profile：用于个人用户的bash登录 shell的配置文件。</li>
<li>~/.bashrc：用于个人用户的bash非登录 shell的配置文件。</li>
<li>/etc/profile：用于全局系统范围的bash登录 shell的配置文件。</li>
<li>/etc/environment：用于整个系统的全局环境变量配置文件。</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>LED驱动程序框架</title>
    <url>/2024/01/02/LED%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="led驱动程序框架设计-分离">1.LED驱动程序框架设计-分离</h2>
<p>在上一篇博文中编写的驱动程序仅能操作固定开发板上的一个LED灯。考虑现实情况，使用同一款主控芯片，不同厂家可能会设计不同的PCB板，针对硬件使用的芯片引脚各不相同，但是同一款主控针对同一硬件的设置都是相似的。因此，我们考虑针对通用LED驱动程序，主控芯片，开发板来分离出三层，以便我们的LED驱动程序能够支持不同主控不同开发板使用：</p>
<figure>
<img src="../images/LED驱动程序框架/image-20231202161816859.png"
alt="image-20231202161816859" />
<figcaption aria-hidden="true">image-20231202161816859</figcaption>
</figure>
<h3 id="开发板层">1.1 开发板层</h3>
<p>led_resources.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LED_RESOURCES_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED_RESOURCES_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROUP(x) (x &gt;&gt; 16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN(x) (x &amp; 0xFFFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROUP_PIN(g, p) ((g &lt;&lt; 16) | (p))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_resources</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> pins[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> led_resources *<span class="title function_">get_led_resouce</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !_LED_RESOUS_H_</span></span></span><br></pre></td></tr></table></figure>
<p>board_A_imx6ull.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_resources.h&quot;</span></span></span><br><span class="line"><span class="comment">// static:该变量对外不可见，仅能通过get_led_resource函数获取</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_resources</span> <span class="title">board_A_imx6ll</span> =</span> &#123;</span><br><span class="line">    .pins = &#123; GROUP_PIN(<span class="number">5</span>, <span class="number">3</span>), GROUP_PIN(<span class="number">1</span>, <span class="number">1</span>)&#125;,</span><br><span class="line">    .num = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> led_resources *<span class="title function_">get_led_resouce</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;board_A_imx6ll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该层主要定义开发板上所分别的LED资源，通过定义结构体<code>led_resources</code>并向上一层提供get函数。</p>
<p>在示例中定义了<code>GPIO5_3</code>和<code>GPIO1_1</code>两个LED引脚。针对不同的开发板需要编写不同.c文件来定义LED引脚。</p>
<h3 id="芯片层">1.2 芯片层</h3>
<p>led_operations.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LED_OPERATIONS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED_OPERATIONS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOMUXC_SNVS_BASE_ADDRESS 0x02290000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 (IOMUXC_SNVS_BASE_ADDRESS + 0x14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOMUXC_SNVS_SW_PAD_CTL_PAD_SNVS_TAMPER3 (IOMUXC_SNVS_BASE_ADDRESS + 0x58)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOMUXC_BASE_ADDRESS 0x020E0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO01 (IOMUXC_BASE_ADDRESS + 0x60)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO01 (IOMUXC_BASE_ADDRESS + 0x2EC)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO5_BASE_ADDRESS 0x020AC000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO5_GDIR (GPIO5_BASE_ADDRESS + 0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO5_DR (GPIO5_BASE_ADDRESS + 0x00)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_BASE_ADDRESS 0x0209C000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_GDIR (GPIO1_BASE_ADDRESS + 0x04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO1_DR (GPIO1_BASE_ADDRESS + 0x00)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*init)(<span class="type">int</span> which);</span><br><span class="line">    <span class="type">int</span> (*ctl) (<span class="type">int</span> which, <span class="type">char</span> status);</span><br><span class="line">    <span class="type">int</span> (*get_led_num)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">int</span> (*close)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> led_operations *<span class="title function_">get_chip_led_operations</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// !_LED_OPERATIONS_H_</span></span></span><br></pre></td></tr></table></figure>
<p>在芯片层的.h文件中，定义所有可能成为LED引脚的相关寄存器地址（当然作为测试仅定义了<code>GPIO5_3</code>和<code>GPIO1_1</code>的相关寄存器），以及定义该芯片实现LED操作所需要的函数，以供上一层调用。</p>
<p>chip_imx6ull_gpio.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_operations.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_resources.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_resources</span> *<span class="title">led_rsc</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* registers */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_MUX_CTL_PAD_Pin_Virtual;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_PAD_CTL_PAD_Pin_Virtual;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIOx_GDIR_Virtual;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *GPIOx_DR_Virtual;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_led_init</span><span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 初始化LED, which-哪个LED */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> val;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d, led %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, which);</span><br><span class="line">    <span class="keyword">if</span> (!led_rsc)</span><br><span class="line">        led_rsc = get_led_resouce();</span><br><span class="line">    <span class="keyword">if</span> (which &gt; led_rsc-&gt;num)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    printk(<span class="string">&quot;init gpio: group %d, pin %d\n&quot;</span>, GROUP(led_rsc-&gt;pins[which]), PIN(led_rsc-&gt;pins[which]));</span><br><span class="line">    <span class="keyword">switch</span> (led_rsc-&gt;pins[which])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title function_">GROUP_PIN</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span>: &#123;</span><br><span class="line">        printk(<span class="string">&quot;init pin of GPIO5_3 ...\n&quot;</span>);</span><br><span class="line">        IOMUXC_MUX_CTL_PAD_Pin_Virtual = ioremap(IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3, <span class="number">4</span>);</span><br><span class="line">        IOMUXC_PAD_CTL_PAD_Pin_Virtual = ioremap(IOMUXC_SNVS_SW_PAD_CTL_PAD_SNVS_TAMPER3, <span class="number">4</span>);</span><br><span class="line">        GPIOx_GDIR_Virtual = ioremap(GPIO5_GDIR, <span class="number">4</span>);</span><br><span class="line">        GPIOx_DR_Virtual = ioremap(GPIO5_DR, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        *GPIOx_GDIR_Virtual |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>); <span class="comment">// 配置引脚为输出模式</span></span><br><span class="line">        *GPIOx_DR_Virtual |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);   <span class="comment">// 先熄灭LED</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title function_">GROUP_PIN</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span>: &#123;</span><br><span class="line">        printk(<span class="string">&quot;init pin of group GPIO1_1 ...\n&quot;</span>);</span><br><span class="line">        IOMUXC_MUX_CTL_PAD_Pin_Virtual = ioremap(IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO01, <span class="number">4</span>);</span><br><span class="line">        IOMUXC_PAD_CTL_PAD_Pin_Virtual = ioremap(IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO01, <span class="number">4</span>);</span><br><span class="line">        GPIOx_GDIR_Virtual = ioremap(GPIO1_GDIR, <span class="number">4</span>);</span><br><span class="line">        GPIOx_DR_Virtual = ioremap(GPIO1_DR, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val = *IOMUXC_MUX_CTL_PAD_Pin_Virtual;</span><br><span class="line">    *IOMUXC_MUX_CTL_PAD_Pin_Virtual = (val &amp; (~<span class="number">0xf</span>)) | <span class="number">0x5</span>; <span class="comment">// 先清除,再赋值，失能测试模式，配置复用为ALT5</span></span><br><span class="line">    *GPIOx_GDIR_Virtual |= (<span class="number">1</span> &lt;&lt; PIN(led_rsc-&gt;pins[which])); <span class="comment">// 配置引脚为输出模式</span></span><br><span class="line">    *GPIOx_DR_Virtual |= (<span class="number">1</span> &lt;&lt; PIN(led_rsc-&gt;pins[which]));   <span class="comment">// 先熄灭LED</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_led_ctl</span><span class="params">(<span class="type">int</span> which, <span class="type">char</span> status)</span> <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d, led %d, status: %s\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, which,</span><br><span class="line">           (status == <span class="number">1</span> ? <span class="string">&quot;on&quot;</span> : <span class="string">&quot;off&quot;</span>));</span><br><span class="line">    printk(<span class="string">&quot;set led %s: group %d, pin %d\n&quot;</span>, status ? <span class="string">&quot;on&quot;</span> : <span class="string">&quot;off&quot;</span>, GROUP(led_rsc-&gt;pins[which]),</span><br><span class="line">           PIN(led_rsc-&gt;pins[which]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status)</span><br><span class="line">        *GPIOx_DR_Virtual &amp;= ~(<span class="number">1</span> &lt;&lt; PIN(led_rsc-&gt;pins[which])); <span class="comment">/* set led on*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *GPIOx_DR_Virtual |= (<span class="number">1</span> &lt;&lt; PIN(led_rsc-&gt;pins[which])); <span class="comment">/* set led off */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_board_led_num</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!led_rsc)</span><br><span class="line">        led_rsc = get_led_resouce();</span><br><span class="line">    <span class="keyword">return</span> led_rsc-&gt;num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_led_close</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    iounmap(IOMUXC_MUX_CTL_PAD_Pin_Virtual);</span><br><span class="line">    iounmap(IOMUXC_PAD_CTL_PAD_Pin_Virtual);</span><br><span class="line">    iounmap(GPIOx_GDIR_Virtual);</span><br><span class="line">    iounmap(GPIOx_DR_Virtual);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> <span class="title">chip_imx6ll_led_opr</span> =</span> &#123;</span><br><span class="line">    .init = chip_led_init,</span><br><span class="line">    .ctl = chip_led_ctl,</span><br><span class="line">    .close = chip_led_close,</span><br><span class="line">    .get_led_num = get_board_led_num,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> led_operations *<span class="title function_">get_chip_led_operations</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;chip_imx6ll_led_opr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在芯片层的.c文件中实现了<code>led_operations</code>结构体中定义函数，该.c文件所实现的函数是针对imx6ull芯片而开发的。支持其他芯片在新的.c文件中实现相应的操作逻辑。</p>
<h3 id="通用led驱动程序">1.3 通用LED驱动程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_operations.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/printk.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 确定主设备号                                                                 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> *<span class="title">p_led_opr</span>;</span></span><br><span class="line"><span class="type">int</span> led_num;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) (a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 实现对应的open/read/write等函数，填入file_operations结构体                   */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* write(fd, &amp;val, 1); */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">char</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file);</span><br><span class="line">    <span class="type">int</span> minor = iminor(inode);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    err = copy_from_user(&amp;status, buf, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* 根据次设备号和status控制LED */</span></span><br><span class="line">	p_led_opr-&gt;ctl(minor, status);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_open</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> minor = iminor(node);</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="comment">/* 根据次设备号初始化LED */</span></span><br><span class="line">    ret = p_led_opr-&gt;init(minor);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_close</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	p_led_opr-&gt;close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 定义自己的file_operations结构体                                              */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_drv</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = led_drv_open,</span><br><span class="line">    .read = led_drv_read,</span><br><span class="line">    .write = led_drv_write,</span><br><span class="line">    .release = led_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4. 把file_operations结构体告诉内核：注册驱动程序                                */</span></span><br><span class="line"><span class="comment">/* 5. 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err, i;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;krocz_led&quot;</span>, &amp;led_drv); <span class="comment">/* /dev/led */</span></span><br><span class="line">    led_class = class_create(THIS_MODULE, <span class="string">&quot;krocz_led_class&quot;</span>);</span><br><span class="line">    err = PTR_ERR(led_class);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(led_class))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        unregister_chrdev(major, <span class="string">&quot;krocz_led&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p_led_opr = get_chip_led_operations();</span><br><span class="line">    <span class="keyword">if</span>(p_led_opr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">&quot;get led operations failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    led_num = p_led_opr-&gt;get_led_num();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; led_num; i++)</span><br><span class="line">        device_create(led_class, <span class="literal">NULL</span>, MKDEV(major, i), <span class="literal">NULL</span>, <span class="string">&quot;krocz_led%d&quot;</span>, i); <span class="comment">/* /dev/krocz_led0,1,... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数           */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; led_num; i++)</span><br><span class="line">        device_destroy(led_class, MKDEV(major, i)); <span class="comment">/* /dev/krocz_led0,1,... */</span></span><br><span class="line">    class_destroy(led_class);</span><br><span class="line">    unregister_chrdev(major, <span class="string">&quot;krocz_led&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */</span></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>该驱动程序就是通用的驱动框架，只不过具体的引脚以及不同芯片针对引脚的寄存器操作都被分离到芯片层和开发板层了。在使用时，只需要利用下面提供的Makefile将通用LED驱动和相应的芯片.c文件和相应开发板的.c文件进行编译链接即可：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KERN_DIR = /home/book/100ask_imx6ull_mini-sdk/Linux-4.9.88</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules </span><br><span class="line">	<span class="variable">$(CROSS_COMPILE)</span>gcc -o krocz_led_test ledtest.c </span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules clean</span><br><span class="line">	rm -rf modules.order</span><br><span class="line">	rm -f ledtest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参考内核源码drivers/char/ipmi/Makefile</span></span><br><span class="line"><span class="comment"># 要想把a.c, b.c编译成ab.ko, 可以这样指定:</span></span><br><span class="line"><span class="comment"># ab-y := a.o b.o</span></span><br><span class="line"><span class="comment"># obj-m += ab.o</span></span><br><span class="line"></span><br><span class="line">krocz_led-y := led_drv.o chip_imx6ll_gpio.o board_A_imx6ll_led.o</span><br><span class="line">obj-m	+= krocz_led.o</span><br></pre></td></tr></table></figure>
<p>通过分层的方式，从而实现了解耦合，使得我们的LED驱动程序具有通用性。</p>
<h3 id="测试程序">1.4 测试程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用法：  ./ledtest /dev/krocz_led&lt;0 | 1&gt; &lt;on | off&gt;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> status;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 1. 判断参数 */</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt; &lt;on | off&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. 打开文件 */</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3. 写文件 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;on&quot;</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		status = <span class="number">1</span>;</span><br><span class="line">		write(fd, &amp;status, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		status = <span class="number">0</span>;</span><br><span class="line">		write(fd, &amp;status, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总线设备驱动模型">2. 总线设备驱动模型</h2>
<p>在第1节的基础上，进一步考虑支持开发板上的所有硬件资源。在第1节中，我们主要定义了两个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_resources</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> pins[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*init)(<span class="type">int</span> which);</span><br><span class="line">    <span class="type">int</span> (*ctl) (<span class="type">int</span> which, <span class="type">char</span> status);</span><br><span class="line">    <span class="type">int</span> (*get_led_num)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">int</span> (*close)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>并通过相应的.c文件对结构体的内容进行填充。不同的硬件对应的引脚配置和操作函数大体上都是类似的，我们可以考虑定义一个通用的引脚配置结构体<code>struct platform_device</code>和通用的操作配置结构体<code>struct platform_driver</code>，然后在一个.c文件中实现针对主控芯片的所有硬件的操作函数，在另一个.c文件中实现针对某一款开发板的所有硬件的引脚定义，从而将第1节的分离思想应用到所有的硬件：</p>
<figure>
<img src="../images/LED驱动程序框架/image-20231218153656623.png"
alt="image-20231218153656623" />
<figcaption aria-hidden="true">image-20231218153656623</figcaption>
</figure>
<h3 id="理解busdevdrv模型">2.1 理解Bus/Dev/Drv模型</h3>
<p>结构体<code>platform_device</code>的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*name;</span><br><span class="line">	<span class="type">int</span>		id;</span><br><span class="line">	<span class="type">bool</span>		id_auto;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>	<span class="title">dev</span>;</span></span><br><span class="line">	u32		num_resources;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span>	*<span class="title">resource</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span>	*<span class="title">id_entry</span>;</span></span><br><span class="line">	<span class="type">char</span> *driver_override; <span class="comment">/* Driver name to force a match */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* MFD cell pointer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> *<span class="title">mfd_cell</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* arch specific additions */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pdev_archdata</span>	<span class="title">archdata</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>目前用到的几个结构体成员：</p>
<ul>
<li>name：自定义的设备名称，可以根据该名称将<code>platform_device</code>与<code>platform_driver</code>进行匹配</li>
<li>resource：硬件引脚资源结构体</li>
<li>num_resources：资源的数量</li>
<li>driver_override：首先匹配<code>driver_override</code>所表示的<code>platform_driver</code></li>
</ul>
<p>结构体<code>struct resource</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">	<span class="type">resource_size_t</span> start;</span><br><span class="line">	<span class="type">resource_size_t</span> end;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> desc;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>start/end：用来表示地址的<code>u32</code>整型数据</p></li>
<li><p>name：引脚名称标识</p></li>
<li><p>flag：标识引脚资源类型，后面<code>platform_get_resource</code>的参数
type 指的类别就是下面这些</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IO resources have these defined flags.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PCI devices expose these flags to userspace in the &quot;resource&quot; sysfs file,</span></span><br><span class="line"><span class="comment"> * so don&#x27;t move them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_BITS		0x000000ff	<span class="comment">/* Bus-specific bits */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_TYPE_BITS	0x00001f00	<span class="comment">/* Resource type */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_IO		0x00000100	<span class="comment">/* PCI/ISA I/O ports */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM		0x00000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_REG		0x00000300	<span class="comment">/* Register offsets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_IRQ		0x00000400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_DMA		0x00000800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_BUS		0x00001000</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>结构体<code>platform_driver</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*probe)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">	<span class="type">int</span> (*remove)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">	<span class="type">int</span> (*suspend)(<span class="keyword">struct</span> platform_device *, <span class="type">pm_message_t</span> state);</span><br><span class="line">	<span class="type">int</span> (*resume)(<span class="keyword">struct</span> platform_device *);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">	<span class="type">bool</span> prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>比较重要的几个成员：</p>
<ul>
<li>probe：当总线扫描到设备树中的<code>platform_device</code>并与相应的<code>platform_driver</code>进行匹配之后，内核会调用probe函数，probe（探针）函数包含了初始化设备的逻辑。</li>
<li>remove：当总线或者内核监测到硬件设备拔出事件之后，通常会触发对应驱动程序调用remove函数，该函数包含清理设备资源的逻辑。</li>
<li>driver-&gt;name：与<code>platform_device</code>的name或者driver_override成员进行匹配的名称</li>
<li>id_table：表示该 drv 支持若干 个 device，它里面列出了各个 device
的<code>&#123;.name, .driver_data&#125;</code>，其中的<code>name</code>表示该 drv
支持的设备的名字，<code>driver_data</code> 是些提供给该 device
的私有数据，与<code>platform_device</code>的name进行匹配</li>
</ul>
<h4 id="dev和drv的匹配">2.1.1 Dev和Drv的匹配</h4>
<h5 id="匹配优先级大概了解后面详细讲">(1)
匹配优先级（大概了解，后面详细讲）</h5>
<ol type="1">
<li>最先比较<code>platform_device.driver_override</code>和
<code>platform_driver.driver.name</code></li>
<li>然后比较<code>platform_device.name</code> 和
<code>platform_driver.id_table[i].name</code></li>
<li>最后比较<code>platform_device.name</code> 和
<code>platform_driver.driver.name</code></li>
</ol>
<h5 id="函数调用关系">(2) 函数调用关系</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">platform_device_register </span><br><span class="line">platform_device_add </span><br><span class="line">    device_add </span><br><span class="line">    	bus_add_device <span class="comment">// 放入链表 </span></span><br><span class="line">     	bus_probe_device <span class="comment">// probe 枚举设备，即找到匹配的(dev, drv) </span></span><br><span class="line">    		device_initial_probe </span><br><span class="line">    			__device_attach </span><br><span class="line">    				<span class="title function_">bus_for_each_drv</span><span class="params">(...,__device_attach_driver,...)</span> 											__device_attach_driver </span><br><span class="line">    						<span class="title function_">driver_match_device</span><span class="params">(drv, dev)</span> <span class="comment">// 是否匹配 </span></span><br><span class="line">  							driver_probe_device           <span class="comment">// 调用 drv 的 probe </span></span><br><span class="line"></span><br><span class="line">platform_driver_register </span><br><span class="line">__platform_driver_register </span><br><span class="line">    driver_register </span><br><span class="line">    	bus_add_driver <span class="comment">// 放入链表 </span></span><br><span class="line">    		<span class="title function_">driver_attach</span><span class="params">(drv)</span> </span><br><span class="line">    			<span class="title function_">bus_for_each_dev</span><span class="params">(drv-&gt;bus, <span class="literal">NULL</span>, drv, __driver_attach)</span>; </span><br><span class="line">					__driver_attach </span><br><span class="line">                        <span class="title function_">driver_match_device</span><span class="params">(drv, dev)</span> <span class="comment">// 是否匹配 </span></span><br><span class="line">                        driver_probe_device           <span class="comment">// 调用 drv 的 probe</span></span><br></pre></td></tr></table></figure>
<h4 id="常用函数">2.1.2 常用函数</h4>
<p>这些函数在内核源码：<code>drivers/base/platform.c</code></p>
<p><strong>(1) 注册/取消注册</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">platform_device_register/ platform_device_unregister </span><br><span class="line">platform_driver_register/ platform_driver_unregister </span><br><span class="line">platform_add_devices <span class="comment">// 注册多个 device</span></span><br></pre></td></tr></table></figure>
<p><strong>(2) 获取资源</strong></p>
<p>返回该 dev 中某类型(type)资源中的第几个(num)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> num)</span></span><br></pre></td></tr></table></figure>
<p>返回该 dev 所用的第几个(num)中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">platform_get_irq</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="type">unsigned</span> <span class="type">int</span> num)</span></span><br></pre></td></tr></table></figure>
<p>通过名字(name)返回该 dev 的某类型(type)资源：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource_byname</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure>
<p>通过名字(name)返回该 dev 的中断号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">platform_get_irq_byname</span><span class="params">(<span class="keyword">struct</span> platform_device *dev， <span class="type">const</span> <span class="type">char</span> *name)</span></span><br></pre></td></tr></table></figure>
<h3 id="编写代码">2.2 编写代码</h3>
<h4 id="开发板层-1">2.2.1 开发板层</h4>
<p>board_A_imx6ull.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">led_dev_release</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">resources</span>[] =</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .start = GROUP_PIN(<span class="number">3</span>,<span class="number">1</span>),</span><br><span class="line">                .flags = IORESOURCE_IRQ,</span><br><span class="line">                .name = <span class="string">&quot;100ask_led_pin&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .start = GROUP_PIN(<span class="number">5</span>,<span class="number">8</span>),</span><br><span class="line">                .flags = IORESOURCE_IRQ,</span><br><span class="line">                .name = <span class="string">&quot;100ask_led_pin&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">board_A_led_dev</span> =</span> &#123;</span><br><span class="line">        .name = <span class="string">&quot;100ask_led&quot;</span>,</span><br><span class="line">        .num_resources = ARRAY_SIZE(resources),</span><br><span class="line">        .resource = resources,</span><br><span class="line">        .dev = &#123;</span><br><span class="line">                .release = led_dev_release,</span><br><span class="line">         &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_dev_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_device_register(&amp;board_A_led_dev);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_dev_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_device_unregister(&amp;board_A_led_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_dev_init);</span><br><span class="line">module_exit(led_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>当模块安装时会调用<code>led_dev_init</code>，模块卸载时会调用<code>led_dev_exit</code>。</p>
<p>注：必须要提供<code>release</code>函数，如果不提供则在调用<code>platform_device_unregister</code>时会出现警告：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WARN(<span class="number">1</span>, KERN_ERR <span class="string">&quot;Device &#x27;%s&#x27; does not have a release() &quot;</span></span><br><span class="line">     <span class="string">&quot;function, it is broken and must be fixed.\n&quot;</span>,</span><br><span class="line">     dev_name(dev));</span><br></pre></td></tr></table></figure>
<h4 id="芯片层-1">2.2.2 芯片层</h4>
<p>chip_imx6ull_gpio.c</p>
<p>这一部分对应芯片层的硬件操作，和上一节一致：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_init</span> <span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 初始化LED, which-哪个LED */</span>       </span><br><span class="line">&#123;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_ctl</span> <span class="params">(<span class="type">int</span> which, <span class="type">char</span> status)</span> <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> <span class="title">board_demo_led_opr</span> =</span> &#123;</span><br><span class="line">    .init = board_demo_led_init,</span><br><span class="line">    .ctl  = board_demo_led_ctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这一部分对应<code>platform_driver</code>配置和安装和卸载函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> g_ledpins[<span class="number">100</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_ledcnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 当dev和drv匹配时调用，根据dev具体的硬件参数，来完成设备文件初始化等操作 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = platform_get_resource(pdev, IORESOURCE_IRQ, i++);</span><br><span class="line">        <span class="keyword">if</span> (!res)   <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        g_ledpins[g_ledcnt] = res-&gt;start;</span><br><span class="line">        led_class_create_device(g_ledcnt);  <span class="comment">// 调用通用驱动层的函数，完成设备文件创建</span></span><br><span class="line">        g_ledcnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当dev和drv解除匹配时调用 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = platform_get_resource(pdev, IORESOURCE_IRQ, i);</span><br><span class="line">        <span class="keyword">if</span> (!res) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        led_class_destroy_device(i);</span><br><span class="line">        i++;</span><br><span class="line">        g_ledcnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">chip_demo_gpio_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = chip_demo_gpio_probe,</span><br><span class="line">    .remove     = chip_demo_gpio_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_led&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在模块安装时调用 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chip_demo_gpio_drv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    </span><br><span class="line">    err = platform_driver_register(&amp;chip_demo_gpio_driver); </span><br><span class="line">    register_led_operations(&amp;board_demo_led_opr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在模块卸载时调用 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">lchip_demo_gpio_drv_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_unregister(&amp;chip_demo_gpio_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chip_demo_gpio_drv_init);</span><br><span class="line">module_exit(lchip_demo_gpio_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="通用驱动层">2.2.3 通用驱动层</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> *<span class="title">p_led_opr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_create_device</span><span class="params">(<span class="type">int</span> minor)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_create(led_class, <span class="literal">NULL</span>, MKDEV(major, minor), <span class="literal">NULL</span>, <span class="string">&quot;100ask_led%d&quot;</span>, minor); <span class="comment">/* /dev/100ask_led0,1,... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_destroy_device</span><span class="params">(<span class="type">int</span> minor)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(led_class, MKDEV(major, minor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_led_operations</span><span class="params">(<span class="keyword">struct</span> led_operations *opr)</span></span><br><span class="line">&#123;</span><br><span class="line">	p_led_opr = opr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(led_class_create_device);</span><br><span class="line">EXPORT_SYMBOL(led_class_destroy_device);</span><br><span class="line">EXPORT_SYMBOL(register_led_operations);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>通用驱动层的代码和之前几乎一样，只不过设备文件的创建因为和硬件资源的分配有关，所以放到了芯片层完成。</p>
<p><code>EXPORT_SYMBOL()</code>：EXPORT_SYMBOL标签内定义的函数或者符号对全部内核代码公开，使用EXPORT_SYMBOL可以<strong>将一个函数以符号的方式导出给其他模块使用</strong>。</p>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Pinctrl和GPIO子系统</title>
    <url>/2024/01/02/Pinctrl%E5%92%8CGPIO%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="gpio-和-pinctrl-子系统的使用">1. GPIO 和 Pinctrl
子系统的使用</h2>
<p>在 LED
驱动程序中，我们使用寄存器操作的方式来配置硬件，这种方式是非常低效的，对于具有大量寄存器的芯片肯定需要将寄存器操作，可以由芯片厂的BSP工程师来封装成库，然后来让驱动开发人员进行调用，这就是今天引入的
GPIO 和 Pinctrl 子系统。</p>
<h3 id="pinctrl-子系统">1.1 Pinctrl 子系统</h3>
<blockquote>
<p>参考文档：内核目录-bindings.txt</p>
</blockquote>
<p>Pinctrl 子系统涉及 2 个对象：pin controller、client device。</p>
<ul>
<li>pin controller 提供服务，可以用它来复用引脚、配置引脚。</li>
<li>client device
使用服务，声明自己要使用哪些引脚的哪些功能，怎么配置它们。</li>
</ul>
<h4 id="pin-controller">1.1.1 pin controller</h4>
<p>pin controller
是一个软件上的概念，用来复用引脚，还可以配置引脚(比如上下拉电阻等)。</p>
<blockquote>
<p>pin controller 和后面讲到的 GPIO Controller
不是一回事，前者控制的引脚可用于 GPIO 功能、I2C
功能；后者只是把引脚配置为输入、输出等简单的功能。</p>
</blockquote>
<h4 id="client-device">1.1.2 client device</h4>
<p>Pinctrl
系统的客户，就是使用引脚的设备，<strong>它在设备树里会被定义为一个节点，在节点里声明要用哪些引脚</strong>。例如：</p>
<figure>
<img src="../images/Pinctrl和GPIO子系统/image-20240102204442724.png"
alt="image-20240102204442724" />
<figcaption aria-hidden="true">image-20240102204442724</figcaption>
</figure>
<p>上图中，左边是 pin controller 节点，右边是 client device 节点.</p>
<h5 id="pin-state">(1) pin state</h5>
<p>比如对于一个 UART 设备，它有多个“状态”：default、sleep
等，那对应的引脚在设备处于不同状态时也需要配置为不同的模式。例如UART默认状态两个引脚需要配置为输出+输入模式，在休眠模式下节约功耗则可以配置为均输出高电平。</p>
<h5 id="groups-和-function">(2) groups 和 function</h5>
<p>一个设备会用到一个或多个引脚，这些引脚就可以归为一组(group)；</p>
<p>这些引脚可以复用为某个功能：function。</p>
<p>当然：一个设备可以用到多组引脚，比如 A1、A2 两组引脚，A1 组复用为 F1
功能，A2 组复用为 F2 功能。</p>
<h5
id="generic-pin-multiplexing-node-和-generic-pin-configuration-node">(3)
Generic pin multiplexing node 和 Generic pin configuration node</h5>
<p>在上图左边的 pin controller
节点中，一些其他属性可以描述不同的引脚信息，例如，哪组 (group)
引脚配置为哪 个设置功能 (setting)，比如上拉、下拉等。</p>
<blockquote>
<p>pin controller 节点的格式，没有统一的标准。每家芯片都不一样。
甚至上面的 group、function 关键字也不一定有，但是概念是有的。</p>
</blockquote>
<p>Pinctrl 子系统举例：</p>
<figure>
<img src="../images/Pinctrl和GPIO子系统/image-20240102210056127.png"
alt="image-20240102210056127" />
<figcaption aria-hidden="true">image-20240102210056127</figcaption>
</figure>
<h4 id="代码中怎么引用-pinctrl">1.1.3 代码中怎么引用 pinctrl</h4>
<p>基本上驱动程序不用管，当设备切换状态时，对应的 pinctrl
就会被自动调用来切换引脚状态。</p>
<p>非要调用，也有函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">devm_pinctrl_get_select_default(<span class="keyword">struct</span> device *dev); <span class="comment">// 使用&quot;default&quot;状态的引脚</span></span><br><span class="line">pinctrl_get_select(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="type">char</span> *name); <span class="comment">// 根据 name 选择某种状态的引脚</span></span><br></pre></td></tr></table></figure>
<h3 id="gpio-子系统">1.2 GPIO 子系统</h3>
<p>要操作 GPIO 引脚，先把所用引脚配置为 GPIO 功能，这通过 Pinctrl
子系统来实现。</p>
<p>然后就可以根据设置引脚方向(输入还是输出)，获取引脚电平(读)，设置引脚电平(写)，这通过
GPIO 子系统来实现。</p>
<h4 id="在设备树中指定引脚">1.2.1 在设备树中指定引脚</h4>
<p>几乎所有 ARM 芯片中，GPIO 都分为几组，每组中有若干个引脚。</p>
<p>所以在使用 GPIO 子系统之前，就要先确定引脚的组别和组内序号</p>
<p><strong>在设备树中，“GPIO组”就是一个 GPIO
Controller</strong>，这通常都由芯片厂家设置好。我们要做的是找到它名字，比如“gpio1”，然后指定要用它里面的哪个引脚，比如&lt;&amp;gpio1
0&gt;。</p>
<p>下图是一些芯片的 GPIO 控制器节点，它们一般都是厂家定义好，在 xxx.dtsi
文件中：</p>
<figure>
<img src="../images/Pinctrl和GPIO子系统/image-20240102211315432.png"
alt="image-20240102211315432" />
<figcaption aria-hidden="true">image-20240102211315432</figcaption>
</figure>
<p>暂时只需要关心里面的这 2 个属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpio-controller; </span><br><span class="line">#gpio-cells = &lt;2&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>gpio-controller 表示这个节点是一个 GPIO
Controller，它下面有很多引脚。</li>
<li>#gpio-cells = &lt;2&gt; 表示这个控制器下每一个引脚要用 2 个 32
位的数
(cell)来描述。具体用几个数以及如何表示都可以自己决定；<strong>普遍的用法是，用第
1 个 cell 来表示哪一个引脚，用第 2 个 cell
来表示有效电平</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPIO_ACTIVE_HIGH: 高电平有效 </span><br><span class="line">GPIO_ACTIVE_LOW : 低电平有效</span><br></pre></td></tr></table></figure>
<p>片厂来定义 GPIO Controller
，我们如果需要修改设备树文件，只需要引用他们规定的引脚即可：</p>
<figure>
<img src="../images/Pinctrl和GPIO子系统/image-20240102212214670.png"
alt="image-20240102212214670" />
<figcaption aria-hidden="true">image-20240102212214670</figcaption>
</figure>
<p>例如上图中，在设备树文件，我们定义的设备节点中直接引用 "gpios" 或者
"xxx-gpios" 属性即可</p>
<h4 id="在驱动代码中调用-gpio-子系统">1.2.2 在驱动代码中调用 GPIO
子系统</h4>
<p>GPIO 子系统有两套接口：</p>
<ol type="1">
<li>基于描述符 - descriptor-based。函数都有前缀
<code>gpiod_</code>，它使用 gpio_desc 结构体来表示 一个引脚；</li>
<li>过时的接口 - legacy。函数都有前缀
<code>gpio_</code>，它使用一个整数来表示一个引脚。</li>
</ol>
<p>要操作一个引脚，首先要 get 引脚，然后设置方向，读值、写值。</p>
<h5 id="常用函数">(1) 常用函数</h5>
<p>需包含头文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span> <span class="comment">// descriptor-based</span></span></span><br><span class="line">or</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span> <span class="comment">// legacy</span></span></span><br></pre></td></tr></table></figure>
<figure>
<img src="../images/Pinctrl和GPIO子系统/image-20240102213415783.png"
alt="image-20240102213415783" />
<figcaption aria-hidden="true">image-20240102213415783</figcaption>
</figure>
<p>有前缀 <code>devm_</code> 的含义是“设备资源管理”(Managed Device
Resource)，
这是一种自动释放资源的机制。它的思想是“<strong>资源是属于设备的，设备不存在时资源就可以自动释放</strong>”。</p>
<p>比如在 Linux 开发过程中，先申请了
GPIO，再申请内存；如果内存申请失败，那么在返回之前就需要先释放 GPIO
资源。如果使用 devm
的相关函数，在内存申请失败时可以直接返回：设备的销毁函数会自动地释放已经申请了的
GPIO
资源。<strong>建议使用<code>devm_</code>版本的相关函数。</strong></p>
<h5 id="使用-descriptor-based-方式获得引脚">(2) 使用 descriptor-based
方式获得引脚</h5>
<p>假设备在设备树中有如下节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo_device</span><br><span class="line">&#123;</span><br><span class="line">    compatible = &quot;acme,foo&quot;;</span><br><span class="line">    ... </span><br><span class="line">    led-gpios   = &lt;&amp;gpio 15 GPIO_ACTIVE_HIGH&gt;, /* red */</span><br><span class="line">    			  &lt;&amp;gpio 16 GPIO_ACTIVE_HIGH&gt;, /* green */</span><br><span class="line">    			  &lt;&amp;gpio 17 GPIO_ACTIVE_HIGH&gt;; /* blue */</span><br><span class="line">    power-gpios = &lt;&amp;gpio 1 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么可以使用下面的函数获得引脚：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">red</span>, *<span class="title">green</span>, *<span class="title">blue</span>, *<span class="title">power</span>;</span></span><br><span class="line">red = gpiod_get_index(dev, <span class="string">&quot;led&quot;</span>, <span class="number">0</span>, GPIOD_OUT_HIGH);</span><br><span class="line">green = gpiod_get_index(dev, <span class="string">&quot;led&quot;</span>, <span class="number">1</span>, GPIOD_OUT_HIGH);</span><br><span class="line">blue = gpiod_get_index(dev, <span class="string">&quot;led&quot;</span>, <span class="number">2</span>, GPIOD_OUT_HIGH);</span><br><span class="line">power = gpiod_get(dev, <span class="string">&quot;power&quot;</span>, GPIOD_OUT_HIGH);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gpiod_set_value
设置的值是“逻辑值”，不一定等于物理值。之所以使用逻辑值，是为了保持功能代码不变。以LED不同的驱动电路为例，见下图：</p>
</blockquote>
<figure>
<img src="../images/Pinctrl和GPIO子系统/image-20240103114637359.png"
alt="image-20240103114637359" />
<figcaption aria-hidden="true">image-20240103114637359</figcaption>
</figure>
<h5 id="使用老的方式获得引脚">(3) 使用老的方式获得引脚</h5>
<p>旧的 <code>gpio_</code>
函数没办法根据设备树信息获得引脚，它需要先知道引脚号。</p>
<p>在 GPIO 子系统中，每注册一个 GPIO Controller 时会确定它的“base
number”，那么这个控制器里的第 n 号引脚的号码就是：base number + n。
但是<strong>如果硬件有变化、设备树有变化，这个 base number
并不能保证是固定的，应该查看 sysfs 来确定 base number。</strong></p>
<ol type="1">
<li><p>先在开发板的/sys/class/gpio 目录下，找到各个 gpiochipxxx
目录：</p></li>
<li><p>然后进入某个 gpiochip 目录，查看文件 label 的内容</p></li>
<li><p>根据 label 的内容对比设备树。label
内容来自设备树，比如它的寄存器基地址。用来跟设备树(dtsi 文件)
比较，就可以知道这对应哪一个 GPIO Controller。</p>
<p><img src="../images/Pinctrl和GPIO子系统/image-20240103104344564.png"
alt="image-20240103104344564" />、</p>
<p>从图中可以知道 GPIO Controller (gpio4) 对应的基准引脚号是
96，则对于引脚 "GPIO4_IO14"的引脚号为 96 + 14 =
110，可以按照如下操作读取引脚的值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 110 &gt; /sys/class/gpio/export</span><br><span class="line">echo in &gt; /sys/class/gpio/gpio110/direction</span><br><span class="line">cat /sys/class/gpio/gpio110/value</span><br><span class="line">echo 110 &gt; /sys/class/gpio/unexport</span><br></pre></td></tr></table></figure>
<p>按照如下操作设置引脚的值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 110 &gt; /sys/class/gpio/export</span><br><span class="line">echo out &gt; /sys/class/gpio/gpio110/direction</span><br><span class="line">echo 1 &gt; /sys/class/gpio/gpio110/value</span><br><span class="line">echo 110 &gt; /sys/class/gpio/unexport</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>如果驱动程序已经使用了该引脚，那么将会 export 失败，会提示：write
error: Device orr resource busy</p>
</blockquote>
<h2 id="基于-pinctrl-和-gpio-子系统编写led驱动">2. 基于 Pinctrl 和 GPIO
子系统编写LED驱动</h2>
<p>通过使用 Pinctrl 和 GPIO
子系统封装了硬件操作中大量的寄存器设备，使得驱动代码和芯片种类解绑，大大简化了驱动代码的编写。</p>
<h3 id="基于-pinctrl-子系统修改设备树">2.1 基于 Pinctrl
子系统修改设备树</h3>
<ol type="1">
<li>有些芯片提供了设备树生成工具，在 GUI 界面中选择引脚功能和配置信息，
就可以自动生成 Pinctrl 子结点。把它复制到你的设备树文件中，再在 client
device 结点中引用就可以。</li>
<li>有些芯片只提供文档，那就去阅读文档，一般在内核源码目录
Documentation下面，保存有该厂家的文档。</li>
<li>如果连文档都没有，那只能参考内核源码中的设备树文件，在内核源码目录
arch/arm/boot/dts 目录下。</li>
</ol>
<p>IMX6ULL提供了GUI工具，可以在GUI工具中配置引脚的复用和焊盘的相关参数：</p>
<figure>
<img src="../images/Pinctrl和GPIO子系统/image-20240103202925506.png"
alt="image-20240103202925506" />
<figcaption aria-hidden="true">image-20240103202925506</figcaption>
</figure>
<p>将生成的 Pinctrl 子节点添加到 dts 文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;iomuxc_snvs &#123;</span><br><span class="line">    pinctrl-names = &quot;default_snvs&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_hog_2&gt;;</span><br><span class="line">    </span><br><span class="line">    imx6ull-board &#123;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_krocz_led&gt;;</span><br><span class="line">        pinctrl_krocz_led: krocz_ledgrp &#123;    </span><br><span class="line">            fsl,pins = &lt;</span><br><span class="line">                MX6ULL_PAD_SNVS_TAMPER3__GPIO5_IO03        0x000110E0</span><br><span class="line">            &gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    imx6ul-evk &#123;</span><br><span class="line">        pinctrl_hog_2: hoggrp-2 &#123;</span><br><span class="line">            fsl,pins = &lt;</span><br><span class="line">                MX6ULL_PAD_SNVS_TAMPER9__GPIO5_IO09     0x1b0b0 /* enet1 reset */</span><br><span class="line">                MX6ULL_PAD_SNVS_TAMPER6__GPIO5_IO06     0x1b0b0 /* enet2 reset */</span><br><span class="line">                MX6ULL_PAD_SNVS_TAMPER1__GPIO5_IO01     0x000110A0 /*key 1*/</span><br><span class="line">            &gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：我尝试将 pinctrl_krocz_led 节点直接放置在 &amp;iomuxc_snvs
节点下，但是重启开发板之后发现网络连接不上；通过串口连上开发板之后，装载内核驱动模块时报错找不着引脚，不过感觉语法上应该没有问题。之后，将
pinctrl_krocz_led 放置在原有的 imx6ul-evk 或者像GUI生成的那样放在
imx6ull-board 下是可以的，没有问题。</p>
</blockquote>
<p>在 dts 中新加入一个设备节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">krocz_led &#123;</span><br><span class="line">    compatible = &quot;krocz,leddrv&quot;;               // 和 platform_driver 进行匹配</span><br><span class="line">    pinctrl-names = &quot;default&quot;;                 // 该设备节点可能的状态</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_krocz_led&gt;;          // 第一种状态使用的 Pinctrl 配置</span><br><span class="line">    myled-gpios = &lt;&amp;gpio5 3 GPIO_ACTIVE_LOW&gt;;  // 设备节点所使用的引脚</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过上述代码，我们基于 Pinctrl 子系统设置了 LED
引脚，以及引脚复用功能为
GPIO，并且配置了引脚的相关属性，如上拉电阻阻值，驱动能力，引脚速率等。</p>
<p>基于 GPIO 子系统设置了 LED
引脚，以及该引脚逻辑电平和物理电平的关系，并可以通过 GPIO
子系统来设置该引脚的方向，读写引脚值等。</p>
<h3 id="通用led驱动代码">2.2 通用LED驱动代码</h3>
<p>代码的主要部分：</p>
<ol type="1">
<li>注册 file_operations</li>
<li>内核模块的 init 和 exit</li>
<li>platform_driver 的 probe 和 remove</li>
</ol>
<h4 id="编写-file_operations">2.2.1 编写 file_operations</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">char</span> status;</span><br><span class="line">	printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	err = copy_from_user(&amp;status, buf, <span class="number">1</span>);</span><br><span class="line">	gpiod_set_value(led_gpio, status);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;	</span><br><span class="line">	printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	gpiod_direction_output(led_gpio, <span class="number">0</span>);   <span class="comment">// 默认写逻辑0，熄灭LED灯</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.open    = led_drv_open,</span><br><span class="line">	.write   = led_drv_write,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>基于 Pinctrl 和 GPIO
子系统将芯片寄存器操作封装，使得我们的驱动代码和芯片类型无关，从而使得仅这一个LED驱动代码就可以在任意芯片上通用。在不同的芯片上仅需要修改对应的设备树文件，不需要修改驱动代码文件。</p>
<h4 id="内核模块注册">2.2.2 内核模块注册</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">	printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    err = platform_driver_register(&amp;chip_demo_gpio_driver); </span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    platform_driver_unregister(&amp;chip_demo_gpio_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是注册 platform_driver</p>
<h4 id="设备驱动的注册">2.2.3 设备驱动的注册</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4.1 设备树中定义  myled-gpios=&lt;...&gt;;	*/</span></span><br><span class="line">    <span class="comment">/* device结构体  char*的功能名称    用以GPIO初始化的flags，0表示高电平有效 */</span></span><br><span class="line">    led_gpio = gpiod_get(&amp;pdev-&gt;dev, <span class="string">&quot;myled&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(led_gpio)) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to get GPIO for led\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(led_gpio);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;krocz_led&quot;</span>, &amp;led_drv);  <span class="comment">/* /dev/led */</span></span><br><span class="line">	led_class = class_create(THIS_MODULE, <span class="string">&quot;krocz_led_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(led_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;krocz_led&quot;</span>);</span><br><span class="line">		gpiod_put(led_gpio);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(led_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(led_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;krocz_led%d&quot;</span>, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(led_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(led_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;krocz_led&quot;</span>);</span><br><span class="line">	gpiod_put(led_gpio);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要获取 GPIO 引脚，注册 file_operations 结构体，创建设备文件等。</p>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>UART应用编程</title>
    <url>/2023/10/06/UART%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="tty体系的发展">1.TTY体系的发展</h2>
<blockquote>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/337366679">Linux
终端(TTY)</a></p>
<p><a href="https://taoshu.in/tty.html">解密 TTY 设备</a></p>
</blockquote>
<h3 id="终端机">1.1 终端机</h3>
<p>从历史上看，终端刚开始就是终端机，配有打印机，键盘，带有一个串口，通过串口传送数据到主机端，然后主机处理完交给终端打印出来。电传打字机(teletype)可以被看作是这类设备的统称，因此终端也被简称为
TTY(teletype 的缩写)：</p>
<figure>
<img src="../images/UART应用编程/image-20231006145708741.png"
alt="image-20231006145708741" />
<figcaption aria-hidden="true">image-20231006145708741</figcaption>
</figure>
<h4 id="tty设备">1.1.1 TTY设备</h4>
<p>UART 驱动、行规范和 TTY
驱动都位于内核中，它们的一端是终端设备，另一端是用户进程。一开始，UART
驱动、行规范和 TTY
驱动三个模块统称为<strong>TTY设备</strong>，也是TTY开始的样子。</p>
<h5 id="uart-driver">(1) UART driver</h5>
<p>UART(Universal Asynchronous
Receiver-Transmitter)，通用异步收发器驱动程序用于管理字节流的物理传输。</p>
<h5 id="line-discipline">(2) Line discipline</h5>
<p>行规范的主要功能是处理终端上输入的字符流，并根据特定的规则解释和处理这些字符。行规范在终端的输入处理过程中起到了重要的作用，它可以执行各种任务，如输入缓冲、字符编辑、特殊字符处理等。</p>
<p>以下文字引用自参考资料<strong>解密TTY</strong>：</p>
<p>大多数用户都会在输入时犯错，所以退格键会很有用。这当然可以由应用程序本身来实现，但是根据UNIX设计哲学，应用程序应尽可能保持简单。为了方便起见，<strong>操作系统提供了一个编辑缓冲区和一些基本的编辑命令（退格，清除单个单词，清除行，重新打印），这些命令在行规范（line
discipline）内默认启用</strong>。高级应用程序可以通过将行规范设置为原始模式（raw
mode）而不是默认的成熟或准则模式（cooked and
canonical）来禁用这些功能。大多数交互程序（编辑器，邮件客户端，shell，及所有依赖curses或readline的程序）均以原始模式运行，并自行处理所有的行编辑命令。行规范还包含字符回显(控制是否将字符上报给TTY驱动程序)和回车换行（译者注：和
）间自动转换的选项。如果你喜欢，可以把它看作是一个原始的内核级sed(1)。</p>
<p>另外，内核提供了几种不同的行规范。一次只能将其中一个连接到给定的串行设备。行规范的默认规则称为N_TTY（drivers/char/n_tty.c，如果你想继续探索的话）。其他的规则被用于其他目的，例如管理数据包交换（ppp，IrDA，串行鼠标），但这不在本文的讨论范围之内。</p>
<h5 id="tty-driver">(3) TTY driver</h5>
<p>TTY驱动程序是计算机操作系统中的一个模块，负责与终端设备进行通信，包括键盘、鼠标、打印机等外部设备。</p>
<p>TTY驱动程序的主要功能是通过提供会话管理和终端设备的输入/输出处理，实现用户与计算机系统之间的交互。它允许用户通过终端设备与计算机进行通信，输入命令、数据或请求，并接收来自系统的输出结果。</p>
<h3 id="桌面计算机系统">1.2 桌面计算机系统</h3>
<figure>
<img src="../images/UART应用编程/image-20231006153242686.png"
alt="image-20231006153242686" />
<figcaption aria-hidden="true">image-20231006153242686</figcaption>
</figure>
<p>典型的桌面计算机系统，不再需要UART设备或TTY设备了。同时，这个阶段还出现了<strong>虚拟终端</strong>，即在单个设备上同时支持多个用户会话的机制。</p>
<h4 id="虚拟终端">1.2.1 虚拟终端</h4>
<p>通过使用虚拟终端，用户可以在单个计算机上同时登录多个会话，并在这些会话之间切换。虚拟终端通过在内核中引入了多个逻辑终端设备（如/dev/tty1、/dev/tty2等）来实现。<strong>用户可以使用快捷键<code>Ctrl+Alt+Fx</code>来在不同的虚拟终端之间进行切换</strong>。</p>
<p>虚拟终端的出现是为了解决多用户环境下的多任务处理和资源共享的问题，允许在一个物理终端上同时支持多个用户会话；允许用户在不同的虚拟终端之间切换，从而提供多任务处理的能力；允许多个用户通过虚拟终端共享计算机的资源。</p>
<h3 id="伪终端">1.3 伪终端</h3>
<figure>
<img src="../images/UART应用编程/image-20231006161827882.png"
alt="image-20231006161827882" />
<figcaption aria-hidden="true">image-20231006161827882</figcaption>
</figure>
<p>伪终端（Pseudo
Terminal）是一种特殊的设备，它充当了终端的角色，但实际上并没有与终端硬件直接连接。它被广泛用于在计算机系统中<strong>模拟终端环境，如远程登录、终端仿真和虚拟机管理等，并提供和终端类似的交互功能</strong>。</p>
<h4 id="伪终端的实现原理">1.3.1 伪终端的实现原理</h4>
<p>伪终端的实现原理涉及到以下几个关键的组成部分：</p>
<ol type="1">
<li>主终端（Master
Terminal）：主终端是伪终端设备的前端，作为客户端进程（xterm
process）与伪终端设备之间的联系桥梁。主终端提供了类似于真实终端的接口，包括输入/输出流以及控制字符的交互。</li>
<li>从终端（Slave
Terminal）：从终端是伪终端设备的服务端，它是一个虚拟终端设备，通常表示为<code>/dev/pty/X</code>，其中<code>X</code>是一个字符。从终端通过I/O流与主终端进行数据交换。</li>
</ol>
<p>伪终端的实现原理如下：</p>
<ol type="1">
<li>当客户端进程启动时，它会创建一个伪终端设备。客户端将伪终端的主设备文件描述符传递给服务端进程。</li>
<li>服务端进程收到客户端传递的伪终端主设备文件描述符后，它会打开该设备，并将其作为自己的标准输入和标准输出。这样，服务端进程就可以通过读取和写入该设备来与客户端进行通信。</li>
<li>如此一来，客户端和服务器进程之间就建立了一个管道，通过这个管道双方可以交换数据。<strong>客户端进程读取用户输入，并将其写入伪终端设备，而服务端进程则从伪终端设备中读取数据，并将结果写回到伪终端。</strong></li>
<li>对于客户端来说，它认为自己正在与一个终端进行交互，而对于服务端进程来说，它认为自己正在与一个用户进行交互。因此，伪终端的实现使得两个进程之间的通信就像是一个真实的终端会话一样。</li>
</ol>
<p><strong>以SSH远程登陆为例：</strong></p>
<figure>
<img src="../images/UART应用编程/image-20231006165804068.png"
alt="image-20231006165804068" />
<figcaption aria-hidden="true">image-20231006165804068</figcaption>
</figure>
<h2 id="理解linux的不同设备节点">2.理解Linux的不同设备节点</h2>
<table>
<colgroup>
<col style="width: 53%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>设备节点</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>/dev/ttyS0、/dev/ttySAC0</td>
<td>串口</td>
</tr>
<tr class="even">
<td>/dev/tty1、/dev/tty2、/dev/tty3、……</td>
<td>虚拟终端设备节点</td>
</tr>
<tr class="odd">
<td>/dev/tty0</td>
<td>前台终端</td>
</tr>
<tr class="even">
<td>/dev/tty</td>
<td>当前shell对应的终端</td>
</tr>
<tr class="odd">
<td>/dev/console</td>
<td>控制台，由内核的cmdline参数确定</td>
</tr>
</tbody>
</table>
<figure>
<img src="../images/UART应用编程/image-20231006172508437.png"
alt="image-20231006172508437" />
<figcaption aria-hidden="true">image-20231006172508437</figcaption>
</figure>
<ul>
<li><code>/dev/ttyN(N=1,2,3...)</code>：表示某个shell程序使用的虚拟终端，通过快捷键<code>Ctrl+Alt+Fx</code>来切换不同终端</li>
<li><code>/dev/tty0</code>：代表前台shell程序的虚拟终端</li>
<li><code>/dev/tty</code>：表示当前shell程序的终端，可能是虚拟终端也可能是串口终端</li>
<li><code>/dev/console</code>：控制台，可以理解为权限更大，能查看更多信息的终端，比如可以在控制台上看到内核得到打印信息
<ul>
<li>可以通过内核的cmdline来指定哪一个终端作为控制台，例如<code>console=tty</code>，如果不设置则默认第一个tty设备为控制台</li>
</ul></li>
</ul>
<h2 id="uart应用编程">3. UART应用编程</h2>
<blockquote>
<p>参考资料：</p>
<p><a
href="https://digilander.libero.it/robang/rubrica/serial.htm">Serial
Programming Guide for POSIX Operating Systems</a></p>
<p>代码示例：<a
href="https://www.cnblogs.com/feisky/archive/2010/05/21/1740893.html">Linux串口编程</a></p>
<p>termios结构体详细信息：<a
href="https://blog.csdn.net/yemingzhu163/article/details/5897156">Linux串口-struct
termios结构体</a></p>
</blockquote>
<h3 id="串口api">3.1 串口API</h3>
<p>在Linux上操作设备的统一接口：<code>open/ioctl/read/write</code>；对于UART，又在<code>ioctl</code>上封装了用于设置行规程的函数。</p>
<ul>
<li><p>行规程的参数使用结构体<code>termios</code>来表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>	<span class="type">cc_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>	<span class="type">speed_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>	<span class="type">tcflag_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termios</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">tcflag_t</span> c_iflag;		<span class="comment">/* input mode flags */</span></span><br><span class="line">    <span class="type">tcflag_t</span> c_oflag;		<span class="comment">/* output mode flags */</span></span><br><span class="line">    <span class="type">tcflag_t</span> c_cflag;		<span class="comment">/* control mode flags */</span></span><br><span class="line">    <span class="type">tcflag_t</span> c_lflag;		<span class="comment">/* local mode flags */</span></span><br><span class="line">    <span class="type">cc_t</span> c_line;			<span class="comment">/* line discipline */</span></span><br><span class="line">    <span class="type">cc_t</span> c_cc[NCCS];		<span class="comment">/* control characters */</span></span><br><span class="line">    <span class="type">speed_t</span> c_ispeed;		<span class="comment">/* input speed */</span></span><br><span class="line">    <span class="type">speed_t</span> c_ospeed;		<span class="comment">/* output speed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>行规程的配置函数在名称上有一些惯例：</p>
<ul>
<li>tc：terminal contorl</li>
<li>cf：control flag</li>
</ul>
<table>
<thead>
<tr class="header">
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>tcgetattr</td>
<td>get terminal attributes，获得终端的属性</td>
</tr>
<tr class="even">
<td>tcsetattr</td>
<td>set terminal attributes，修改终端参数</td>
</tr>
<tr class="odd">
<td>tcflush</td>
<td>清空终端未完成的输入/输出请求及数据</td>
</tr>
<tr class="even">
<td>cfsetispeed</td>
<td>sets the input baud rate，设置输入波特率</td>
</tr>
<tr class="odd">
<td>cfsetospeed</td>
<td>sets the output baud rate，设置输出波特率</td>
</tr>
<tr class="even">
<td>cfsetspeed</td>
<td>同时设置输入、输出波特率</td>
</tr>
</tbody>
</table></li>
</ul>
<h3 id="打开串口和配置行规程">3.2 打开串口和配置行规程</h3>
<p><code>termios</code>结构体的配置还是相当复杂的，<a
href="https://www.cnblogs.com/feisky/archive/2010/05/21/1740893.html">Linux串口编程</a>这篇文章中给了封装好的配置函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 设置串口参数</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; fd 串口设备文件</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; nSpeed 波特率(2400 4800 9600 115200)</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; nBits 数据位(7 or 8)</span></span><br><span class="line"><span class="comment"> * @param &#123;char&#125; nEvent 校验方式(O/E/N:奇校验/偶校验/无校验)</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; nStop 停止位(1 or 2)</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; minByte 最小接收字节</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; minTime 首字节最小等待时间</span></span><br><span class="line"><span class="comment"> * @return &#123;配置结果&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">set_opt</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> nSpeed, <span class="type">int</span> nBits, <span class="type">char</span> nEvent, <span class="type">int</span> nStop, <span class="type">int</span> minByte, <span class="type">int</span> minTime)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">newtio</span>, <span class="title">oldtio</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*保存测试现有串口参数设置，在这里如果串口号等出错，会有相关的出错信息*/</span></span><br><span class="line">    <span class="keyword">if</span> (tcgetattr(fd, &amp;oldtio) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;SetupSerial 1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;newtio, <span class="keyword">sizeof</span>(newtio));</span><br><span class="line">    <span class="comment">/* 设置字符大小*/</span></span><br><span class="line">    newtio.c_cflag |= CLOCAL | CREAD;</span><br><span class="line">    newtio.c_cflag &amp;= ~CSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置行规程为原始模式(Raw Mode)方式(禁用规范模式、回显和信号处理，以及禁用输出处理) */</span></span><br><span class="line">    newtio.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ISIG); <span class="comment">/*Input*/</span></span><br><span class="line">    newtio.c_oflag &amp;= ~OPOST;                          <span class="comment">/*Output*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置字元位数*/</span></span><br><span class="line">    <span class="keyword">switch</span> (nBits)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        newtio.c_cflag |= CS7;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        newtio.c_cflag |= CS8;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置奇偶校验位*/</span></span><br><span class="line">    <span class="keyword">switch</span> (nEvent)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>: <span class="comment">// 奇校验</span></span><br><span class="line">        newtio.c_cflag |= PARENB;</span><br><span class="line">        newtio.c_cflag |= PARODD;</span><br><span class="line">        newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: <span class="comment">// 偶校验</span></span><br><span class="line">        newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">        newtio.c_cflag |= PARENB;</span><br><span class="line">        newtio.c_cflag &amp;= ~PARODD;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>: <span class="comment">// 无校验位</span></span><br><span class="line">        newtio.c_cflag &amp;= ~PARENB;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*设置波特率*/</span></span><br><span class="line">    <span class="keyword">switch</span> (nSpeed)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2400</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B2400);</span><br><span class="line">        cfsetospeed(&amp;newtio, B2400);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4800</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B4800);</span><br><span class="line">        cfsetospeed(&amp;newtio, B4800);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9600</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B9600);</span><br><span class="line">        cfsetospeed(&amp;newtio, B9600);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">115200</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B115200);</span><br><span class="line">        cfsetospeed(&amp;newtio, B115200);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cfsetispeed(&amp;newtio, B9600);</span><br><span class="line">        cfsetospeed(&amp;newtio, B9600);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置停止位*/</span></span><br><span class="line">    <span class="keyword">if</span> (nStop == <span class="number">1</span>)</span><br><span class="line">        newtio.c_cflag &amp;= ~CSTOPB;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nStop == <span class="number">2</span>)</span><br><span class="line">        newtio.c_cflag |= CSTOPB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置等待时间和最小接收字符*/</span></span><br><span class="line">    newtio.c_cc[VMIN] = minByte;  <span class="comment">/* 读数据时的最小字节数: 没读到这些数据我就不返回! */</span></span><br><span class="line">    newtio.c_cc[VTIME] = minTime; <span class="comment">/* 等待第1个数据的时间:</span></span><br><span class="line"><span class="comment">                             * 比如VMIN设为10表示至少读到10个数据才返回,</span></span><br><span class="line"><span class="comment">                             * 但是没有数据总不能一直等吧? 可以设置VTIME(单位是10秒)</span></span><br><span class="line"><span class="comment">                             * 假设VTIME=1，表示:</span></span><br><span class="line"><span class="comment">                             *    10秒内一个数据都没有的话就返回</span></span><br><span class="line"><span class="comment">                             *    如果10秒内至少读到了1个字节，那就继续等待，完全读到VMIN个数据再返回</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">    <span class="comment">/*处理未接收字符*/</span></span><br><span class="line">    tcflush(fd, TCIFLUSH);</span><br><span class="line">    <span class="comment">/*激活新配置*/</span></span><br><span class="line">    <span class="keyword">if</span> ((tcsetattr(fd, TCSANOW, &amp;newtio)) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;com set error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 打开串口设备</span></span><br><span class="line"><span class="comment"> * @param &#123;char&#125; *com 设备文件路径</span></span><br><span class="line"><span class="comment"> * @return &#123;int&#125; fd 串口设备文件描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open_port</span><span class="params">(<span class="type">char</span> *com)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 可读可写，不作为终端 */</span></span><br><span class="line">    fd = open(com, O_RDWR | O_NOCTTY);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一个小问题">3.2.1 一个小问题</h4>
<p>使用上述代码打开串口设备文件时，按理来说是以阻塞方式打开的设备文件，如果没有写入数据，那么调用<code>read()</code>读取时应该会阻塞。<strong>对于其他大部分设备文件确实会阻塞，但是对于串口设备文件却没有阻塞，直接返回0，表示读取到0字节的数据。</strong></p>
<p>应该和行规程有关，<strong>对于串口设备，可以通过设置行规程中的参数来控制是否阻塞</strong>。而其他设备文件都不会经过行规程。不过具体是什么原因，还得通过阅读源码才能知道。</p>
<h3 id="使用串口与gps模块通信">3.3 使用串口(与GPS模块通信)</h3>
<h4 id="民用gps常用数据格式">3.3.1 民用GPS常用数据格式</h4>
<p><strong>NVMEA0183
格式</strong>主要针对民用定位导航。使用串口接收数据，收到的数据头包括：</p>
<table>
<thead>
<tr class="header">
<th>数据头</th>
<th>表示的内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>$GPGGA</td>
<td>GPS 定位数据</td>
</tr>
<tr class="even">
<td>$GPGLL</td>
<td>地理定位信息</td>
</tr>
<tr class="odd">
<td>$GPGSA</td>
<td>当前卫星信息</td>
</tr>
<tr class="even">
<td>$GPGSV</td>
<td>可见卫星状态信息</td>
</tr>
<tr class="odd">
<td>$GPRMC</td>
<td>推荐最小定位信息</td>
</tr>
<tr class="even">
<td>$GPVTG</td>
<td>地面速度信息</td>
</tr>
</tbody>
</table>
<p>以$GPGGA为例，其标准格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$XXGGA,&lt;1&gt;,&lt;2&gt;,&lt;3&gt;,&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;,&lt;8&gt;,&lt;9&gt;,M,&lt;10&gt;,M,&lt;11&gt;,&lt;12&gt;*hh&lt;CR&gt;&lt;LF&gt;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$GPGGA,<span class="number">074529.82</span>,<span class="number">2429.6717</span>,N,<span class="number">11804.6973</span>,E,<span class="number">1</span>,<span class="number">8</span>,<span class="number">1.098</span>,<span class="number">42.110</span>,,, M,, *<span class="number">76</span></span><br></pre></td></tr></table></figure>
<p>$XXGGA中XX的取值及对应类型如下：</p>
<ul>
<li>GPGGA：单 GPS</li>
<li>BDGGA：单北斗</li>
<li>GLGGA：单 GLONASS</li>
<li>GNGGA：多星联合定位</li>
</ul>
<p>其余各个字段的含义及取值范围如下：</p>
<figure>
<img src="../images/UART应用编程/image-20231011204725792.png"
alt="image-20231011204725792" />
<figcaption aria-hidden="true">image-20231011204725792</figcaption>
</figure>
<p><code>hh</code>表示校验和，即是对除去"$"和"*"之外的所有字符的ASCII码进行按位异或（XOR）操作，并将得到的结果作为校验和，通常以十进制进行表示。</p>
<h5 id="经纬度的度分制表示">经纬度的度分制表示</h5>
<p>度分制是一种用于表示经纬度的格式化方式，在度分制中，一个地理位置的纬度和经度被表示为<strong>度数(整数)和分钟数的组合</strong>，度数部分可能代表具体位置所在的纬度带，而分钟数则可以表示具体位置在该纬度带内的精确偏移量。以纬度格式<code>ddmm.mmmm</code>为例，其中dd表示度数，mm.mmmm表示分钟数。度数范围从0到90度。分钟数的范围从0到59.9999分钟，例如“37度24.5684分钟”可以写作37°24.5684</p>
<h4 id="代码">3.3.2 代码</h4>
<p>参考上面打开串口和配置行规程的代码进行配置之后，使用以下函数读取原始数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read_gps_raw_data</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iRet, i = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iRet = read(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (iRet == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;$&#x27;</span>)  start = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (start)     buf[i++] = c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span> || c == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数使用休眠-唤醒方式(行规程设置读取1字节后返回)读取GPS模块发送的原始数据。</p>
<p>当读取完原始数据之后，可以通过sscanf()对原始数据进行解析：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> time, lat, lng;  </span><br><span class="line"><span class="type">char</span> tmp[<span class="number">10</span>];     </span><br><span class="line"><span class="type">char</span> ns, ew;            </span><br><span class="line"><span class="type">char</span> tmp[<span class="number">10</span>], time[<span class="number">100</span>], lat[<span class="number">100</span>], lng[<span class="number">100</span>];  <span class="comment">//数据头标识 时间 纬度 经度</span></span><br><span class="line"><span class="type">char</span> ns, ew;                                  <span class="comment">// 南北半球 东西半球</span></span><br><span class="line"><span class="built_in">sscanf</span>(buf, <span class="string">&quot;%[^,],%[^,],%[^,],%c,%[^,],%c&quot;</span>, tmp, time, lat, &amp;ns, lng, &amp;ew);</span><br></pre></td></tr></table></figure>
<p><code>%[^,]</code>表示除了<code>,</code>之外的所有字符。</p>
<p>当读取到度分制的经纬度之后，可以通过如下代码将度分制转化为度数浮点数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 纬度格式: ddmm.mmmm */</span></span><br><span class="line"><span class="built_in">sscanf</span>(Lat + <span class="number">2</span>, <span class="string">&quot;%f&quot;</span>, &amp;fLat);</span><br><span class="line">fLat = fLat / <span class="number">60</span>;</span><br><span class="line">fLat += (Lat[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (Lat[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>至此，完成GPS模块的数据的接收以及解析。</p>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix-Linux编程实践教程-章节1笔记</title>
    <url>/2023/09/12/Unix-Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B-%E7%AB%A0%E8%8A%821%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="more">more</h2>
<h3 id="more的三种用法">more的三种用法</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">more filename      //分页显示文件内容</span><br><span class="line">command | more     //将command命令的输出分页显示</span><br><span class="line">more &lt; filename    //more从标准输入中获取要分页显示的内容，而标准输入被从重定向到filename</span><br></pre></td></tr></table></figure>
<ul>
<li><code>enter</code>显示下一行，<code>space</code>显示下一页，<code>q</code>退出</li>
<li>管道命令<code>|</code>将command的输出重定向到more的输入</li>
</ul>
<p>例如命令<code>ls /bin | more</code>，ls命令的标准输出重定向到more的标准输入，如果还是使用<code>getchar()</code>来读取用户的输入，那么就会从ls的输出中读取，这显然不行，所以需要其他方式</p>
<h3 id="devtty">/dev/tty</h3>
<p>通过在more命令中打开<code>/dev/tty</code>文件进行读取的方式，使得more可以从其他途径中获取到用户输入</p>
<ul>
<li>键盘和显示器的设备描述文件</li>
<li>向这个文件写相当于显示在用户的屏幕上，读相当于从键盘获得用户的输入</li>
</ul>
<h2 id="c函数">C函数</h2>
<h3 id="gets">gets</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将读取到内容保存在s中，遇到换行符、文件结尾时读取结束，不会检查输入会溢出s的大小</li>
<li>该函数于C11已经废弃</li>
<li>返回值：读取正确返回s,发生错误返回NULL，溢出则什么可能都会发生</li>
</ul>
<h3 id="fgets">fgets</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> size, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ungetc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>fgets:读取到size-1个字符(最后一个位置会填上<code>\0</code>)，遇到换行符，文件结尾时结束</li>
<li>返回值：
<ul>
<li>对于<code>fgets</code>如果返回s表示读取成功，如果返回NULL表示读取错误或者什么都没有读取到</li>
<li>对于其他函数(除了ungetc)，返回读取到的字符转化为int的值，返回EOF表示错误或者读取到了文件结尾</li>
</ul></li>
</ul>
<h3 id="fputs">fputs</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：该函数返回一个非负值，如果发生错误则返回 EOF(-1)。</li>
</ul>
<h3 id="fgetc">fgetc</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>功能是从文件指针指定的文件中读入一个字符，该字符的ASCII值作为函数的返回值。</li>
<li>若返回值为EOF，说明文件结束。如果发生错误也返回 EOF(-1)</li>
</ul>
<h3 id="perror">perror</h3>
<ul>
<li>使用perror()函数，它可以自己查找错误代码，并在标准错误输出中显示相应的错误信息</li>
<li>参数：string是同时显示的描述信息，例如对于文件操作的代码，可以把文件名作为描述信息传进去</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="strtoul">strtoul</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">strtoul</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr, <span class="type">char</span> **endptr, <span class="type">int</span> base)</span>; </span><br></pre></td></tr></table></figure>
<ul>
<li><p>该函数尝试将字符串转换为一个无符号长整型</p></li>
<li><p>参数：</p>
<ul>
<li>nptr：待转换的字符串</li>
<li>endptr：如果传入指针不为NULL，则返回nptr中首个不为合法数字的字符的地址(使用指针的指针就是为了能够修改指针的内容)；<strong>当遇到首个不合法字符时，转换过程停止。</strong></li>
<li>base：<strong>应该以何种进制来解释字符串中的数字</strong>，该值可以传入2~36，或者特殊值0；如果传入0则该函数会根据字符串首部来确定进制：
<ul>
<li>如果 <code>nptr</code> 以 "0x" 或 "0X" 开头，则基数为 16。</li>
<li>如果 <code>nptr</code> 以 "0" 开头，则基数为 8。</li>
<li>否则，基数为 10。</li>
</ul></li>
</ul></li>
<li><p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;12345abcd&quot;</span>;  <span class="comment">// 输入字符串</span></span><br><span class="line">    <span class="type">char</span> *end;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> value;</span><br><span class="line">    value = strtoul(str, &amp;end, <span class="number">10</span>);  <span class="comment">// 转换为十进制的无符号长整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;转换结果: %lu\n&quot;</span>, value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未转换的部分: %s\n&quot;</span>, end);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">转换结果: 12345</span><br><span class="line">未转换的部分: abcd</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="c语言知识复习">C语言知识复习</h2>
<ul>
<li>sizeof(string):会计入'\0'</li>
</ul>
<h3 id="声明字符串的两种方式">声明字符串的两种方式</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;hello wrold&quot;</span>;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;hello wrold&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>char *str</code>里的str是指针变量,指向一个字符串常量
<ul>
<li><code>sizeof(str)</code>:返回的是指针变量的大小，而不是字符串的长度</li>
<li><code>str[0] = 'H</code>:会报<code>Segment fault</code>错误，<strong>常量字符串不可修改</strong></li>
<li><code>str = "Hello"</code>：指针可以修改指向不同的常量字符串</li>
</ul></li>
<li><code>char str[]</code>里str是地址常量，str的值是str[]的地址，它声明了一个字符数组
<ul>
<li><code>sizeof(str)</code>:返回字符串的大小，包括'\0'</li>
</ul></li>
</ul>
<h3 id="c语言的内存分配方式">C语言的内存分配方式</h3>
<p>内存分配可分为三种：<code>静态存储区、栈区、堆区</code>。</p>
<p>1、静态存储区：该内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，它主要存放<code>静态数据、全局数据和常量</code>。
2、栈区：它的用途是完成函数的调用。在执行函数时，函数内局部变量及函数参数的存储单元在栈上创建，函数调用结束时这些存储单元自动被释放。
3、堆区：程序在运行时使用库函数为变量申请内存，在变量使用结束后再调用库函数释放内存。动态内存的生存期是由我们决定的，如果我们不释放内存，就会导致内存泄漏。</p>
<h3 id="section"></h3>
<h2 id="linux系统调用">linux系统调用</h2>
<h3 id="read">read</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：成功则返回读取数量，遇到错误返回-1</li>
</ul>
<h3 id="open">open</h3>
<ul>
<li>open()已经逐渐取代了creat()的使用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数：</p></li>
<li><p>flags:</p>
<ul>
<li><code>O_RDONLY</code>, <code>O_WRONLY</code>,
<code>O_RDWR</code>，分别对应只读，只写，读写三种；这三个参数应指定其中一个，然后或上可选参数：</li>
<li><code>O_CREAT</code>若文件不存在则创建它。使用此选项时，<strong>需要同时说明第三个参数mode</strong>，用其说明该新文件的存取许可权限</li>
<li><code>O_EXCL</code>如果同时指定了<code>O_CREAT</code>，<strong>而文件已经存在，则出错</strong></li>
<li><code>O_APPEND</code>每次写时都加到文件的尾端。（写文件在文件末尾不会覆盖原先内容）</li>
<li><code>O_TRUNC</code>属性去打开文件时，如果这个文件中本来是有内容的，而且为只读或只写成功打开，则将其长度截短为0。（如果文件里面有东西直接删然后写）</li>
</ul></li>
<li><p>mode:
一定是在flags中使用了<code>O_CREAT</code>标志，mode表示待创建的文件的访问权限</p></li>
<li><p>返回值：成功则返回文件描述符，遇到错误返回-1</p></li>
<li><p>打开文件可能出错的原因多种多样，具体请查看文档</p></li>
</ul>
<h3 id="close">close</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：0表示成功关闭，-1表示出现错误</li>
</ul>
<h3 id="ctime">ctime</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">ctime</span><span class="params">(<span class="type">const</span> <span class="type">time_t</span> *timep)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：格式为<code>"Wed Jun 30 21:49:08 1993\n"</code>的字符串</li>
<li><code>time_t</code>为<code>long int</code>类型</li>
<li>utmp文件中的<code>ut-&gt;time</code>表示用户从登录时间到初始时间所经过的秒数</li>
</ul>
<h3 id="creat">creat</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：
<ul>
<li>mode:访问模式,传入三个用户组的权限对于该文件的权限(mode_t应该是unsigned
int类型)</li>
</ul></li>
<li>返回值：成功返回文件描述符，失败返回-1</li>
<li>没有则创建文件，如果文件存在则它的内容会被清空。</li>
</ul>
<h3 id="write">write</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：成功则返回写入的字节数，失败则返回-1</li>
<li>为什么写入字节数会少于指定数量：
<ul>
<li>系统对文件的最大长度有限制，或者磁盘空间不足</li>
<li>因此有必要校验是否完全写入</li>
</ul></li>
</ul>
<h3 id="lseek函数">lseek()函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/type.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> oldpos = lseek(<span class="type">int</span> fd , <span class="type">off_t</span> dist , <span class="type">int</span> base)</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：
<ul>
<li>dist:移动的距离</li>
<li>base:<code>SEEK_SET -&gt; 文件开始</code>，<code>SEEK_CUR -&gt; 当前位置</code>
， <code>SEEK_END -&gt; 文件结尾</code></li>
</ul></li>
<li>返回值：返回指针变化前的位置，返回-1表示遇到错误</li>
</ul>
<h3 id="stat函数">stat()函数</h3>
<p>该函数返回关于一个文件的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">    <span class="type">ino_t</span>     st_ino;         <span class="comment">/* Inode number */</span> 索引编号</span><br><span class="line">    <span class="type">mode_t</span>    st_mode;        <span class="comment">/* File type and mode */</span></span><br><span class="line">    <span class="type">nlink_t</span>   st_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">    <span class="type">uid_t</span>     st_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>     st_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">    <span class="type">dev_t</span>     st_rdev;        <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">    <span class="type">off_t</span>     st_size;        <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>  st_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Since Linux 2.6, the kernel supports nanosecond</span></span><br><span class="line"><span class="comment">        precision for the following timestamp fields.</span></span><br><span class="line"><span class="comment">        For the details before Linux 2.6, see NOTES. */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查文件类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	__S_ISTYPE(mode, mask)	(((mode) &amp; __S_IFMT) == (mask))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	S_ISDIR(mode)	 __S_ISTYPE((mode), __S_IFDIR)  <span class="comment">//目录</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	S_ISCHR(mode)	 __S_ISTYPE((mode), __S_IFCHR)  <span class="comment">//字符特殊设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	S_ISBLK(mode)	 __S_ISTYPE((mode), __S_IFBLK)  <span class="comment">//块特殊设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	S_ISREG(mode)	 __S_ISTYPE((mode), __S_IFREG)  <span class="comment">//普通文件</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：如果成功返回0，否则返回-1，并且<code>error</code>会设置为相应的错误类型</li>
</ul>
<h3 id="ioctl">ioctl()</h3>
<p>用来操作<strong>底层设备文件的参数</strong>的系统调用。ioctl
的作用非常强大、灵活。不同的驱动程序内部会实现不同的
ioctl，应用可以使用各种 ioctl
跟驱动程序交互：可以传数据给驱动程序，也可以从驱动程序中读出数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：
<ul>
<li>fd 表示文件描述符；</li>
<li>request
表示与驱动程序交互的命令，用不同的命令控制驱动程序输出我们需要的数据；</li>
<li>... 表示可变参数 arg，根据 request
命令，设备驱动程序返回输出的数据</li>
</ul></li>
<li>返回值：
<ul>
<li>通常成功返回0，失败将返回-1</li>
</ul></li>
</ul>
<h3 id="mmap">mmap()</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,<span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：
<ul>
<li>addr：表示指定映射的內存起始地址，通常设为 NULL
表示让系统自动选定地址，并在成功映射后返回该地址；</li>
<li>length：表示将文件中多大的内容映射到内存中；</li>
<li>prot：表示映射区域的保护方式，可以为以下 4 种方式的组合：
<ul>
<li>PROT_EXEC 映射区域可被执行</li>
<li>PROT_READ 映射区域可被读出</li>
<li>PROT_WRITE 映射区域可被写入</li>
<li>PROT_NONE 映射区域不能存取</li>
</ul></li>
<li>flags：表示影响映射区域的不同特性，常用的有以下两种：
<ul>
<li>MAP_SHARED
表示对映射区域写入的数据会复制回文件内，原来的文件会改变。</li>
<li>MAP_PRIVATE
表示对映射区域的操作会产生一个映射文件的复制，对此区域的任何修改都不会写回原来的文件内容中</li>
</ul></li>
<li>fd：被映射的文件描述符</li>
<li>offset：从文件的offset偏移位置开始映射</li>
</ul></li>
<li>返回值：
<ul>
<li>若成功映射，将返回指向映射的区域的指针，失败将返回-1</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《Unix-Linux编程实践教程》</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix-Linux编程实践教程-章节2笔记</title>
    <url>/2023/09/12/Unix-Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B-%E7%AB%A0%E8%8A%822%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="who">who</h2>
<ul>
<li>把程序的可执行文件放到任意的一个目录中（/bin /usr/bin
/usr/local/bin），就可以为系统添加新的命令</li>
</ul>
<h3 id="寻找who的踪迹">寻找who的踪迹</h3>
<ul>
<li><code>man who</code>:发现文件utmp,wtmp很关键</li>
<li><code>man -k utmp</code>:按关键字搜索utmp，发现：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">utmp (5)            - login records</span><br><span class="line">login (3)            - write utmp and wtmp entries</span><br><span class="line">logout (3)           - write utmp and wtmp entries</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>man 5 utmp</code>:发现<code>&lt;utmp.h&gt;</code>中关于utmp结构体的定义</p></li>
<li><p>通过阅读以上信息，知道<code>who</code>通过读文件获得需要的信息，而每一个登录用户的信息在文件中都有记录,所以编写<code>who</code>命令分为两步：</p>
<ul>
<li>a.从<code>UTMP_FILE</code>文件中读取数据结构</li>
<li>b.将结构体中的信息以适当的形式显示出来</li>
</ul></li>
</ul>
<h3 id="如何读取数据结构">如何读取数据结构</h3>
<ul>
<li><p><code>man -k file | grep read</code>：将man的输出重定向到grep的输入，grep查找符合条件的字符串，发现：</p>
<ul>
<li><code>read (2)             - read from a file descriptor</code></li>
<li>注：grep的查找关键字是随意输入的主题相关的单词</li>
</ul></li>
<li><p><code>man 2 read</code>:发现文件操作必须的三个函数<code>read、open、close</code></p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：成功则返回读取数量，遇到错误返回-1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int open(const char *pathname, int flags);</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：
<ul>
<li>flags:O_RDONLY, O_WRONLY, or
O_RDWR，分别对应只读，只写，读写三种</li>
</ul></li>
<li>返回值：成功则返回文件描述符，遇到错误返回-1</li>
<li>打开文件可能出错的原因多种多样，具体请查看文档</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：0表示成功关闭，-1表示出现错误</li>
</ul>
<p>通过以上三个函数即可读取登录信息记录文件<code>UTMP_FILE</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if((utmpfd = open(UTMP_FILE , O_RDONLY)) == -1)</span><br><span class="line">    perror(UTMP_FILE);   //用法</span><br><span class="line"></span><br><span class="line">while (read(utmpfd , &amp;current_record , len) == len)</span><br><span class="line">    show_info(&amp;current_record);</span><br><span class="line"></span><br><span class="line">close(utmpfd);</span><br></pre></td></tr></table></figure>
<h3 id="将结构体中的信息显示">将结构体中的信息显示</h3>
<p>主要是以合适格式显示登录时间，通过以下命令查询相关函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man -k time | grep transform</span><br><span class="line">man 3 ctime</span><br></pre></td></tr></table></figure>
<p>函数ctime的信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;time.h&gt;</span><br><span class="line">char *ctime(const time_t *timep);</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：格式为<code>"Wed Jun 30 21:49:08 1993\n"</code>的字符串</li>
<li><code>time_t</code>为<code>long int</code>类型</li>
<li>utmp文件中的<code>ut-&gt;time</code>表示用户从登录时间到初始时间所经过的秒数</li>
</ul>
<h3 id="who的工作流程">who的工作流程</h3>
<p>1.打开UTMP_FILE路径对应的文件 2.读出一个utmp结构，并显示
3.关闭utmp文件</p>
<h4 id="在用户空间中使用缓冲区">在用户空间中使用缓冲区</h4>
<p>1.一次读取16个utmp结构，以供显示
2.当缓冲区中的内容显示完成之后，在进行系统调用，从内核中读取utmp结构数据</p>
<h4 id="内核中的缓冲技术">内核中的缓冲技术</h4>
<ul>
<li>read()将数据从内核缓冲区读取到进程缓冲区。如果进程所要求的数据块不在内核缓冲区，则内核会把对该数据块的请求加入到请求数据队列中，然后将进程挂起；当内核把数据块从磁盘读取到内核缓冲区之后，再把数据从内核缓冲区复制到进程缓冲区，最后再唤醒挂起的进程。</li>
<li>write()将数据从进程缓冲区复制到内核缓冲区。内核会把需要写的数据暂时存在缓冲区中，积累到一定数量之后再一次性写入到磁盘中。如果发生意外情况(停电)，有可能内核来不及将数据写入到磁盘中，就会导致数据丢失。</li>
</ul>
<h3 id="修改用户登录信息">修改用户登录信息</h3>
<p>1.打开utmp文件 2.查找需要修改的登录记录，并修改 3.关闭文件</p>
<h4 id="文件读取过程">文件读取过程</h4>
<ul>
<li>从文件读数据时，从指针标明的地方开始读取指定字节并将指针移动至下一未被读取的字节</li>
<li>指针与文件描述符相关，所以两个程序同时读一个文件时互不影响</li>
</ul>
<h4 id="lseek函数">lseek()函数</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/type.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">off_t oldpos = lseek(int fd , off_t dist , int base)</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：
<ul>
<li>dist:移动的距离</li>
<li>base:基准位置
<code>SEEK_SET -&gt; 文件开始</code>，<code>SEEK_CUR -&gt; 当前位置</code>
， <code>SEEK_END -&gt; 文件结尾</code></li>
</ul></li>
<li>返回值：返回指针变化前的位置，返回-1表示遇到错误</li>
</ul>
<h3
id="修改utmp文件中记录的ut-type">修改UTMP文件中记录的ut-&gt;type</h3>
<ul>
<li><code>ut-&gt;type</code>表示该记录的某种状态，例如<code>USER_PROCESS</code>表示正常的登录进程，<code>DEAD_PROCESS</code>表示终止的登录进程
<ul>
<li>不过用户logout之后并不会修改其为<code>DEAD_PROCESS</code>,不确定什么情况下会使用<code>DEAD_PROCESS</code>来标记登录记录</li>
</ul></li>
<li><code>/var/lib/wtmp</code>:记录了本系统中历史登录信息</li>
<li><code>/var/run/utmp</code>:记录当前的登录信息</li>
</ul>
<h4 id="编写logout_tty函数">编写logout_tty()函数</h4>
<p>1.打开wtmp文件 2.循环读取，寻找匹配记录
3.定位文件指针到该记录的开始位置 4.写入需要修改的内容 5.关闭文件</p>
<ul>
<li>通过对比传入的ut_line来修改对应记录的<code>ut-&gt;type</code>属性</li>
<li>编写时注意<code>open()</code>传入的flags应为<code>O_RDWR</code>
<ul>
<li>如果传了<code>O_RDONLY</code>则写入时会perror报<code>/var/log/wtmp: Bad file descriptor</code></li>
<li><code>Bad file descriptor</code>:如果文件描述符有问题，也会报出这个错误(一般文件描述符不会太大，太大时八成是没有初始化)</li>
</ul></li>
<li>查看一下<code>/var/lib/wtmp</code>的信息以及当前用户和root用户的所属组：
<ul>
<li>该文件属于root用户，而我们和root用户不同组，属于其他组，没有写入权限，报<code>/var/log/wtmp: Permission denied</code></li>
<li>可以切换成root用户再执行</li>
</ul></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//wtmp信息</span><br><span class="line">-rw-rw-r-- 1 root utmp 22656 10月 26 16:54 /var/log/wtmp</span><br><span class="line"></span><br><span class="line">// 用户所属组信息</span><br><span class="line">zhaoyan : zhaoyan adm cdrom sudo dip plugdev lpadmin lxd sambashare</span><br><span class="line">root : root</span><br></pre></td></tr></table></figure>
<h2 id="cp">cp</h2>
<ul>
<li>拷贝：<code>cp source_file target_file</code></li>
</ul>
<h3 id="使用的系统调用">使用的系统调用</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int creat(const char *pathname, mode_t mode);</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：
<ul>
<li>mode:访问模式(mode_t应该是unsigned int类型)</li>
</ul></li>
<li>返回值：成功返回文件描述符，失败返回-1</li>
<li>没有则创建文件，如果文件存在则它的内容会被清空。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：成功则返回写入的字节数，失败则返回-1</li>
<li>为什么写入字节数会少于指定数量：
<ul>
<li>系统对文件的最大长度有限制，或者磁盘空间不足</li>
<li>因此有必要校验是否完全写入</li>
</ul></li>
</ul>
<h4 id="linux权限">linux权限</h4>
<p>例如<code>-rw--r--r-</code>:</p>
<ul>
<li>第一位表示文件类型，-表示文件，d表示目录</li>
<li>从左到右分别是文件所有者的权限(u)，文件所有者所属组成员的权限(g)，所有者所属组之外的用户的权限(o)</li>
<li>r对应4，w对应2，x对应1，-对应0，所以可以用<code>0644</code>来描述（<strong>0表示该数是一个八进制数</strong>）</li>
<li>权限一般用八进制表示，因为二进制每三位对应一组权限，用十六或者十进制都得需要计算一下，不如八进制方便</li>
</ul>
<h2 id="错误提示">错误提示</h2>
<ul>
<li>在&lt;errno.h&gt;中包含错误类型和相应的说明。当系统调用出错时，就会把该文件中的errno全局变量设置为相应的错误代码，然后返回-1。程序可以通过检查errno来确定错误类型，并采取相应的措施。</li>
<li>更方便是使用perror()函数，它可以自己查找错误代码，并在标准错误输出中显示相应的错误信息，string是同时显示的描述信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void perror(const char *s);</span><br></pre></td></tr></table></figure>
<h2 id="cat">cat</h2>
<p>1.判断pathname是一个文件还是目录 2.打开该文件，并通过缓存读取并输出
3.关闭该文件</p>
<h3 id="如何判断是文件还是目录">如何判断是文件还是目录</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- man 2 stat</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int stat(const char *pathname, struct stat *statbuf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct stat &#123;</span><br><span class="line">    dev_t     st_dev;         /* ID of device containing file */</span><br><span class="line">    ino_t     st_ino;         /* Inode number */ 索引编号</span><br><span class="line">    mode_t    st_mode;        /* File type and mode */</span><br><span class="line">    nlink_t   st_nlink;       /* Number of hard links */</span><br><span class="line">    uid_t     st_uid;         /* User ID of owner */</span><br><span class="line">    gid_t     st_gid;         /* Group ID of owner */</span><br><span class="line">    dev_t     st_rdev;        /* Device ID (if special file) */</span><br><span class="line">    off_t     st_size;        /* Total size, in bytes */</span><br><span class="line">    blksize_t st_blksize;     /* Block size for filesystem I/O */</span><br><span class="line">    blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */</span><br><span class="line"></span><br><span class="line">    /* Since Linux 2.6, the kernel supports nanosecond</span><br><span class="line">        precision for the following timestamp fields.</span><br><span class="line">        For the details before Linux 2.6, see NOTES. */</span><br><span class="line"></span><br><span class="line">    struct timespec st_atim;  /* Time of last access */</span><br><span class="line">    struct timespec st_mtim;  /* Time of last modification */</span><br><span class="line">    struct timespec st_ctim;  /* Time of last status change */</span><br><span class="line"></span><br><span class="line">#define st_atime st_atim.tv_sec      /* Backward compatibility */</span><br><span class="line">#define st_mtime st_mtim.tv_sec</span><br><span class="line">#define st_ctime st_ctim.tv_sec</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//检查文件类型</span><br><span class="line">#define	__S_ISTYPE(mode, mask)	(((mode) &amp; __S_IFMT) == (mask))</span><br><span class="line"></span><br><span class="line">#define	S_ISDIR(mode)	 __S_ISTYPE((mode), __S_IFDIR)  //目录</span><br><span class="line">#define	S_ISCHR(mode)	 __S_ISTYPE((mode), __S_IFCHR)  //字符特殊设备</span><br><span class="line">#define	S_ISBLK(mode)	 __S_ISTYPE((mode), __S_IFBLK)  //块特殊设备</span><br><span class="line">#define	S_ISREG(mode)	 __S_ISTYPE((mode), __S_IFREG)  //普通文件</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：如果成功返回0，否则返回-1，并且<code>error</code>会设置为相应的错误类型</li>
</ul>
<h2 id="习题">习题</h2>
<p>习题写了cat head last命令，
其中last命令，由于没有找到用户logout信息在哪里存放，所以无法和系统的last保持一致
此外，与head命令相对应的tail命令不是很好写，难在“怎么定位一个文件的倒数10行开始处”这个问题怎么优雅的解决</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《Unix-Linux编程实践教程》</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC和Makefile学习</title>
    <url>/2023/09/10/makefile%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="gcc编译器的使用">1.GCC编译器的使用</h2>
<figure>
<img src="../images/makefile学习/image-20230910100317585.png"
alt="image-20230910100317585" />
<figcaption aria-hidden="true">image-20230910100317585</figcaption>
</figure>
<ul>
<li>预处理：预处理阶段会根据指令对源代码进行<strong>替换、宏展开</strong>等操作。在这个阶段，编译器会根据#include指令查找头文件，并<strong>将头文件的内容插入到main.c文件中</strong>。预处理后的文件通常以.i或.ii为扩展名。</li>
<li>编译：编译阶段将预处理后的文件翻译成汇编语言文件（通常使用.
s扩展名）。编译器将C代码转换为汇编代码，将高级语言代码转换成底层机器语言的表示形式，同时<strong>进行语法检查和优化</strong>。</li>
<li>汇编：汇编阶段将汇编语言代码转换成机器码指令。汇编器将每条汇编指令转换为可执行的机器码，并生成目标文件（通常使用.o扩展名）。目标文件包含机器码指令和一些附加信息，如符号表等。</li>
<li>链接：链接阶段将目标文件与其他库文件进行组装，生成最终的可执行程序。在这个阶段，链接器会解析代码中的符号引用，并将其与库函数的定义进行关联。如果找不到某个符号的定义，链接将会失败，并报出"<strong>undefined
reference</strong>"的错误。</li>
</ul>
<h3 id="常用编译选项">1.1 常用编译选项</h3>
<table>
<thead>
<tr class="header">
<th>常用选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-E</td>
<td>预处理</td>
</tr>
<tr class="even">
<td>-S</td>
<td>编译</td>
</tr>
<tr class="odd">
<td>-c</td>
<td>进行预处理、编译、汇编，但是不链接</td>
</tr>
<tr class="even">
<td>-o</td>
<td>指定输出文件</td>
</tr>
<tr class="odd">
<td>-I</td>
<td>指定头文件目录</td>
</tr>
<tr class="even">
<td>-L</td>
<td>指定链接时库文件目录</td>
</tr>
<tr class="odd">
<td>-l</td>
<td>指定链接哪一个库文件</td>
</tr>
<tr class="even">
<td>-v</td>
<td>输出详细编译信息（比如说库文件查找路径）</td>
</tr>
</tbody>
</table>
<ul>
<li><p>举例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -E -o hello.i hello.c    // 预处理</span><br><span class="line">gcc -S -o hello.s hello.i -v // 编译，输出编译信息</span><br><span class="line">gcc -o hello hello.c         // 输出名为 hello 的可执行程序，然后可以执行./hello </span><br><span class="line">gcc -o hello hello.c -static // 静态链接 </span><br><span class="line">gcc -c -o hello.o hello.c    // 先编译(不链接) </span><br><span class="line">gcc -o hello hello.o         // 再链接</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="编译多个文件">1.2 编译多个文件</h3>
<ul>
<li><p>一起编译、链接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o test main.c sub.c</span><br></pre></td></tr></table></figure></li>
<li><p>分开编译，统一链接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -o main.o main.c </span><br><span class="line">gcc -c -o sub.o sub.c </span><br><span class="line">gcc -o test main.o sub.o</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="动态库和静态库">1.3 动态库和静态库</h3>
<ul>
<li>类 unix 系统，静态库为 <strong>.a</strong>(archive)， 动态库为
<strong>.so</strong>(shared object)。</li>
<li>windows 系统静态库为 <strong>.lib</strong>， 动态库为
<strong>.dll</strong>。</li>
<li><strong>静态库被使用目标代码最终和可执行文件在一起，而动态库与它相反，它的目标代码在运行时或者加载时链接。</strong></li>
<li><a
href="https://zhuanlan.zhihu.com/p/71372182">浅谈静态库和动态库</a></li>
</ul>
<h4 id="制作使用静态库">1.3.1 制作使用静态库</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -o main.o main.c </span><br><span class="line">gcc -c -o sub.o sub.c </span><br><span class="line">ar crs libsub.a sub.o sub2.o sub3.o(可以使用多个.o 生成静态库) </span><br><span class="line">gcc -o test main.o libsub.a (如果.a不在当前目录下，需要使用-L参数指定它的绝对或相对路径)</span><br></pre></td></tr></table></figure>
<h4 id="制作使用动态库">1.3.2 制作使用动态库</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -o main.o main.c </span><br><span class="line">gcc -c -o sub.o sub.c </span><br><span class="line">gcc -shared -o libsub.so sub.o sub2.o sub3.o(可以使用多个.o 生成动态库) </span><br><span class="line">gcc -o test1 main.o libsub.so                 //在当前目录下寻找动态库libsub.so</span><br><span class="line">gcc -o test main.o -lsub -L 指定库文件目录      //-lsub：在工具链指定目录中寻找libsub.so文件</span><br><span class="line">										      // 因此需要使用-L指定该动态库文件的目录		</span><br></pre></td></tr></table></figure>
<h3 id="程序运行的基础知识">1.4 程序运行的基础知识</h3>
<ul>
<li>头文件：<code>&lt;xx.h&gt;</code>
<ul>
<li>在编译工具链指定include目录寻找</li>
<li><code>-I dir</code>：指定头文件目录</li>
</ul></li>
<li>链接：<code>-lxxx</code>
<ul>
<li>在编译工具链指定的lib目录寻找</li>
<li><code>-L dir</code>：指定库文件所在目录</li>
</ul></li>
<li>运行：寻找动态库<code>.so</code>文件
<ul>
<li>在运行程序的系统的指定/lib目录寻找</li>
<li>修改环境变量<code>LD_LIBRARY_PATH</code>添加新路径，例如<code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/new_lib</code></li>
</ul></li>
</ul>
<h4 id="查找编译工具链的指定目录">1.4.1 查找编译工具链的指定目录</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;main()&#123;&#125;&#x27;| arm-buildroot-linux-gnueabihf-gcc -E -v -</span><br></pre></td></tr></table></figure>
<p>echo在标准输入中打印字符串"main(){}"，gcc命令最后的<code>-</code>表示从标准输入中获取输入数据，即gcc对于代码<code>main()&#123;&#125;</code>进行预处理，并输出详细编译信息。<strong>在这些编译信息中，会列出头文件目录(#include
&lt;...&gt;)和库文件目录(LIBRARY_PATH)</strong></p>
<h4 id="运行时库的系统路径">1.4.2 运行时库的系统路径</h4>
<ul>
<li><p>在开发板上<code>/lib</code>或者<code>/usr/lib</code>目录。</p></li>
<li><p>或者在bash中添加新的库路径，见1.4</p></li>
</ul>
<h4 id="如何交叉编译开源软件">1.4.3 如何交叉编译开源软件</h4>
<p>如果开源软件的目录中有<code>configure</code>文件，则使用交叉编译工具链<code>arm-buildroot-linux-gnueabihf</code>编译的万能命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --host=arm-buildroot-linux-gnueabihf --prefix=$PWD/tmp </span><br><span class="line">make                </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<ul>
<li>make执行makefile中编译命令，make
install将生成的软件安装到系统对应目录中，例如<code>/usr/local/bin</code>用于可执行文件，<code>/usr/local/lib</code>用于库文件等。</li>
<li>在上述命令中即为安装到tmp目录下的bin，lib，include目录中，然后在手动将对应文件放到工具链和板子上的对应目录中。</li>
<li><code>prefix=/usr/local</code>：通常make会将生成的软件安装在这个目录中，为了不污染系统库，所以通过<code>--prefix=$PWD/tmp</code>指定安装目录</li>
</ul>
<h2 id="makefile">2. Makefile</h2>
<ul>
<li>Makefile的核心规则：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标 : 依赖1 依赖2</span><br><span class="line">[TAB]命令</span><br></pre></td></tr></table></figure>
<p>当<strong>目标文件不存在或者依赖文件比目标文件新</strong>的时候，就会执行命令。</p>
<p>一般来说，在Makefile中将编译代码文件分为预处理/编译/汇编和链接两步，当某个代码文件重新修改时，Makefile会根据修改时间仅对修改文件进行步骤一，然后重新链接，不必重新编译所有代码文件。</p>
<ul>
<li>make命令基本语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make [目标]</span><br></pre></td></tr></table></figure>
<ul>
<li>假设待编译的实例文件如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        func_b();</span><br><span class="line">        func_c();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//b.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_b</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is func B!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//c.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_c</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is func C!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="makefile编写">2.2 Makefile编写</h3>
<h4 id="第一版">2.2.1 第一版</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">test : a.o b.o c.o</span><br><span class="line">        gcc -o test a.o b.o c.o</span><br><span class="line">a.o : a.c</span><br><span class="line">        gcc -c -o a.o a.c</span><br><span class="line">b.o : b.c</span><br><span class="line">        gcc -c -o b.o b.c</span><br><span class="line">c.o : c.c</span><br><span class="line">        gcc -c -o c.o c.c</span><br></pre></td></tr></table></figure>
<h4 id="使用通配符">2.2.2 使用通配符</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">test : a.o b.o c.o</span><br><span class="line">        gcc -o test <span class="variable">$^</span></span><br><span class="line">%.o : %.c</span><br><span class="line">        gcc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">clean :</span><br><span class="line">		rm *.o </span><br><span class="line">.PHONY : clean</span><br></pre></td></tr></table></figure>
<ul>
<li><code>%.o : %.c</code>：匹配模式规则
<ul>
<li><code>%</code>通配符用于匹配模式规则中的字符序列</li>
<li><code>*</code>通配符用于匹配文件名</li>
</ul></li>
<li><code>$@</code>：表示目标</li>
<li><code>$&lt;</code>：表示第一个依赖文件</li>
<li><code>$^</code>：表示所有依赖文件</li>
<li><code>.PHONY</code>：声明clean为假想目标，防止目录下存在clean文件而导致命令不执行</li>
</ul>
<h4 id="变量">2.2.3 变量</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A := xxx   //即时变量，在定义时即确定</span><br><span class="line">B = xxx    //延时变量，在使用时才确定</span><br><span class="line">C ?= xxx   //延时变量，如果是第一次定义才起效，如果前面该变量已经定义，则忽略此句</span><br><span class="line">C += xxx   //附加变量，是即时还是延时变量取决于前面的定义</span><br></pre></td></tr></table></figure>
<ul>
<li><p>举例</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">A := $&#123;C&#125;</span><br><span class="line">B = $&#123;C&#125;</span><br><span class="line"><span class="section">all: </span></span><br><span class="line">	@echo $&#123;A&#125;</span><br><span class="line">	@echo $&#123;B&#125;</span><br><span class="line">C ?= abc</span><br><span class="line">C += 123</span><br></pre></td></tr></table></figure>
<p>A是即时变量，在定义时C还未定义，所有A的值为空；B是延时变量，在使用时C已经定义，B的值为<code>abc 123</code></p></li>
</ul>
<h4 id="常用函数">2.2.4 常用函数</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> var, list, text)</span>       <span class="comment"># 遍历list的元素var，对于var生成text的格式</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> pattern..., text)</span>       <span class="comment"># 在text中取出符合patten格式的值</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out pattern..., txt)</span>    <span class="comment"># 在text中取出不符合patten格式的值</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> pattern)</span>              <span class="comment"># pattern定义了文件名的格式，wildcard取出其中存在的文件</span></span><br><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern, replacement, <span class="variable">$(var)</span>)</span> <span class="comment">#对变量var中符合pattern格式的值，替换为repl格式</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>举例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">A = a b c</span><br><span class="line">B = <span class="variable">$(<span class="built_in">foreach</span> f, <span class="variable">$(A)</span>, <span class="variable">$(f)</span>.o)</span></span><br><span class="line"></span><br><span class="line">C = a b c d/</span><br><span class="line">D = <span class="variable">$(<span class="built_in">filter</span> %/, <span class="variable">$(C)</span>)</span></span><br><span class="line">E = <span class="variable">$(<span class="built_in">filter</span>-out %/, <span class="variable">$(C)</span>)</span></span><br><span class="line"></span><br><span class="line">file1 = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span>             <span class="comment"># 从当前目录下取出符合格式的文件名</span></span><br><span class="line">file_name = a.c b.c d.c e.c abc</span><br><span class="line">file2 = <span class="variable">$(<span class="built_in">wildcard</span>  <span class="variable">$(file_name)</span>)</span>   <span class="comment"># 判断file_name中的文件在当前目录下是否存在</span></span><br><span class="line">dep_files = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.d, <span class="variable">$(file_name)</span>)</span></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">        @echo B = <span class="variable">$(B)</span></span><br><span class="line">        @echo D = <span class="variable">$(D)</span></span><br><span class="line">        @echo E = <span class="variable">$(E)</span></span><br><span class="line">        @echo file1 = <span class="variable">$(file1)</span></span><br><span class="line">        @echo file2 = <span class="variable">$(file2)</span></span><br><span class="line">        @echo dep_files = <span class="variable">$(dep_files)</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B = a.o b.o c.o</span><br><span class="line">D = d/</span><br><span class="line">E = a b c</span><br><span class="line">file1 = a.c c.c b.c</span><br><span class="line">file2 = a.c b.c</span><br><span class="line">dep_files = a.d b.d d.d e.d abc</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="判断语句">2.2.5 判断语句</h4>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (condition1, condition2)</span><br><span class="line">  <span class="comment"># 代码块</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># 代码块</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<h4 id="考虑头文件">2.2.6 考虑头文件</h4>
<p>假设c.c文件包含了头文件c.h，并引用了其中的宏定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//c.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C <span class="string">&#x27;C&#x27;</span></span></span><br><span class="line"><span class="comment">//c.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;c.h&quot;</span>  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func_c</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is func %c!\n&quot;</span>, C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Makefile仅在目标文件不存在或者依赖文件更新时才执行目录，所以如果在编译完成之后，再修改.h文件，则使用原来的Makefile不会更新所引用的宏，因此需要在Makefile中考虑头文件</p>
<h5 id="使用gcc命令生成头文件依赖">使用gcc命令生成头文件依赖</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -M c.c                          // 打印出头文件依赖</span><br><span class="line">gcc -M -MF c.d c.c                  // 把依赖写入文件c.d</span><br><span class="line">gcc -c -o c.o c.c -MD -MF c.d       // 编译c.c文件，同时把依赖写入文件c.d</span><br></pre></td></tr></table></figure>
<h5 id="修改makefile">修改Makefile</h5>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objs = a.o b.o c.o</span><br><span class="line"></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">patsubst</span> %, .%.d, <span class="variable">$(objs)</span>)</span>   <span class="comment"># 修改文件名的格式</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dep_files)</span>)</span>       <span class="comment"># 找出当前目录所包含的文件</span></span><br><span class="line">CFLAGS = -Werror -Iinclude</span><br><span class="line"></span><br><span class="line"><span class="section">test: <span class="variable">$(objs)</span></span></span><br><span class="line">        gcc -o test <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(dep_files)</span>, )                      <span class="comment"># 判断dep_files是否为空</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(dep_files)</span>                        <span class="comment"># 不空说明不是首次编译，则包含头文件依赖</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">        gcc <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span> -MD -MF .<span class="variable">$@</span>.d</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm *.o test</span><br><span class="line"><span class="section">dep_clean:</span></span><br><span class="line">        rm <span class="variable">$(dep_files)</span></span><br><span class="line">.PHONY : clean dep_clean</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用该Makefile，在首次编译之后，修改c.h文件，再一次执行Makefile：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -o c.o c.c -MD -MF .c.o.d</span><br><span class="line">gcc -o test a.o b.o c.o</span><br></pre></td></tr></table></figure>
<p>包含头文件依赖，发现头文件c.h发生改变，所以重新编译c.c文件，最后重新链接生成可执行文件</p></li>
<li><p><code>CFLAGS = -Werror -Iinclude</code>：为gcc增加编译选项</p>
<ul>
<li><code>-Werror</code>：将警告视为错误</li>
<li><code>-Iinclude</code>：在当前目录的include目录下搜索头文件</li>
</ul></li>
</ul>
<h3 id="通用makefile模板">2.3 通用Makefile模板</h3>
<p>主目录下Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定编译工具链的前缀</span></span><br><span class="line">CROSS_COMPILE = </span><br><span class="line">AS		= <span class="variable">$(CROSS_COMPILE)</span>as</span><br><span class="line">LD		= <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">CC		= <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">CPP		= <span class="variable">$(CC)</span> -E</span><br><span class="line">AR		= <span class="variable">$(CROSS_COMPILE)</span>ar</span><br><span class="line">NM		= <span class="variable">$(CROSS_COMPILE)</span>nm</span><br><span class="line"></span><br><span class="line">STRIP		= <span class="variable">$(CROSS_COMPILE)</span>strip</span><br><span class="line">OBJCOPY		= <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">OBJDUMP		= <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> AS LD CC CPP AR NM</span><br><span class="line"><span class="keyword">export</span> STRIP OBJCOPY OBJDUMP</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定所有源文件的编译选项</span></span><br><span class="line">CFLAGS := -Wall -O2 -g</span><br><span class="line">CFLAGS += -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/<span class="keyword">include</span></span><br><span class="line"><span class="comment"># 指定所有.o文件的链接选项</span></span><br><span class="line">LDFLAGS := </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> CFLAGS LDFLAGS</span><br><span class="line"></span><br><span class="line">TOPDIR := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="keyword">export</span> TOPDIR</span><br><span class="line"><span class="comment"># 指定可执行文件的名称</span></span><br><span class="line">TARGET := test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定需要编译的源文件和目录</span></span><br><span class="line">obj-y += main.o</span><br><span class="line">obj-y += sub.o</span><br><span class="line">obj-y += a/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all : start_recursive_build <span class="variable">$(TARGET)</span></span><br><span class="line">	@echo <span class="variable">$(TARGET)</span> has been built!</span><br><span class="line"></span><br><span class="line"><span class="section">start_recursive_build:</span></span><br><span class="line">	make -C ./ -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span> : start_recursive_build</span><br><span class="line">	<span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> built-in.o <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="section">distclean:</span></span><br><span class="line">	rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">	rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.d&quot;)</span></span><br><span class="line">	rm -f <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>主目录下Makefile.build：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">PHONY := __build</span><br><span class="line"><span class="section">__build:</span></span><br><span class="line"></span><br><span class="line">obj-y :=</span><br><span class="line">subdir-y :=</span><br><span class="line">EXTRA_CFLAGS :=</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> Makefile</span><br><span class="line"></span><br><span class="line"><span class="comment"># obj-y := a.o b.o c/ d/</span></span><br><span class="line"><span class="comment"># $(filter %/, $(obj-y))   : c/ d/</span></span><br><span class="line"><span class="comment"># __subdir-y  : c d</span></span><br><span class="line"><span class="comment"># subdir-y    : c d</span></span><br><span class="line">__subdir-y	:= <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">filter</span> %/, $(obj-y)</span>))</span><br><span class="line">subdir-y	+= $(__subdir-y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># c/built-in.o d/built-in.o</span></span><br><span class="line">subdir_objs := <span class="variable">$(<span class="built_in">foreach</span> f,$(subdir-y)</span>,<span class="variable">$(f)</span>/built-in.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># a.o b.o</span></span><br><span class="line">cur_objs := <span class="variable">$(<span class="built_in">filter</span>-out %/, $(obj-y)</span>)</span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(cur_objs)</span>,.<span class="variable">$(f)</span>.d)</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dep_files)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(dep_files)</span>,)</span><br><span class="line">  <span class="keyword">include</span> <span class="variable">$(dep_files)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">PHONY += $(subdir-y)</span><br><span class="line"></span><br><span class="line">__build : $(subdir-y) built-in.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于子目录使用最顶层的Makefile.build</span></span><br><span class="line"><span class="section">$(subdir-y):</span></span><br><span class="line">	make -C <span class="variable">$@</span> -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br><span class="line"></span><br><span class="line">built-in.o : $(subdir-y) <span class="variable">$(cur_objs)</span></span><br><span class="line">	<span class="variable">$(LD)</span> -r -o <span class="variable">$@</span> <span class="variable">$(cur_objs)</span> <span class="variable">$(subdir_objs)</span></span><br><span class="line"></span><br><span class="line">dep_file = .<span class="variable">$@</span>.d</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(EXTRA_CFLAGS)</span> $(CFLAGS_<span class="variable">$@</span>) -Wp,-MD,<span class="variable">$(dep_file)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">	</span><br><span class="line">.PHONY : <span class="variable">$(PHONY)</span></span><br></pre></td></tr></table></figure>
<p>子目录下Makefile示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定子目录中文件的编译选项</span></span><br><span class="line">EXTRA_CFLAGS := -D DEBUG</span><br><span class="line"><span class="comment"># 为具体文件指定额外的编译选项</span></span><br><span class="line">CFLAGS_sub3.o := -D DEBUG_SUB3</span><br><span class="line"></span><br><span class="line">obj-y += sub2.o </span><br><span class="line">obj-y += sub3.o </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Unix-Linux编程实践教程-章节3笔记</title>
    <url>/2023/09/12/Unix-Linux%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E6%95%99%E7%A8%8B-%E7%AB%A0%E8%8A%823%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="ls">ls</h2>
<p>编写ls命令</p>
<ul>
<li>列出目录的内容</li>
<li>读取并显示文件的属性</li>
<li>给出名字，判断它是目录还是文件</li>
</ul>
<h3 id="目录">目录</h3>
<ul>
<li>目录是一种特殊的文件，它的内容一条条记录，每一个记录代表一个文件或者目录</li>
<li>目录文件永远不空，至少包含两个特殊项"."或者".."</li>
</ul>
<h3 id="操作目录的相关函数">操作目录的相关函数</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;dirent.h&gt;</span><br><span class="line"></span><br><span class="line">DIR *opendir(const char *name);</span><br><span class="line">struct dirent *readdir(DIR *dirp);</span><br><span class="line">int closedir(DIR *dirp);</span><br><span class="line"></span><br><span class="line">// 目录属性</span><br><span class="line">struct dirent &#123;</span><br><span class="line">    ino_t          d_ino;       /* Inode number */</span><br><span class="line">    off_t          d_off;       /* Not an offset; see below */</span><br><span class="line">    unsigned short d_reclen;    /* Length of this record */</span><br><span class="line">    unsigned char  d_type;      /* Type of file; not supported</span><br><span class="line">                                    by all filesystem types */</span><br><span class="line">    char           d_name[256]; /* Null-terminated filename */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>opendir</code>返回值：成功返回一个目录流，失败返回NULL，同时errno设置为相应值</p></li>
<li><p><code>readdir</code>返回值：成功返回对应结构体的指针(该结构体被静态分配，不要使用free()释放)；发生错误时返回NULL，同时errno会被相应设置；如果到达目录流的末尾，也会返回NULL(errno提前设置为0，不会发生改变)</p></li>
<li><p><code>closedir</code>返回值：0表示成功，-1表示发生错误</p></li>
<li><p>d_type参数：</p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DT_BLK      This is a block device.</span><br><span class="line">DT_CHR      This is a character device.</span><br><span class="line">DT_DIR      This is a directory.</span><br><span class="line">DT_FIFO     This is a named pipe (FIFO).</span><br><span class="line">DT_LNK      This is a symbolic link.</span><br><span class="line">DT_REG      This is a regular file.</span><br><span class="line">DT_SOCK     This is a UNIX domain socket.</span><br><span class="line">DT_UNKNOWN  The file type could not be determined.</span><br></pre></td></tr></table></figure>
<h3 id="编写ls--l">编写ls -l</h3>
<p>编写该命令，既需要读取目录文件，也需要根据目录文件中的名称来获取对应的文件信息</p>
<p><code>ls -l</code>显示示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-rw-r-- 1 zhaoyan zhaoyan 1497 11月 12 14:08 a.txt</span><br><span class="line">drwxrwxr-x 3 zhaoyan zhaoyan 4096 10月  9 18:39 C</span><br></pre></td></tr></table></figure>
<ul>
<li>模式(mode):首位表示文件类型
<ul>
<li><code>-</code>：普通文件</li>
<li><code>d</code>：目录</li>
<li><code>c</code>：字符设备文件</li>
<li><code>b</code>：块设备文件</li>
<li><code>l</code>：符号链接文件(Symbolic Links)</li>
<li><code>s</code>：套接字文件</li>
<li><code>p</code>：管道文件</li>
</ul></li>
<li>链接数(links):指该文件被引用的次数</li>
<li>文件所有者(owner):</li>
<li>组(group):文件所有者所在的组</li>
<li>大小(size):显示文件的大小，单位是字节，目录所占空间是以块(每块512字节)为单位进行分配的，所以目录的大小经常是相等的</li>
<li>最后修改时间(last-modified)</li>
<li>文件名(name)</li>
</ul>
<h4 id="stat函数">stat()函数</h4>
<p>进程定义一个<code>struct stat</code>，然后调用stat函数，让内核将文件属性放入这个数据结构中（之前目录结构体dirent是直接返回指针，为什么有这样的区别？）</p>
<p>该函数返回关于一个文件的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int stat(const char *pathname, struct stat *statbuf);</span><br><span class="line"></span><br><span class="line">// 文件属性</span><br><span class="line">struct stat &#123;</span><br><span class="line">    dev_t     st_dev;         /* ID of device containing file */</span><br><span class="line">    ino_t     st_ino;         /* Inode number */ 索引编号</span><br><span class="line">    mode_t    st_mode;        /* File type and mode */</span><br><span class="line">    nlink_t   st_nlink;       /* Number of hard links */</span><br><span class="line">    uid_t     st_uid;         /* User ID of owner */</span><br><span class="line">    gid_t     st_gid;         /* Group ID of owner */</span><br><span class="line">    dev_t     st_rdev;        /* Device ID (if special file) */</span><br><span class="line">    off_t     st_size;        /* Total size, in bytes */</span><br><span class="line">    blksize_t st_blksize;     /* Block size for filesystem I/O */</span><br><span class="line">    blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */</span><br><span class="line"></span><br><span class="line">    /* Since Linux 2.6, the kernel supports nanosecond</span><br><span class="line">        precision for the following timestamp fields.</span><br><span class="line">        For the details before Linux 2.6, see NOTES. */</span><br><span class="line"></span><br><span class="line">    struct timespec st_atim;  /* Time of last access */</span><br><span class="line">    struct timespec st_mtim;  /* Time of last modification */</span><br><span class="line">    struct timespec st_ctim;  /* Time of last status change */</span><br><span class="line"></span><br><span class="line">#define st_atime st_atim.tv_sec      /* Backward compatibility */</span><br><span class="line">#define st_mtime st_mtim.tv_sec</span><br><span class="line">#define st_ctime st_ctim.tv_sec</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//检查文件类型</span><br><span class="line">#define	__S_ISTYPE(mode, mask)	(((mode) &amp; __S_IFMT) == (mask))</span><br><span class="line"></span><br><span class="line">#define	S_ISDIR(mode)	 __S_ISTYPE((mode), __S_IFDIR)  //目录</span><br><span class="line">#define	S_ISCHR(mode)	 __S_ISTYPE((mode), __S_IFCHR)  //字符特殊设备</span><br><span class="line">#define	S_ISBLK(mode)	 __S_ISTYPE((mode), __S_IFBLK)  //块特殊设备</span><br><span class="line">#define	S_ISREG(mode)	 __S_ISTYPE((mode), __S_IFREG)  //普通文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define	S_IRUSR	__S_IREAD	/* Read by owner.  */</span><br><span class="line">#define	S_IWUSR	__S_IWRITE	/* Write by owner.  */</span><br><span class="line">#define	S_IXUSR	__S_IEXEC	/* Execute by owner.  */</span><br><span class="line">#define	S_IRGRP	(S_IRUSR &gt;&gt; 3)	/* Read by group.  */</span><br><span class="line">#define	S_IWGRP	(S_IWUSR &gt;&gt; 3)	/* Write by group.  */</span><br><span class="line">#define	S_IXGRP	(S_IXUSR &gt;&gt; 3)	/* Execute by group.  */</span><br><span class="line">#define	S_IROTH	(S_IRGRP &gt;&gt; 3)	/* Read by others.  */</span><br><span class="line">#define	S_IWOTH	(S_IWGRP &gt;&gt; 3)	/* Write by others.  */</span><br><span class="line">#define	S_IXOTH	(S_IXGRP &gt;&gt; 3)	/* Execute by others.  */</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：如果成功返回0，否则返回-1，并且<code>error</code>会设置为相应的错误类型</li>
</ul>
<h4 id="如何显示st_mode">如何显示st_mode</h4>
<ul>
<li>st_mode是一个16位的二进制数，文件类型和权限被编码在这个数中
<ul>
<li>高四位：文件类型，最多可以标识16种</li>
<li>中间3位：文件的特殊属性，1表示有，0表示没有。这三位分别是<code>set-user-ID</code>,<code>set-group-ID</code>和<code>sticky</code></li>
<li>最后9位是许可权限，分别对应3种用户（文件所有者，同组用户，其他用户）</li>
</ul></li>
<li>所以，只需要通过stat.h文件提供的掩码即可获得</li>
</ul>
<h4 id="根据用户组id寻找name">根据用户/组ID寻找name</h4>
<h5 id="etcpasswd文件">/etc/passwd文件</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zhaoyan:x:1000:1000:zhaoyan,,,:/home/zhaoyan:/bin/bash</span><br></pre></td></tr></table></figure>
<ul>
<li>该文件中每一行代表一个用户，冒号分割不同的字段。</li>
<li>每一个字段依次为：用户名、密码、用户ID、用户所属组ID、用户的全名、主目录、用户使用shell程序的路径</li>
<li>该文件并没有包括所有的用户。在分布式系统中，通常在一台所有人都能访问的主机上保存所有的用户信息，该主机称为NIS，所有的主机通过NIS进行用户身份验证。所有需要用户信息的程序也从NIS上获取。本地只保存所有用户的一个子集以备离线操作。</li>
</ul>
<h5
id="通过getpwuid得到完整的用户列表">通过getpwuid得到完整的用户列表</h5>
<p>通过库函数getpwuid来访问用户信息(从/etc/passwd或者NIS中获取)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;pwd.h&gt;</span><br><span class="line">struct passwd *getpwuid(uid_t uid);</span><br><span class="line"></span><br><span class="line">struct passwd &#123;</span><br><span class="line">    char   *pw_name;       /* username */</span><br><span class="line">    char   *pw_passwd;     /* user password */</span><br><span class="line">    uid_t   pw_uid;        /* user ID */</span><br><span class="line">    gid_t   pw_gid;        /* group ID */</span><br><span class="line">    char   *pw_gecos;      /* user information */</span><br><span class="line">    char   *pw_dir;        /* home directory */</span><br><span class="line">    char   *pw_shell;      /* shell program */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：成功返回结构体指针，发生错误或者查询为空返回NULL。调用之前请将errno置为0</li>
</ul>
<h5 id="etcgroup文件">/etc/group文件</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zhaoyan:x:1000:</span><br></pre></td></tr></table></figure>
<ul>
<li><p>每一个字段依次为组名，组密码，组ID，组中的成员列表</p></li>
<li><p>passwd文件中每个用户所属的组，是用户的主组(primary
group)。用户还可以是其他组的成员，只需要把它的用户名添加到<code>/etc/group</code>中这个组所在行的最后一个字段即可。</p></li>
</ul>
<h5 id="通过getgrgid访问组列表">通过getgrgid访问组列表</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;grp.h&gt;</span><br><span class="line"></span><br><span class="line">struct group *getgrgid(gid_t gid);</span><br><span class="line"></span><br><span class="line">struct group &#123;</span><br><span class="line">    char   *gr_name;        /* group name */</span><br><span class="line">    char   *gr_passwd;      /* group password */</span><br><span class="line">    gid_t   gr_gid;         /* group ID */</span><br><span class="line">    char  **gr_mem;         /* NULL-terminated array of pointers</span><br><span class="line">                                to names of group members */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：成功返回结构体指针，发生错误或者查询为空返回NULL。调用之前请将errno置为0</li>
</ul>
<h3 id="详解st_mode中三个特殊位">详解st_mode中三个特殊位</h3>
<h4 id="set-user-id位">set-user-ID位</h4>
<p>普通用户可以通过<code>passwd</code>来修改密码，用户密码存放在<code>/etc/passwd</code>中，但是可以看到普通用户并没有权限来修改该文件。
所以<code>passwd</code>命令有一个特殊权限<code>s</code>，使得其特殊属性包含set-user-ID位。<strong>SUID位告诉内核，运行这个程序时认为时由该文件所有者在运行这个程序</strong>，在这里是root，而root有权限修改<code>/etc/passwd</code>文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-rw-r--r-- 1 root root 2862 10月  9 17:55 /etc/passwd</span><br><span class="line">-rwsr-xr-x 1 root root 59976  3月 14  2022 /usr/bin/passwd</span><br></pre></td></tr></table></figure>
<p><strong>对于一些所有用户共享的文件，普通用户只能以受限方式进行修改，那么就将该文件的所有者设置为root,同时受限命令的所有者添加's'权限</strong></p>
<h4 id="set-group-id位">set-group-ID位</h4>
<p>类似于SUID，如果SGID置位，那么程序运行时认为是由该文件所属组中的某一个用户运行</p>
<h4 id="sticky位">sticky位</h4>
<ul>
<li>对于文件，使用交换(swap)技术会用到该位。现在已经被虚拟内存技术所取代</li>
<li>对于目录，例如用来存放临时文件的<code>/tmp</code>，每一个用户都可以在该目录中创建/删除文件，sticky位使得该目录中的文件只能被创建者删除</li>
</ul>
<h4 id="特殊属性标识">特殊属性标识</h4>
<p><strong>许可权限位上所有者的s表示set-user-ID，组用户的s表示set-group-ID；其他组的t表示sticky被设置</strong></p>
<hr />
<h2 id="设置和修改文件的属性">设置和修改文件的属性</h2>
<h3 id="文件类型">文件类型</h3>
<ul>
<li>文件类型有普通文件、目录文件、设备文件、socket文件、符号链接文件、命名管道(named
pipe)文件等。</li>
<li>文件类型是在创建文件时设置的，不同的系统调用创建不同类型的文件(如creat创建一个普通文件)</li>
<li>文件已经创建，其类型就无法修改了</li>
</ul>
<h3 id="许可位和特殊属性位">许可位和特殊属性位</h3>
<p>每个文件都有9位许可权限和3位特殊属性。它们可以被chmod系统调用修改</p>
<h4 id="建立文件的模式">建立文件的模式</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fd = creat(&quot;newfile&quot; , 0744);</span><br></pre></td></tr></table></figure>
<p>上述参数只是请求。<strong>程序请求的许可权限还会与上"新建文件掩码"(file-creation-mask)来得到文件的最终模式</strong>。新建文件掩码<code>umask</code>是一个非常有用的系统变量。例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(&quot;a.txt&quot; , O_RDWR | O_CREAT, 0777);</span><br><span class="line"></span><br><span class="line">-rwxrwxr-x 1 zhaoyan zhaoyan     0 11月 14 20:02 a.txt</span><br><span class="line"></span><br><span class="line">&gt;umask -S</span><br><span class="line">u=rwx,g=rwx,o=rx</span><br></pre></td></tr></table></figure>
<p>可以看到open函数所要求的文件权限<code>0777</code>并没有得到满足，正好是和umask相与之后的结果。</p>
<h4 id="改变文件的模式">改变文件的模式</h4>
<p>使用系统调用chmod，该命令不会收到umask影响，文件许可和特殊属性都可以通过其进行修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">int chmod(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">//mode:建议使用&lt;sys/stat.h&gt;中定义的符号表示，程序可移植性高</span><br><span class="line">chmod(&quot;a.txt&quot; , 04764);  // 100 111 110 100</span><br><span class="line">chmod(&quot;a.txt&quot; , S_ISUID|S_IRWXU|S_IRGRP|S_IWGRP|S_IROTH);</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：成功则返回0，发生错误返回-1</li>
</ul>
<h3 id="文件的链接数">文件的链接数</h3>
<p>链接数就是文件被引用的次数(别名的数量)。
增加文件的别名(使用link)使链接数增加，减少别名(unlink)使得链接数减少。</p>
<h3 id="文件所有者与组">文件所有者与组</h3>
<ul>
<li><p>文件所有者就是创建该文件的用户。如果通过程序创建一个文件，且程序具有SUID位，那么新文件的所有者就是程序文件的所有者</p></li>
<li><p>通常，新文件组和创建者的组一致。有些情况下，组会被设置为和父目录的组相同。</p></li>
</ul>
<h4 id="修改文件所有者和组">修改文件所有者和组</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int chown(const char *pathname, uid_t owner, gid_t group);</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：成功则返回0，失败则返回-1</li>
</ul>
<p>或者通过Shell命令<code>chown</code>和<code>chgrp</code>也可以修改文件所有者和组</p>
<h3 id="文件大小">文件大小</h3>
<p>不存在能够直接减小文件占用空间的函数</p>
<h3 id="时间">时间</h3>
<p>每一个文件都有3个时间：最后修改(modification)时间、最后访问(access)时间和属性最后修改时间。</p>
<h4 id="修改最后修改和访问时间">修改最后修改和访问时间</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;utime.h&gt;</span><br><span class="line">int utime(const char *filename, const struct utimbuf *times);</span><br><span class="line"></span><br><span class="line">struct utimbuf &#123;</span><br><span class="line">    time_t actime;       /* access time */</span><br><span class="line">    time_t modtime;      /* modification time */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：成功返回0，发生错误返回-1</li>
<li>使用Shell命令<code>touch</code>也可以修改这两个时间</li>
</ul>
<h3 id="文件名">文件名</h3>
<p>使用系统调用<code>rename</code>可以修改文件/目录的名字，还可以移动文件的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int rename(const char *oldpath, const char *newpath);</span><br></pre></td></tr></table></figure>
<ul>
<li>返回值：成功返回0，遇到错误返回-1</li>
</ul>
<h2 id="编程练习">编程练习</h2>
<h3 id="ls的完善1">ls的完善1</h3>
<p>1.为ls02添加支持<code>./ls02 /tmp</code>的功能 -
原始不能支持该功能，因为在使用<code>stat()</code>寻找文件信息时，默认在当前目录下寻找，所以找不到指定目录下的文件信息
- 修改：对于指定目录下的文件，拼接出绝对路径就好了 -
<code>strcpy(s1,s2)</code>:字符串拷贝，直接将s2拷贝到s1串的起始位置 -
<code>strcat(s1,s2)</code>：字符串拼接，先寻找s1串的'\0'字符，然后从该位置开始拼接</p>
<h3 id="ls的完善2">ls的完善2</h3>
<p>在文件<code>ls01.c</code>中实现了ls对-a
-l的支持，同时支持排序，分栏显示，颜色显示</p>
<h4 id="分栏显示">分栏显示</h4>
<p>系统的ls支持： 1.按序显示
2.按照排序规则按列从上往下显示，当前列显示完成后转到下一列继续显示
3.每一列都是左对齐的 4.每一列的宽度都是该列最长文件名长度加2
5.列的数目要尽量保证每一行都被文件名“填充满”，而又不会导致行中最后一个文件名换行</p>
<h5 id="实现">实现</h5>
<p>1.查询屏幕宽度，使用<code>ioctl</code>系统调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct winsize size;</span><br><span class="line">ioctl(STDIN_FILENO,TIOCGWINSZ,&amp;size);  //获取设备参数</span><br><span class="line">int screen_len = size.ws_col;</span><br></pre></td></tr></table></figure>
<p>2.统计所有filename的总长度，然后除以屏幕宽度，从而得到一个基础行数
3.根据行数计算列数，然后求每一列的宽度(该列中最长的filename，用col_len表示)，以及这个最长的filename在第几行(用col_idx表示)。如果所有列总长小于屏幕宽，结束输出行数。否则转4
4.想要减小列总长，只要两列的最大filename能够移动到同一列，则总列长大概率能够缩小(除非一列中最长的filename有多个)，所以按照这个思路，只需要第一次满足<code>i*add_row_num &gt;= col_idx</code>即可求得增加的行数，然后转3.</p>
<h4 id="排序">排序</h4>
<p>自己实现了快排，具体实现中指针的使用还需要学习</p>
<h4 id="颜色显示">颜色显示</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man dircolors</span><br><span class="line">dircolors -p &gt; color</span><br><span class="line">vim color</span><br></pre></td></tr></table></figure>
<ul>
<li>这样在<code>color</code>文件中即可找到每种类型的文件的默认颜色值</li>
<li><a
href="https://blog.csdn.net/judgejames/article/details/82735738">printf打印颜色</a></li>
</ul>
<h4 id="教训找了2小时的bug">教训(找了2小时的BUG)</h4>
<p>C语言指针、数组、二维、内存分配其乐无穷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//改进之前</span><br><span class="line">char *filenames[4096];</span><br><span class="line">filenames[file_cnt++] = direntp-&gt;d_name;</span><br><span class="line"></span><br><span class="line">struct dirent *readdir(DIR *dirp);</span><br><span class="line"></span><br><span class="line">//改进之后</span><br><span class="line">char *filenames[4096];</span><br><span class="line">char *filename = (char *)malloc(sizeof(char)*256);</span><br><span class="line">strcpy(filename , direntp-&gt;d_name);</span><br><span class="line">filenames[file_cnt++] = filename;</span><br><span class="line">for(int i = 0; i &lt; file_cnt; i++)</span><br><span class="line">    free(filenames[i]);</span><br></pre></td></tr></table></figure>
<ul>
<li>！！问题：在调用<code>getpwuid</code>,<code>getgrgid</code>等函数之后，发现filename[i]中的值神奇的改变了，明明这些系统调用不需要传入filename的。在改进之后问题就消失了。</li>
<li>猜测：改进之前，name的内存是系统调用分配的，然后在使用其他系统调用，这些内存区被改变了？</li>
<li>启示：
1.如果需要持久化系统调用给的内存，最好自己动态内存分配，在copy过来。
2.学习这种分配字符串数组的方式</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li><p><a
href="https://blog.csdn.net/liitdar/article/details/80972088">C/C++编程语言中char**
a和char* a[]的区别</a></p></li>
<li><p><a
href="https://blog.csdn.net/zzyzgg/article/details/89483189">(<em>a)[]与</em>a[]的区别</a></p></li>
<li><p><a
href="https://www.cnblogs.com/lularible/p/14395705.html">ls命令优化版和ls
-l实现</a></p></li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《Unix-Linux编程实践教程》</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>mmap</title>
    <url>/2024/01/12/mmap/</url>
    <content><![CDATA[<h2 id="为什么要使用-mmap">1. 为什么要使用 mmap</h2>
<p>应用程序和驱动程序之间传递数据时，可以通过 read、write
函数进行，如下图：</p>
<figure>
<img src="../images/mmap/image-20240112114136049.png"
alt="image-20240112114136049" />
<figcaption aria-hidden="true">image-20240112114136049</figcaption>
</figure>
<p>应用程序不能直接读写驱动程序中的 buffer，需要在用户态 buffer 和内核态
buffer 之间进行一次数据拷贝。这种方式在数据量比较小时没什么问题；
但是数据量比较大时效率太低。例如更新 LCD，假设 LCD 采用
<code>1024 × 600 × 32 bpp</code> 的格式，则一帧数据就有 2.3
M左右，拷贝的步骤效率太低。</p>
<p>应该允许程序直接读写驱动程序中的 buffer，这可以通过 mmap 实现(memory
map)，把内核的 buffer 映射到用户态，让 APP 在用户态直接读写。</p>
<h2 id="虚拟地址和物理地址">2. 虚拟地址和物理地址</h2>
<p>编写一个测试程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;number&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a&#x27;s address = 0x%lx, a&#x27;s value = %d\n&quot;</span>, (<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>)&amp;a, a);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果如下：</p>
<figure>
<img src="../images/mmap/image-20240112151412038.png"
alt="image-20240112151412038" />
<figcaption aria-hidden="true">image-20240112151412038</figcaption>
</figure>
<p>两次运行分别产生了两个进程，打印出来的都是<strong>各自进程内变量的虚拟地址</strong>。使用<code>cat /proc/进程PID/maps</code>：可以查看进程内划分的不同虚拟内存区域：</p>
<figure>
<img src="../images/mmap/image-20240112151746736.png"
alt="image-20240112151746736" />
<figcaption aria-hidden="true">image-20240112151746736</figcaption>
</figure>
<p>例如第一行是代码段，第二行是只读数据段（data段，存放初始化的全局变量和静态变量），第三行是可读写数据段（bss段，存放的是未初始化的全局变量和静态变量）。</p>
<h3 id="虚拟地址转换物理地址">2.1 虚拟地址转换物理地址</h3>
<p>CPU 发出的地址是虚拟地址 ，它经过 MMU(Memory Manage
Unit，内存管理单元)映射到物理地址上，对于不同进程的同一个虚拟地址，MMU
会把它们映射到不同的物理地址。如下图：</p>
<figure>
<img src="../images/mmap/image-20240112153131551.png"
alt="image-20240112153131551" />
<figcaption aria-hidden="true">image-20240112153131551</figcaption>
</figure>
<p>每一个进程在内核里都有一个
tast_struct，这个结构体中保存有内存信息：mm_struct。而虚拟地址、物理地址的映射关系保存在页目录表中，如下图所示：</p>
<figure>
<img src="../images/mmap/image-20240112153334851.png"
alt="image-20240112153334851" />
<figcaption aria-hidden="true">image-20240112153334851</figcaption>
</figure>
<ul>
<li>内存有虚拟地址、物理地址，mm_struct 中用 mmap 来描述虚拟地址，用 pgd
(Page Global Directory)来描述对应的物理地址。</li>
<li>每个进程都有一系列的 VMA：virtual memory；比如代码段、数据段、BSS
段、栈，共享库等等，内核用一系列 vm_area_struct 来表述</li>
<li>vm_area_struct 中的 vm_start、vm_end 是虚拟地址，通过寻址 pgd 转换为
物理地址</li>
</ul>
<h4 id="arm架构内存映射简介">2.1.1 ARM架构内存映射简介</h4>
<p>ARM 架构支持一级页表映射，也就是说 MMU 根据 CPU
发来的虚拟地址可以找到第 1 个页表，从第 1
个页表里就可以知道这个虚拟地址对应的物理地址。<strong>一级页表里地址映射的最小单位是
1M</strong>。</p>
<p>ARM 架构还支持二级页表映射，也就是说 MMU 根据 CPU
发来的虚拟地址先找到第 1 个页表，从第 1 个页表里就可以知道第 2
级页表在哪里；再取出第 2 级页表，从第 2
个页表里才能确定这个虚拟地址对应的物理地址。<strong>二级页表地址映射的最小单位有
4K、1K，Linux 使用 4K。</strong></p>
<p>一级页表项中的内容，决定了它是指向一块物理内存，还是指问二级页表，如下图：</p>
<figure>
<img src="../images/mmap/image-20240112154619471.png"
alt="image-20240112154619471" />
<figcaption aria-hidden="true">image-20240112154619471</figcaption>
</figure>
<p>二级页表项的内容：</p>
<figure>
<img src="../images/mmap/image-20240112160229903.png"
alt="image-20240112160229903" />
<figcaption aria-hidden="true">image-20240112160229903</figcaption>
</figure>
<h5 id="一级页表映射过程">（1）一级页表映射过程</h5>
<p>一级页表中每一个表项用来设置 1M 的空间，对于 32
位的系统，虚拟地址空间有 4G，4G/1M=4096。所以一级页表要映射整个 4G
空间的话，需要 4096 个页表项。</p>
<p>第 0 个页表项用来表示虚拟地址第 0 个 1M(虚拟地址为
0～0xFFFFF)对应哪一块物理内存，并且有一些权限设置；依次类推。</p>
<p>使用一级页表时，先在内存里设置好各个页表项，然后把页表基地址告诉
MMU， 就可以启动 MMU 进行地址映射，如下图：</p>
<figure>
<img src="../images/mmap/image-20240112155507090.png"
alt="image-20240112155507090" />
<figcaption aria-hidden="true">image-20240112155507090</figcaption>
</figure>
<p>使用虚拟地址的 index
部分寻址页表，在页表项中找到该页面的物理基地址，然后将基地址和 offset
拼接就得到了物理地址。</p>
<h5 id="二级页表映射过程">（2） 二级页表映射过程</h5>
<figure>
<img src="../images/mmap/image-20240112160148135.png"
alt="image-20240112160148135" />
<figcaption aria-hidden="true">image-20240112160148135</figcaption>
</figure>
<p>使用 vaddr[31:20]
寻址一级页表，得到二级页表项的物理地址，将二级页表从磁盘中取出放入内存；然后后面的过程与一级页表映射过程类似。</p>
<h2 id="给-app-新建一块内存映射">3. 给 APP 新建一块内存映射</h2>
<h3 id="mmap-调用过程">3.1 mmap 调用过程</h3>
<p>从上面内存映射的过程可以知道，要给 APP
新开劈一块虚拟内存，并且让它指向某块内核 buffer，我们要做这些事：</p>
<ol type="1">
<li>得到一个 vm_area_struct，它表示 APP 的一块虚拟内存空间：APP 调用
mmap 系统函数时 ，内核就帮我们构造了一个 vm_area_stuct
结构体。里面含有虚拟地址的地址范围、权限。</li>
<li>确定物理地址：你想映射某个内核
buffer，你需要得到它的物理地址，这得由驱动程序提供。</li>
<li>给 vm_area_struct 和物理地址建立映射关系</li>
</ol>
<p>APP 里调用 mmap 时，导致的内核相关函数调用过程如下：</p>
<figure>
<img src="../images/mmap/image-20240112161445090.png"
alt="image-20240112161445090" />
<figcaption aria-hidden="true">image-20240112161445090</figcaption>
</figure>
<h3 id="cache-和-buffer">3.2 cache 和 buffer</h3>
<p>使用 mmap 时，需要有 cache、buffer 的知识。下图是 CPU
和内存之间的关系，有 cache、buffer(写缓冲器)。Cache
是一块高速内存；写缓冲器相当于 一个
FIFO，可以把多个写操作集合起来一次写入内存。</p>
<figure>
<img src="../images/mmap/image-20240112161652547.png"
alt="image-20240112161652547" />
<figcaption aria-hidden="true">image-20240112161652547</figcaption>
</figure>
<p>基于局部性原理，为了提高内存数据的读写速度，在内存和CPU之间引入了
cache 。引入 cache 之后读写内存的变化：</p>
<ol type="1">
<li><p>读取内存 addr 处的数据：</p>
<p>先看看 cache 中有没有 addr 的数据，如果有就直接从 cache 里返回
数据，即 cache 命中。否则，从内存里把一个 cache line 大小的数据读入
cache，基于局部性原理 CPU 很可能会再次用到这个 addr
的数据，或是会用到它附近的数据。</p></li>
<li><p>写数据：</p>
<p>CPU 要写数据时，可以直接写内存，这很慢；也可以先把数据写入 cache，
这很快。但是 cache 中的数据终究是要写入内存，有 2 种写策略：</p>
<ul>
<li><strong>写通(write through)</strong>：数据要同时写入 cache
和内存，所以 <strong>cache
和内存中的数据保持一致</strong>。但是写内存很慢，因此可以选择引入写缓冲器，写缓冲器有“写合并”的功能，比如
CPU 执行了 4 条写指令： 写第 0、1、2、3 个字节，每次写 1
字节；写缓冲器会把这 4 个写操作合并成一个写操作：写
word，从而提高了写内存的效率。</li>
<li><strong>写回(write back)</strong>：新数据只是写入
cache，不会立刻写入内存，<strong>cache
和内存中的数据不一致</strong>。新数据写入 cache 时，这一行 cache
被标为“脏”(dirty)；当 cache 不够用时，才需要把脏的数据写入内存。</li>
</ul></li>
</ol>
<p>是否使用 cache、是否使用 buffer，就有 4 种组合，参见
<code>arch\arm\include\asm\pgtable-2level.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> L_PTE_MT_UNCACHED	(_AT(pteval_t, 0x00) &lt;&lt; 2)	<span class="comment">/* 0000 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L_PTE_MT_BUFFERABLE	(_AT(pteval_t, 0x01) &lt;&lt; 2)	<span class="comment">/* 0001 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L_PTE_MT_WRITETHROUGH	(_AT(pteval_t, 0x02) &lt;&lt; 2)	<span class="comment">/* 0010 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L_PTE_MT_WRITEBACK	(_AT(pteval_t, 0x03) &lt;&lt; 2)	<span class="comment">/* 0011 */</span></span></span><br></pre></td></tr></table></figure>
<p>上面 4 种组合对应下表中的各项：</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 16%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th>是否启用 cache</th>
<th>是否启用 buffer</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>否</td>
<td>否</td>
<td>Non-cached, non-buffered (NCNB) 读、写都直达外设硬件</td>
</tr>
<tr class="even">
<td>否</td>
<td>是</td>
<td>Non-cached buffered (NCB) 读、写都直达外设硬件； 写操作通过 buffer
实现，CPU 不等待写操作完成，CPU 会马上执行下一条指令</td>
</tr>
<tr class="odd">
<td>是</td>
<td>否</td>
<td>Cached, write-through mode (WT)，写通策略。不使用
buffer，写会直达外设硬件</td>
</tr>
<tr class="even">
<td>是</td>
<td>是</td>
<td>Cached, write-back mode (WB)，写回策略。写操作通过 buffer
实现，cache hit 时新数据不会到达硬件， 而是在 cahce 中被标为“脏”；cache
miss 时，通过 buffer 写入硬件，CPU 不等待写操作完成，CPU
会马上执行下一条指令</td>
</tr>
</tbody>
</table>
<ul>
<li>第 1 种是不使用 cache 也不使用
buffer，读写时都直达硬件，这适合寄存器的读写。</li>
<li>第 2 种是不使用 cache 但是使用 buffer，写数据时会用 buffer
进行优化，可能会有“写合并”，这适合显存的操作。因为对显存很少有读操作，基本都是写操作，而写操作即使被“合并”也没有关系。</li>
<li>第 3 种是使用 cache 不使用 buffer，就是“write
through”，适用于只读设备：在读数据时用 cache 加速，基本不需要写。</li>
<li>第 4 种是既使用 cache 又使用 buffer，适合一般的内存读写。</li>
</ul>
<h3 id="编写-app-测试程序">3.3 编写 APP 测试程序</h3>
<p>mmap 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>        </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>
<p>各参数的描述如下：</p>
<ul>
<li>addr：指定映射的虚拟内存地址，可以设置为 NULL，让 Linux
内核自动选择合适的虚拟内存地址。</li>
<li>length：映射的长度。</li>
<li>prot：映射内存的保护模式，可选值如下：
<ul>
<li>PROT_EXEC：可以被执行。</li>
<li>PROT_READ：可以被读取。</li>
<li>PROT_WRITE：可以被写入。</li>
<li>PROT_NONE：不可访问。</li>
</ul></li>
<li>flags：指定映射的类型，常用的可选值如下：
<ul>
<li>MAP_SHARED：与其它所有映射到这个文件的进程共享映射空间（可实现共享内存）。</li>
<li>MAP_PRIVATE：建立一个写时复制（Copy on Write）的私有映射空间。</li>
<li>...</li>
</ul></li>
<li>fd：进行映射的文件句柄。</li>
<li>offset：文件偏移量（从文件的何处开始映射），该值必须是
<code>sysconf(_SC_PAGE_SIZE)</code> 函数返回的页面大小的倍数。</li>
</ul>
<p>返回值：</p>
<p>成功时返回映射区域的虚拟地址的指针，失败时返回 MAP_FAILED</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_FAILED	((void *) -1)</span></span><br></pre></td></tr></table></figure>
<p>mumap() 函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>
<p>该系统调用删除指定地址范围的映射，并导致对该范围内地址的进一步引用生成无效的内存引用。进程终止时，区域也会自动取消映射。另一方面，关闭文件描述符并不会取消映射该区域。</p>
<p>返回值：成功返回 0，失败返回 -1</p>
<h4 id="map_shared-和-map_private-的区别">3.3.1 MAP_SHARED 和
MAP_PRIVATE 的区别</h4>
<p>使用 MAP_PRIVATE
映射时，在没有发生写操作时，APP、驱动访问的都是同一块内存； 当 APP
发起写操作时，就会触发“copy on write”，即内核会先创建该内存块的拷贝，APP
的写操作在这个新内存块上进行，<strong>这个新内存块是 APP 私有的，别的
APP、驱动看不到</strong>。</p>
<p>MAP_PRIVATE 映射是很有用的，Linux 中多个 APP 都会使用同一个动态库，
在没有写操作之前大家都使用内存中唯一一份代码。当 APP1
发起写操作时，内核会为它复制一份代码，再执行写操作，<strong>APP1
就有了专享的、私有的动态库，在里面做的修改只会影响到
APP1</strong>。其他程序仍然共享原先的、未修改的代码。</p>
<p>仅用 MAP_SHARED 参数时，<strong>多个
APP、驱动读、写时，操作的都是同一个内存块</strong>，“共享”。</p>
<h4 id="app-代码">3.3.2 APP 代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *buf;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 1. 打开文件 */</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2. mmap */</span></span><br><span class="line">	buf =  mmap(<span class="literal">NULL</span>, <span class="number">1024</span>*<span class="number">8</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (buf == MAP_FAILED)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not mmap file /dev/hello\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mmap address = 0x%x\n&quot;</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;buf origin data = %s\n&quot;</span>, buf); </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3. write */</span></span><br><span class="line">	<span class="built_in">strcpy</span>(buf, <span class="string">&quot;new&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4. read &amp; compare */</span></span><br><span class="line">	read(fd, str, <span class="number">1024</span>);  </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, str) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 对于MAP_SHARED映射，APP写的数据驱动可见</span></span><br><span class="line"><span class="comment">		 * APP和驱动访问的是同一个内存块</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;compare ok!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 对于MAP_PRIVATE映射，APP写数据时, 是写入原来内存块的&quot;拷贝&quot;</span></span><br><span class="line"><span class="comment">		 * 而 read 函数读取的是驱动中分配的原来内存块的数据</span></span><br><span class="line"><span class="comment">		 * 因此，str 和 buf 的数据不同</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;compare err!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str = %s!\n&quot;</span>, str);  <span class="comment">/* old */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;buf = %s!\n&quot;</span>, buf);  <span class="comment">/* new */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">		sleep(<span class="number">10</span>);  </span><br><span class="line">	</span><br><span class="line">	munmap(buf, <span class="number">1024</span>*<span class="number">8</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 APP
后，查看该进程的内存映射信息，可以看到驱动为其分配的内存对应的数据段：</p>
<figure>
<img src="../images/mmap/image-20240112192222526.png"
alt="image-20240112192222526" />
<figcaption aria-hidden="true">image-20240112192222526</figcaption>
</figure>
<h4 id="驱动编程">3.3.3 驱动编程</h4>
<p>在驱动程序中提供 mmap 支持，需要分配一块内存，并在
file_operations.mmap 函数中建立 APP
虚拟地址到这块内存物理地址的映射。</p>
<p>分配内存使用的函数：</p>
<table>
<thead>
<tr class="header">
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>kmalloc</td>
<td>分配到的内存物理地址是连续的</td>
</tr>
<tr class="even">
<td>kzalloc</td>
<td>分配到的内存物理地址是连续的，内容清 0</td>
</tr>
<tr class="odd">
<td>vmalloc</td>
<td>分配到的内存物理地址不保证是连续的</td>
</tr>
<tr class="even">
<td>vzalloc</td>
<td>分配到的内存物理地址不保证是连续的，内容清 0</td>
</tr>
</tbody>
</table>
<p>我们应该使用 kmalloc 或 kzalloc，这样得到的内存物理地址是连续的，在
mmap 时后 APP
才可以使用同一个基地址去访问这块内存。(如果物理地址不连续，就要执行多次
mmap 了)。</p>
<p>在安装内核模块时分配内存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *kernel_buf;</span><br><span class="line">kernel_buf = kmalloc(<span class="number">1024</span>*<span class="number">8</span>, GFP_KERNEL);</span><br><span class="line"><span class="built_in">strcpy</span>(kernel_buf, <span class="string">&quot;old&quot;</span>);  <span class="comment">//做实验用，用来验证对于MAP_PRIVATE映射，写数据时是否会写入新的内存中</span></span><br></pre></td></tr></table></figure>
<p>在卸载模块时释放内存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kfree(kernel_buf);</span><br></pre></td></tr></table></figure>
<p>file_operations.mmap 函数的编写如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获得物理地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> phy = virt_to_phys(kernel_buf);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置属性: cache, buffer */</span></span><br><span class="line">	vma-&gt;vm_page_prot = pgprot_writecombine(vma-&gt;vm_page_prot);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* map */</span></span><br><span class="line">	<span class="keyword">if</span> (remap_pfn_range(vma, vma-&gt;vm_start, phy &gt;&gt; PAGE_SHIFT,</span><br><span class="line">			    vma-&gt;vm_end - vma-&gt;vm_start, vma-&gt;vm_page_prot)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;mmap remap_pfn_range failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>宏 pgprot_writecombine 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __pgprot_modify(prot,mask,bits)		\</span></span><br><span class="line"><span class="meta">	__pgprot((pgprot_val(prot) &amp; ~(mask)) | (bits))</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_writecombine(prot) \</span></span><br><span class="line"><span class="meta">	__pgprot_modify(prot, L_PTE_MT_MASK, L_PTE_MT_BUFFERABLE)</span></span><br></pre></td></tr></table></figure>
<p>设置不使用 cache, 使用 buffer。函数 remap_pfn_range 的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * remap_pfn_range - remap kernel memory to userspace</span></span><br><span class="line"><span class="comment"> * @vma: user vma to map to</span></span><br><span class="line"><span class="comment"> * @addr: target user address to start at</span></span><br><span class="line"><span class="comment"> * @pfn: physical address of kernel memory</span></span><br><span class="line"><span class="comment"> * @size: size of map area</span></span><br><span class="line"><span class="comment"> * @prot: page protection flags for this mapping</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Note: this is only safe if the mm semaphore is held when called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remap_pfn_range</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">		    <span class="type">unsigned</span> <span class="type">long</span> pfn, <span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">pgprot_t</span> prot)</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：pfn 表示 page frame number，因此需要将物理地址
phy 除以页面大小，得到对应的页号，即
<code>phy &gt;&gt; PAGE_SHIFT</code></p>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用LCD屏幕</title>
    <url>/2023/09/12/%E4%BD%BF%E7%94%A8LCD%E5%B1%8F%E5%B9%95/</url>
    <content><![CDATA[<h2 id="lcd操作原理">1. LCD操作原理</h2>
<ol type="1">
<li>驱动程序：Farmebuffer驱动程序设置好LCD控制器：
<ol type="1">
<li>根据 LCD 的参数设置 LCD 控制器的时序、信号极性；</li>
<li>根据 LCD 分辨率、BPP（Bit Per Pixel）分配 Framebuffer。</li>
</ol></li>
<li>应用程序：使用 ioctl 获得 LCD 分辨率、BPP；通过 mmap 映射
Framebuffer，在 Framebuffer 中写入数据</li>
<li>LCD控制器周而复始的从内存中取出LCD屏幕上每一个像素点的显示数据</li>
</ol>
<figure>
<img src="../images/使用LCD屏幕/image-20230912204455923.png"
alt="image-20230912204455923" />
<figcaption aria-hidden="true">image-20230912204455923</figcaption>
</figure>
<p>计算（x,y）坐标处像素对应Framebuffer地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(x，y)像素起始地址 = fb_base + (xres * bpp / 8) * y + x * bpp / 8</span><br></pre></td></tr></table></figure>
<h3 id="像素rgb显示格式">1.1 像素RGB显示格式</h3>
<ul>
<li>32BPP：一般只设置其中的低 24 位，高 8 位表示透明度，一般的 LCD
都不支持。</li>
<li>24BPP“硬件上为了方便处理，在 Framebuffer 中也是用 32 位来表
示，效果跟 32BPP 是一样的。</li>
<li>16BPP：常用的是 <strong>RGB565</strong>；很少的场合会用到
RGB555</li>
</ul>
<figure>
<img src="../images/使用LCD屏幕/image-20230912205546653.png"
alt="image-20230912205546653" />
<figcaption aria-hidden="true">image-20230912205546653</figcaption>
</figure>
<h2 id="编写lcd应用程序">2.编写LCD应用程序</h2>
<p>在LCD屏幕上显示点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd_fb;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">var</span>;</span>	<span class="comment">/* Current var */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> screen_size;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> *fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> line_width;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> pixel_width;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_put_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> color)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *pen_8 = fb_base+y*line_width+x*pixel_width;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> *pen_16;	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *pen_32;	</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> red, green, blue;	</span><br><span class="line"></span><br><span class="line">	pen_16 = (<span class="type">unsigned</span> <span class="type">short</span> *)pen_8;</span><br><span class="line">	pen_32 = (<span class="type">unsigned</span> <span class="type">int</span> *)pen_8;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (var.bits_per_pixel)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			*pen_8 = color;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 565 */</span></span><br><span class="line">			red   = (color &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">			green = (color &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">			blue  = (color &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">			color = ((red &gt;&gt; <span class="number">3</span>) &lt;&lt; <span class="number">11</span>) | ((green &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">5</span>) | (blue &gt;&gt; <span class="number">3</span>);</span><br><span class="line">			*pen_16 = color;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			*pen_32 = color;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t surport %dbpp\n&quot;</span>, var.bits_per_pixel);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	</span><br><span class="line">	fd_fb = open(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd_fb &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open /dev/fb0\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 用来操作底层设备文件参数的系统调用</span></span><br><span class="line">	<span class="comment">// 打开的文件描述符  设备相关请求代码   存放信息的内存指针</span></span><br><span class="line">	<span class="keyword">if</span> (ioctl(fd_fb, FBIOGET_VSCREENINFO, &amp;var))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t get var\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	line_width  = var.xres * var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">	pixel_width = var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">	screen_size = var.xres * var.yres * var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">	<span class="comment">// 从fd_fb文件中0位置映射screen_size到内存中（由内核自动选择起始地址），该内容可读可写并且修改会反映到源文件中</span></span><br><span class="line">	fb_base = (<span class="type">unsigned</span> <span class="type">char</span> *)mmap(<span class="literal">NULL</span>, screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (fb_base == (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t mmap\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清屏: 全部设为白色 */</span></span><br><span class="line">	<span class="built_in">memset</span>(fb_base, <span class="number">0xff</span>, screen_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 随便设置出100个为红色 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">		lcd_put_pixel(var.xres/<span class="number">2</span>+i, var.yres/<span class="number">2</span>, <span class="number">0xFF0000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//取消从fb_base起始，screen_size的字节区域内的任何映射</span></span><br><span class="line">	munmap(fb_base , screen_size);</span><br><span class="line">	close(fd_fb);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文字显示">3.文字显示</h2>
<h3 id="常用编码方式介绍">3.1 常用编码方式介绍</h3>
<h4 id="asni">3.1.1 ASNI</h4>
<ul>
<li>ASNI 是 ASCII 的扩展，对于 ASCII 字符仍以一个字节来表示，对于非
ASCII 字符则使用 2 字节来表示</li>
<li>ASNI 编码，它跟 “本地化”(locale)密切相关。比如在大陆地区，ANSI
的默认编码是 GB2312； 在港澳台地区默认编码是 BIG5</li>
<li>例如GB2312编码的<code>A中</code>对应十六进制为<code>41 D6 D0</code>。<code>41</code>的最高位是0，则是单字节的ASCII码，<code>D6</code>的最高位是1，则<code>D6</code>是一个双字节字符的高字节，然后在GB2312的编码表中在进行查找</li>
<li>这样的方式，导致同一个字符对应不同的编码，同一文件在不同地区打开时可能会乱码</li>
</ul>
<h4 id="unicode">3.1.2 Unicode</h4>
<ul>
<li>Unicode编码对于地球上任意一个字符，都会给它一个唯一的数值</li>
<li>Unicode中的数值范围是 0x0000 至 0x10FFFF</li>
</ul>
<h4 id="unicode的编码实现-utf8">3.1.3 Unicode的编码实现-UTF8</h4>
<ul>
<li><p>UTF8的BOM为：<code>ef bb bf</code></p></li>
<li><p>为了对于常用字符用尽可能少的字节进行表示，同时又能表示出所有的字符，UTF8采用了一种可变字节的方式来表示所有字符的Unicode编码</p></li>
<li><p>对于 ASCII 字符，在 UTF8 文件中直接用其 ASCII 码来表示</p></li>
<li><p>对于非 ASCII
字符，使用变长的编码：每一个字节的高位都自带长度信息：</p>
<ul>
<li>对于两字节字符：高字节的高位为：<code>110</code></li>
<li>对于三字节字符：高字节的高位为：<code>1110</code></li>
<li>对于四字节字符：高字节的高位为：<code>11110</code></li>
</ul>
<figure>
<img src="../images/使用LCD屏幕/image-20230912220629188.png"
alt="image-20230912220629188" />
<figcaption aria-hidden="true">image-20230912220629188</figcaption>
</figure></li>
<li><p>UTF-8节省空间，扩展性好，丢失部分数据不会影响其他数据的正常显示</p></li>
</ul>
<h3 id="显示英文点阵字符">3.2 显示英文点阵字符</h3>
<p>在 Linux
内核源码中有这个文件：<code>lib\fonts\font_8x16.c</code>：</p>
<figure>
<img src="../images/使用LCD屏幕/image-20230913145835456.png"
alt="image-20230913145835456" />
<figcaption aria-hidden="true">image-20230913145835456</figcaption>
</figure>
<p>对应的显示函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_put_ascii</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *dots = (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;fontdata_8x16[c*<span class="number">16</span>];</span><br><span class="line">	<span class="type">int</span> i, b;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> byte;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		byte = dots[i];</span><br><span class="line">		<span class="keyword">for</span> (b = <span class="number">7</span>; b &gt;= <span class="number">0</span>; b--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (byte &amp; (<span class="number">1</span>&lt;&lt;b))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* show */</span></span><br><span class="line">				lcd_put_pixel(x+<span class="number">7</span>-b, y+i, <span class="number">0xffffff</span>); <span class="comment">/* 白 */</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* hide */</span></span><br><span class="line">				lcd_put_pixel(x+<span class="number">7</span>-b, y+i, <span class="number">0</span>); <span class="comment">/* 黑 */</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="显示中文点阵字符">3.3 显示中文点阵字符</h3>
<h4 id="指定代码文件的编码格式">3.3.1 指定代码文件的编码格式</h4>
<p>代码文件中包含非ASCLL码的字符时，尤其要注意文件的编码格式</p>
<ul>
<li><p>在编译程序时使用以下选项告诉编译器代码文件的编码格式；如果不指定，则编译器会默认代码文件的编码格式为UTF-8：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-finput-charset=GB2312 </span><br><span class="line">-finput-charset=UTF-8</span><br></pre></td></tr></table></figure></li>
<li><p>在编译程序时使用以下选项指定可执行程序里的字符的编码格式；：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-fexec-charset=GB2312 </span><br><span class="line">-fexec-charset=UTF-8</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果<code>-finput-charset</code>和<code>-fexec-charset</code>不一样，则编译器会执行格式转换</p>
<h4 id="汉字区位码">3.3.2 汉字区位码</h4>
<p>HZK16是常用汉字的16×16点阵字库，使用GB2312编码值来查找点阵。</p>
<p>以"中"字为例，它的编码值是<code>0xd6 0xd0</code>，其中的<code>0xd6</code>
表示区码，表示在哪一个区：第<code>0xd6-0xa1</code>
区；其中的<code>0xd0</code>表示位码，表示它是这个区里的哪一个字符：第<code>0xd0-0xa1</code>个。每一个区有
94 个汉字。区位码从<code>0xa1</code> 而不是从 0 开始，是为了兼容 ASCII
码。所以"中"对应HZK16中<code>(0xd6 - 0xa1) * 94 + (0xd0 - 0xa1)</code>位置的字符。</p>
<figure>
<img src="../images/使用LCD屏幕/image-20230913163259874.png"
alt="image-20230913163259874" />
<figcaption aria-hidden="true">image-20230913163259874</figcaption>
</figure>
<p>对应显示函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_put_chinese</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> area  = str[<span class="number">0</span>] - <span class="number">0xA1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> where = str[<span class="number">1</span>] - <span class="number">0xA1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *dots = hzkmem + (area * <span class="number">94</span> + where)*<span class="number">32</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> word;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i, j, b;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		word = dots[i * <span class="number">2</span>] &lt;&lt; <span class="number">8</span> | dots[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">15</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (word &amp; (<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* show */</span></span><br><span class="line">                lcd_put_pixel(x+<span class="number">15</span>-j, y+i, <span class="number">0xffffff</span>); <span class="comment">/* 白 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* hide */</span></span><br><span class="line">                lcd_put_pixel(x+<span class="number">15</span>-j, y+i, <span class="number">0</span>); <span class="comment">/* 黑 */</span></span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用freetype">4.使用FreeType</h2>
<ul>
<li><p>FreeType库是开源的高质量字体引擎；支持多种字体格式文件，并提供了统一的访问接口；</p></li>
<li><p>可以在<a
href="https://www.freetype.org/">官网</a>下载到FreeType库，包括文档和示例代码</p></li>
</ul>
<h3 id="矢量字体">4.1 矢量字体</h3>
<p>使用点阵字库显示字符时，大小固定，如果缩放的话字体显示效果会比较差，而矢量字体能够很好解决这个问题。矢量字体的形成分为三步：</p>
<ol type="1">
<li><p>确定关键点（glyph）</p>
<figure>
<img src="../images/使用LCD屏幕/image-20230916205045563.png"
alt="image-20230916205045563" />
<figcaption aria-hidden="true">image-20230916205045563</figcaption>
</figure></li>
<li><p>使用贝塞尔曲线连接头键点</p>
<figure>
<img src="../images/使用LCD屏幕/image-20230916205059339.png"
alt="image-20230916205059339" />
<figcaption aria-hidden="true">image-20230916205059339</figcaption>
</figure></li>
<li><p>填充闭合曲线内部空间</p>
<figure>
<img src="../images/使用LCD屏幕/image-20230916205116566.png"
alt="image-20230916205116566" />
<figcaption aria-hidden="true">image-20230916205116566</figcaption>
</figure></li>
</ol>
<p>对于矢量字体进行缩放，关键点的相对位置不变，只要用数学曲线平滑，字体就不会变形。</p>
<h3 id="使用freetype显示矢量字体">4.2 使用FreeType显示矢量字体</h3>
<p><strong>矢量字体文件</strong>中记录不同字符的关键点(glyph)；Windows使用的字体文件在<code>C:\Windows\Fonts</code>目录下，拓展名为<code>.TTF</code>都是矢量字库。</p>
<p>和点阵字库一样，矢量字库也是通过<strong>字符编码</strong>来寻址，从而找到对应的字体关键点。<strong>Charmaps</strong>表示矢量字库的字符映射表，可能支持多种编码进行寻址，例如ASCII、GB2312、UniCode，一般矢量字库都支持UniCode编码。</p>
<h4 id="步骤概括">4.2.1 步骤概括</h4>
<ol type="1">
<li>获取字符UniCode编码值</li>
<li>设置字体大小</li>
<li>根据编码从<strong>Charmaps</strong>中找到对应的关键点，FreeType库会根据字体大小自动调整关键点位置</li>
<li>把关键点转换为点阵位图</li>
<li>在LCD上进行显示</li>
</ol>
<p>参考FreeType库官网的使用文档，可以总结使用FreeType库的调库步骤：</p>
<ol type="1">
<li>初始化：<code>FT_InitFreeType</code></li>
<li>加载字体文件Face：<code>FT_New_Face</code></li>
<li>设置字体大小：<code>FT_Set_Char_Sizes</code>或<code>FT_Set_Pixel_Sizes</code></li>
<li>选择Charmap：<code>FT_Select_Charmap</code></li>
<li>根据字符编码charcode得到字符位图：<code>FT_Load_Char(face, charcode, FT_LOAD_RENDER)</code>
<ol type="1">
<li>根据编码值Charcode找到glyph_index：<code>glyph_index = FT_Get_Char_Index(face, charcode)</code></li>
<li>根据glypg_index取出glyph：<code>FT_Load_Glyph(face, glyph_index)</code></li>
<li>转换为点阵位图：<code>FT_Render_Glyph</code></li>
</ol></li>
<li>移动或者旋转：<code>FT_Set_Transform</code></li>
<li>调用LCD显示函数将位图进行显示</li>
</ol>
<h4 id="freetype的几个重要结构体">4.2.2 FreeType的几个重要结构体</h4>
<h5 id="ft_library">FT_Library</h5>
<p>对于 freetype 库，使用 freetype 之前要先调用以下代码进行初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FT_Library library; <span class="comment">/* 对应 freetype 库 */</span> </span><br><span class="line">error = FT_Init_FreeType( &amp;library ); <span class="comment">/* 初始化 freetype 库 */</span></span><br></pre></td></tr></table></figure>
<h5 id="ft_face">FT_face</h5>
<p>对应矢量字体文件，使用如下代码来打开一个字体文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">error = FT_New_Face(library, font_file, <span class="number">0</span>, &amp;face ); <span class="comment">/* 加载字体文件 */</span></span><br></pre></td></tr></table></figure>
<figure>
<img src="../images/使用LCD屏幕/image-20230917170926592.png"
alt="image-20230917170926592" />
<figcaption aria-hidden="true">image-20230917170926592</figcaption>
</figure>
<h5 id="ft_glyphslot">FT_GlyphSlot</h5>
<p>插槽，用来保存字符的处理结果（比如glyph，位图等信息）。当处理face字库中下一个字符时，会覆盖掉插槽中保存的上一个字符的内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FT_GlyphSlot slot = face-&gt;glyph; <span class="comment">/* 插槽: 字体的处理结果保存在这里 */</span></span><br></pre></td></tr></table></figure>
<p><strong>FT_Glyph</strong></p>
<p>字符的原始关键点信息，使用 freetype 的函数可以放大、
缩小、旋转，这些新的关键点保存在插槽中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FT_Glyph glyph;</span><br><span class="line">error = FT_Get_Glyph(slot, &amp;glyph);</span><br></pre></td></tr></table></figure>
<h5 id="ft_bbox">FT_BBox</h5>
<p>表示一个字符的外框，即新 glyph 的外框：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">FT_BBox_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FT_Pos  xMin, yMin;</span><br><span class="line">  FT_Pos  xMax, yMax;</span><br><span class="line">&#125; FT_BBox;</span><br><span class="line"></span><br><span class="line">FT_BBox glyph_bbox;</span><br><span class="line">FT_Glyph_Get_CBox(glyph, FT_GLYPH_BBOX_TRUNCATE, &amp;bbox );   <span class="comment">/* 从glyph得到外框: bbox */</span></span><br></pre></td></tr></table></figure>
<h4 id="在lcd上显示矢量字体">4.2.3 在LCD上显示矢量字体</h4>
<h5
id="使用wchar_t获取字符的unicode值">使用<code>wchar_t</code>获取字符的UniCode值</h5>
<p><code>wchar_t</code>是宽字符类型，根据系统可能大小是2字节或者4字节。使用宽字符保存的字符编码格式为UTF-16或者UTF-32都属于Unicode编码家族。不同于UTF-8，这两种编码对于每一个字符都是用相同的字节保存，所以宽字符中保存的就是<strong>该字符对应的原始Unicode编码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">wchar_t</span> *chinese_str = <span class="string">L&quot;中gif&quot;</span>;  <span class="comment">//L指示编译器该字符串按宽字符保存</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(wchar_t) = %d, str&#x27;s Uniocde: \n&quot;</span>, (<span class="type">int</span>)<span class="keyword">sizeof</span>(<span class="type">wchar_t</span>));</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; wcslen(chinese_str); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0x%x &quot;</span>, chinese_str[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我的系统上输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sizeof(wchar_t) = 4, str&#x27;s Uniocde: </span><br><span class="line">0x4e2d 0x67 0x69 0x66 </span><br></pre></td></tr></table></figure>
<h5 id="代码">代码</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">wchar_t</span> *chinese_str = <span class="string">L&quot;繁&quot;</span>;</span><br><span class="line">FT_Library	  library;</span><br><span class="line">FT_Face 	  face;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line">FT_Vector     pen;</span><br><span class="line">FT_GlyphSlot  slot;</span><br><span class="line"><span class="comment">// 初始化FreeType库</span></span><br><span class="line">error = FT_Init_FreeType( &amp;library );			 </span><br><span class="line"><span class="comment">// 从字体文件路径argv[1] 取出索引为0的字体 放入face结构体中</span></span><br><span class="line">error = FT_New_Face( library, argv[<span class="number">1</span>], <span class="number">0</span>, &amp;face ); </span><br><span class="line">slot = face-&gt;glyph;</span><br><span class="line"><span class="comment">// 设置字体大小</span></span><br><span class="line">FT_Set_Pixel_Sizes(face, font_size, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/* load glyph image into the slot (erase previous one) */</span></span><br><span class="line">error = FT_Load_Char( face, chinese_str[<span class="number">0</span>], FT_LOAD_RENDER );</span><br><span class="line"><span class="comment">//绘制点阵位图</span></span><br><span class="line">draw_bitmap( &amp;slot-&gt;bitmap,</span><br><span class="line">             var.xres/<span class="number">2</span>,</span><br><span class="line">             var.yres/<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>绘制位图，位图中的每一个像素使用一字节表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">draw_bitmap</span><span class="params">(FT_Bitmap *bitmap, FT_Int x, FT_Int y)</span> &#123;</span><br><span class="line">  FT_Int i, j, p, q;</span><br><span class="line">  FT_Int x_max = x + bitmap-&gt;width;</span><br><span class="line">  FT_Int y_max = y + bitmap-&gt;rows;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = y, q = <span class="number">0</span>; j &lt; y_max; j++, q++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = x, p = <span class="number">0</span>; i &lt; x_max; i++, p++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= var.xres || j &gt;= var.yres)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      lcd_put_pixel(i, j, bitmap-&gt;buffer[q * bitmap-&gt;width + p]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="../images/使用LCD屏幕/image-20230917151354574.png"
alt="image-20230917151354574" />
<figcaption aria-hidden="true">image-20230917151354574</figcaption>
</figure>
<h4 id="字体的平移和旋转">4.2.4 字体的平移和旋转</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FT_Vector     pen;</span><br><span class="line">FT_Matrix	  matrix;	</span><br><span class="line"><span class="type">double</span>		  angle;</span><br><span class="line"><span class="comment">// 设置字体的相对平移量</span></span><br><span class="line">pen.x = <span class="number">0</span>;</span><br><span class="line">pen.y = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 角度转弧度</span></span><br><span class="line">angle  = ( <span class="number">1.0</span>* strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>) / <span class="number">360</span> ) * <span class="number">3.14159</span> * <span class="number">2</span>;	  </span><br><span class="line"><span class="comment">/* 设置旋转矩阵</span></span><br><span class="line"><span class="comment">cos()  -sin() </span></span><br><span class="line"><span class="comment">sin()   cos()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">matrix.xx = (FT_Fixed)( <span class="built_in">cos</span>( angle ) * <span class="number">0x10000</span>L );</span><br><span class="line">matrix.xy = (FT_Fixed)(-<span class="built_in">sin</span>( angle ) * <span class="number">0x10000</span>L );</span><br><span class="line">matrix.yx = (FT_Fixed)( <span class="built_in">sin</span>( angle ) * <span class="number">0x10000</span>L );</span><br><span class="line">matrix.yy = (FT_Fixed)( <span class="built_in">cos</span>( angle ) * <span class="number">0x10000</span>L );</span><br><span class="line"><span class="comment">// 对字体进行平移和旋转</span></span><br><span class="line">FT_Set_Transform( face, &amp;matrix, &amp;pen);</span><br></pre></td></tr></table></figure>
<h3 id="使用freetype显示一行文字">4.3 使用FreeType显示一行文字</h3>
<h4 id="坐标系转换">4.3.1 坐标系转换</h4>
<p>FreeType使用的坐标系是笛卡尔坐标系，和LCD使用的坐标系之间需要进行转换：</p>
<figure>
<img src="../images/使用LCD屏幕/image-20230917160355054.png"
alt="image-20230917160355054" />
<figcaption aria-hidden="true">image-20230917160355054</figcaption>
</figure>
<h4 id="使用矢量字体显示一行文字的过程">4.3.2
使用矢量字体显示一行文字的过程</h4>
<p>如果需要在给定坐标处作为左上角显示一行文字；使用点阵字体显示时，每个字符大小已知且相等，可以直接在指定位置上显示字符；</p>
<p>但是使用矢量字体：</p>
<ul>
<li><p>由于每一个字符的大小和位置都不同，必须遍历一行文字，求出这行文字最小外接矩形的笛卡尔坐标</p>
<figure>
<img src="../images/使用LCD屏幕/image-20230917163256692.png"
alt="image-20230917163256692" />
<figcaption aria-hidden="true">image-20230917163256692</figcaption>
</figure></li>
<li><p>假设给定坐标的笛卡尔坐标为<span
class="math inline">\((x,y)\)</span>，最小外接矩形的左上角坐标为<span
class="math inline">\((x&#39;,y&#39;)\)</span>，则坐标<span
class="math inline">\((x-x&#39;,y-y&#39;)\)</span>为平移之后第一个字符显示的原点(origin)</p>
<figure>
<img src="../images/使用LCD屏幕/image-20230917164024463.png"
alt="image-20230917164024463" />
<figcaption aria-hidden="true">image-20230917164024463</figcaption>
</figure></li>
<li><p>知道第一个字符的原点，可以通过<code>FT_Set_Transform(face, 0, &amp;pen);</code>设置平移向量；</p></li>
<li><p>设置完所有矢量字体的参数之后，将第一个字符的左上角坐标转换为LCD坐标，即可显示第一个字符的位图</p></li>
</ul>
<figure>
<img src="../images/使用LCD屏幕/image-20230917164220523.png"
alt="image-20230917164220523" />
<figcaption aria-hidden="true">image-20230917164220523</figcaption>
</figure>
<ul>
<li><p>然后由第一个字符的步进量<code>advance</code>得到下一个字符的origin，即可重复上面的过程</p>
<figure>
<img src="../images/使用LCD屏幕/image-20230917164513063.png"
alt="image-20230917164513063" />
<figcaption aria-hidden="true">image-20230917164513063</figcaption>
</figure></li>
</ul>
<p><strong>矢量字符大小示意图：</strong></p>
<figure>
<img src="../images/使用LCD屏幕/image-20230917162254764.png"
alt="image-20230917162254764" />
<figcaption aria-hidden="true">image-20230917162254764</figcaption>
</figure>
<h4 id="代码-1">4.3.3 代码</h4>
<h5 id="求最小外接矩形">求最小外接矩形</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compute_string_bbox</span><span class="params">(FT_Face face, <span class="type">wchar_t</span> *wstr, FT_BBox *abbox)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> error;</span><br><span class="line">  FT_BBox bbox;</span><br><span class="line">  FT_BBox glyph_bbox;</span><br><span class="line">  FT_Vector pen;</span><br><span class="line">  FT_Glyph glyph;</span><br><span class="line">  FT_GlyphSlot slot = face-&gt;glyph;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 */</span></span><br><span class="line">  bbox.xMin = bbox.yMin = <span class="number">32000</span>;</span><br><span class="line">  bbox.xMax = bbox.yMax = <span class="number">-32000</span>;</span><br><span class="line">  <span class="comment">/* 指定原点为(0, 0) */</span></span><br><span class="line">  pen.x = <span class="number">0</span>;</span><br><span class="line">  pen.y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 计算每个字符的bounding box */</span></span><br><span class="line">  <span class="comment">/* 先translate, 再load char, 就可以得到它的外框了 */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; wcslen(wstr); i++) &#123;</span><br><span class="line">    <span class="comment">/* 转换：transformation */</span></span><br><span class="line">    FT_Set_Transform(face, <span class="number">0</span>, &amp;pen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 加载位图: load glyph image into the slot (erase previous one) */</span></span><br><span class="line">    error = FT_Load_Char(face, wstr[i], FT_LOAD_RENDER);</span><br><span class="line">    <span class="comment">/* 取出glyph */</span></span><br><span class="line">    error = FT_Get_Glyph(face-&gt;glyph, &amp;glyph);</span><br><span class="line">    <span class="comment">/* 从glyph得到外框: bbox */</span></span><br><span class="line">    FT_Glyph_Get_CBox(glyph, FT_GLYPH_BBOX_TRUNCATE, &amp;glyph_bbox);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新外框 */</span></span><br><span class="line">    <span class="keyword">if</span> (glyph_bbox.xMin &lt; bbox.xMin)</span><br><span class="line">      bbox.xMin = glyph_bbox.xMin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (glyph_bbox.yMin &lt; bbox.yMin)</span><br><span class="line">      bbox.yMin = glyph_bbox.yMin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (glyph_bbox.xMax &gt; bbox.xMax)</span><br><span class="line">      bbox.xMax = glyph_bbox.xMax;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (glyph_bbox.yMax &gt; bbox.yMax)</span><br><span class="line">      bbox.yMax = glyph_bbox.yMax;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算下一个字符的原点: increment pen position */</span></span><br><span class="line">    pen.x += glyph-&gt;advance.x;</span><br><span class="line">    pen.y += glyph-&gt;advance.y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* return string bbox */</span></span><br><span class="line">  *abbox = bbox;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="显示一行文字">显示一行文字</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 计算外框 */</span></span><br><span class="line">compute_string_bbox(face, wstr, &amp;bbox);</span><br><span class="line"><span class="comment">/* 反推原点 (FreeType显示的单位是1/64像素,因此×64)*/</span></span><br><span class="line">pen.x = (x - bbox.xMin) * <span class="number">64</span>; <span class="comment">/* 单位: 1/64像素 */</span></span><br><span class="line">pen.y = (y - bbox.yMax) * <span class="number">64</span>; <span class="comment">/* 单位: 1/64像素 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理每个字符 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; wcslen(wstr); i++) &#123;</span><br><span class="line">    <span class="comment">/* 转换：transformation */</span></span><br><span class="line">    FT_Set_Transform(face, <span class="number">0</span>, &amp;pen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 加载位图: load glyph image into the slot (erase previous one) */</span></span><br><span class="line">    error = FT_Load_Char(face, wstr[i], FT_LOAD_RENDER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在LCD上绘制: 使用LCD坐标 */</span></span><br><span class="line">    draw_bitmap(&amp;slot-&gt;bitmap, slot-&gt;bitmap_left, var.yres - slot-&gt;bitmap_top);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算下一个字符的原点: increment pen position */</span></span><br><span class="line">    pen.x += slot-&gt;advance.x;</span><br><span class="line">    pen.y += slot-&gt;advance.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用电阻屏和电容屏</title>
    <url>/2023/09/22/%E4%BD%BF%E7%94%A8%E7%94%B5%E9%98%BB%E5%B1%8F%E5%92%8C%E7%94%B5%E5%AE%B9%E5%B1%8F/</url>
    <content><![CDATA[<h2 id="电阻屏和电容屏定位原理">1. 电阻屏和电容屏定位原理</h2>
<h3 id="电阻屏">1.1 电阻屏</h3>
<figure>
<img src="../images/使用电阻屏和电容屏/image-20230922200403814.png"
alt="image-20230922200403814" />
<figcaption aria-hidden="true">image-20230922200403814</figcaption>
</figure>
<ul>
<li>根据分压原理，计算电阻值。假设材料长度和电阻成线性关系，则可以计算出相对距离</li>
<li>电阻屏分为上下两层薄膜，一层通电时，另一层在按压时作为探针获取分压值，从而进行计算</li>
<li>电阻屏和LCD使用之前，需要进行五点校准二者的相对位置</li>
</ul>
<h4 id="电阻屏数据">1.1.1 电阻屏数据</h4>
<p>按下时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EV_KEY    BTN_TOUCH       <span class="number">1</span>             <span class="comment">/* 按下 */</span> </span><br><span class="line">EV_ABS    ABS_PRESSURE    <span class="number">1</span>             <span class="comment">/* 压力值，可以上报，也可以不报，可以是其他压力值 */</span> </span><br><span class="line">EV_ABS    ABS_X           x_value       <span class="comment">/* X 坐标 */</span> </span><br><span class="line">EV_ABS    ABS_Y           y_value       <span class="comment">/* Y 坐标 */</span> </span><br><span class="line">EV_SYNC   <span class="number">0</span>               <span class="number">0</span>             <span class="comment">/* 同步事件 */</span></span><br></pre></td></tr></table></figure>
<p>松开时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EV_KEY    BTN_TOUCH         <span class="number">0</span>           <span class="comment">/* 松开 */</span> </span><br><span class="line">EV_ABS    ABS_PRESSURE      <span class="number">0</span>           <span class="comment">/* 压力值，可以上报，也可以不报 */</span> </span><br><span class="line">EV_SYNC   <span class="number">0</span>                 <span class="number">0</span>           <span class="comment">/* 同步事件 */</span></span><br></pre></td></tr></table></figure>
<h3 id="电容屏">1.2 电容屏</h3>
<figure>
<img src="../images/使用电阻屏和电容屏/image-20230922202123424.png"
alt="image-20230922202123424" />
<figcaption aria-hidden="true">image-20230922202123424</figcaption>
</figure>
<p>电容屏中有一个控制芯片，它会周期性产生驱动信号，接收电极接收到信号，
并可测量电荷大小。当电容屏被按下时，相当于引入了新的电容，从而影响了接
收电极接收到的电荷大小。主控芯片根据电荷大小即可计算出触点位置，应用开发人员只需要编写程序，通过
I2C 读取芯片寄存器即可得到这些数据。</p>
<h4 id="电容屏多点触摸上报数据">1.2.1 电容屏多点触摸上报数据</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EV_ABS    ABS_MT_SLOT            <span class="number">0</span>    <span class="comment">// 这表示“我要上报一个触点信息了”，用来分隔触点信息 </span></span><br><span class="line">EV_ABS    ABS_MT_TRACKING_ID     <span class="number">45</span>   <span class="comment">// 这个触点的 ID 是 45，由控制芯片分配</span></span><br><span class="line">EV_ABS    ABS_MT_POSITION_X      x[<span class="number">0</span>] <span class="comment">// 触点 X 坐标 </span></span><br><span class="line">EV_ABS    ABS_MT_POSITION_Y      y[<span class="number">0</span>] <span class="comment">// 触点 Y 坐标 </span></span><br><span class="line">EV_ABS    ABS_MT_SLOT            <span class="number">1</span>    <span class="comment">// 这表示“我要上报一个触点信息了”，用来分隔触点信息 </span></span><br><span class="line">EV_ABS    ABS_MT_TRACKING_ID     <span class="number">46</span>   <span class="comment">// 这个触点的 ID 是 46，由控制芯片分配</span></span><br><span class="line">EV_ABS    ABS_MT_POSITION_X      x[<span class="number">1</span>] <span class="comment">// 触点 X 坐标 </span></span><br><span class="line">EV_ABS    ABS_MT_POSITION_Y      y[<span class="number">1</span>] <span class="comment">// 触点 Y 坐标 </span></span><br><span class="line">EV_SYNC   SYN_REPORT             <span class="number">0</span>    <span class="comment">// 全部数据上报完毕</span></span><br></pre></td></tr></table></figure>
<p>当 ID 为 45 的触点正在移动时：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EV_ABS    ABS_MT_SLOT            <span class="number">0</span>    <span class="comment">// 表示“要上报一个触点信息了”,之前上报过ID,就不用再上报ID </span></span><br><span class="line">EV_ABS    ABS_MT_POSITION_X      x[<span class="number">0</span>] <span class="comment">// 触点 X 坐标 </span></span><br><span class="line">EV_SYNC   SYN_REPORT             <span class="number">0</span>    <span class="comment">// 全部数据上报完毕</span></span><br></pre></td></tr></table></figure>
<p>松开 ID 为 45 的触点时(在前面 slot 已经被设置为
0，这里不需要再重新设置 slot，slot
就像一个全局变量一样：如果它没变化的话，就无需再次设置)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EV_ABS    ABS_MT_TRACKING_ID     <span class="number">-1</span>   <span class="comment">// slot对应的ID是45,这里ID=-1，表示ID=45的触点被松开了</span></span><br><span class="line">EV_SYNC   SYN_REPORT             <span class="number">0</span>    <span class="comment">// 全部数据上报完毕</span></span><br></pre></td></tr></table></figure>
<p>最后，松开 ID 为 46 的触点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EV_ABS    ABS_MT_SLOT            <span class="number">1</span>    <span class="comment">// 这表示“我要上报一个触点信息了”， slot 1 的 ID 为 46 </span></span><br><span class="line">EV_ABS    ABS_MT_TRACKING_ID    <span class="number">-1</span>     <span class="comment">// ID 为-1，表示 slot 1 被松开，即ID为46的触点被松开 </span></span><br><span class="line">EV_SYNC   SYN_REPORT                   <span class="comment">// 全部数据上报完毕</span></span><br></pre></td></tr></table></figure>
<h4 id="电容屏实际数据分析">1.2.2 电容屏实际数据分析</h4>
<p>电容屏单点击：</p>
<figure>
<img src="../images/使用电阻屏和电容屏/image-20230922204156789.png"
alt="image-20230922204156789" />
<figcaption aria-hidden="true">image-20230922204156789</figcaption>
</figure>
<ul>
<li><code>xx_MAJOR</code>：用来描述触点大小，不是常用数据</li>
<li><code>ABS_X/ABS_Y</code>：用来兼容老版本应用程序，电阻屏就是使用这个类型的数据</li>
</ul>
<p>两点触发：</p>
<figure>
<img src="../images/使用电阻屏和电容屏/image-20230922204750931.png"
alt="image-20230922204750931" />
<figcaption aria-hidden="true">image-20230922204750931</figcaption>
</figure>
<ul>
<li>为了兼容老程序，它也上报了 ABS_X、ABS_Y 数据，但是只上报第 1
个触点的数据</li>
</ul>
<h2 id="触摸屏开源库-tslib">2.触摸屏开源库-tslib</h2>
<h3 id="tslib框架分析">2.1 tslib框架分析</h3>
<h4 id="目录结构">2.1.1 目录结构</h4>
<p>tslib的主要代码文件结构：</p>
<figure>
<img src="../images/使用电阻屏和电容屏/image-20230922215156184.png"
alt="image-20230922215156184" />
<figcaption aria-hidden="true">image-20230922215156184</figcaption>
</figure>
<ul>
<li>核心在于plugins目录，该目录下每一个文件都是一个module，每个module都提供2个函数：<code>read</code>和<code>read_mt</code>，<strong>前者用于读取单点触摸屏数据，后者用于读取多点触摸屏数据</strong></li>
<li>test目录下是示例程序</li>
</ul>
<h4 id="框架结构">2.1.2 框架结构</h4>
<figure>
<img src="../images/使用电阻屏和电容屏/image-20230922224515068.png"
alt="image-20230922224515068" />
<figcaption aria-hidden="true">image-20230922224515068</figcaption>
</figure>
<ol type="1">
<li><p>调用<code>ts_open</code>后，可以打开某个设备节点，构造出一个
<code>tsdev</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tsdev</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *eventpath;                     <span class="comment">// 设备文件路径</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tslib_module_info</span> *<span class="title">list</span>;</span>      <span class="comment">// 数据处理路径链表</span></span><br><span class="line">	<span class="comment">/* points to position in &#x27;list&#x27; where raw reads</span></span><br><span class="line"><span class="comment">	 * come from.  default is the position of the</span></span><br><span class="line"><span class="comment">	 * ts_read_raw module.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tslib_module_info</span> *<span class="title">list_raw</span>;</span> <span class="comment">//一般指向最底层的数据处理模块</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> res_x;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> res_y;</span><br><span class="line">	<span class="type">int</span> rotation;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tslib_module_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tsdev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tslib_module_info</span> *<span class="title">next</span>;</span>	<span class="comment">/* next module in chain	*/</span></span><br><span class="line">	<span class="type">void</span> *handle;			<span class="comment">/* dl handle		*/</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tslib_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>调用<code>ts_config</code>读取配置文件，假设<code>/etc/ts.conf</code>的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module_raw input </span><br><span class="line">module pthres pmin=1 </span><br><span class="line">module dejitter delta=100 </span><br><span class="line">module linear</span><br></pre></td></tr></table></figure>
<ul>
<li>每行表示一个module或moduel_raw。对于module都会插入<code>tsdev.list</code>表头(读取文件从上到下进行头插)</li>
<li>对于所有的<code>module_raw</code>都会插入<code>tsdev.list_raw</code>链表头，一般都只有一个<code>module_raw</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __ts_attach(<span class="keyword">struct</span> tsdev *ts, <span class="keyword">struct</span> tslib_module_info *info)</span><br><span class="line">&#123;</span><br><span class="line">	info-&gt;dev = ts;</span><br><span class="line">	info-&gt;next = ts-&gt;<span class="built_in">list</span>;</span><br><span class="line">	ts-&gt;<span class="built_in">list</span> = info;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用<code>ts_read</code>或者<code>ts_read_mt</code>都是通过<code>tsdev.list</code>中的模块来处理数据，该过程是一个递归向下调用的过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">linear_read</span><span class="params">(<span class="keyword">struct</span> tslib_module_info *info, <span class="keyword">struct</span> ts_sample *samp,</span></span><br><span class="line"><span class="params">		       <span class="type">int</span> nr_samples)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tslib_linear</span> *<span class="title">lin</span> =</span> (<span class="keyword">struct</span> tslib_linear *)info;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">int</span> xtemp, ytemp;</span><br><span class="line">    <span class="comment">//调用list中的下一个模块读取数据</span></span><br><span class="line">	ret = info-&gt;next-&gt;ops-&gt;read(info-&gt;next, samp, nr_samples); </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="编译和安装tslib">2.2 编译和安装tslib</h3>
<p>根据之前的知识，知道编译和安装库应该执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --host=arm-buildroot-linux-gnueabihf --prefix=$PWD/tmp </span><br><span class="line">make                </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>而<code>ts_config</code>函数首先会在环境变量<code>TSLIB_CONFFILE</code>指定的目录中寻找配置文件<code>ts.conf</code>，如果没有该环境变量，则会在宏定义<code>TS_CONF</code>中寻找配置文件<code>ts.conf</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((conffile = getenv(<span class="string">&quot;TSLIB_CONFFILE&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	conffile = strdup(TS_CONF);</span><br><span class="line">	<span class="keyword">if</span> (conffile) &#123;</span><br><span class="line">		strdup_allocated = <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ts_error(<span class="string">&quot;Couldn&#x27;t find tslib config file: %s\n&quot;</span>,</span><br><span class="line">				strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果按照之前的命令去编译库，指定<code>prefix=$PWD/tmp</code>，则查找宏定义<code>TS_CONF</code>的值发现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -nwr &quot;TS_CONF&quot; .</span><br><span class="line"></span><br><span class="line">TS_CONF = $&#123;sysconfdir&#125;/ts.conf</span><br><span class="line">sysconfdir = $&#123;prefix&#125;/etc</span><br><span class="line">prefix=&#x27;/home/book/vscodeFile/embbed_study/11_input/02_tslib/tslib-1.21/tmp&#x27;</span><br></pre></td></tr></table></figure>
<p>这意味着在开发板上配置文件<code>ts.conf</code>需要放在<code>/home/book/vscodeFile/embbed_study/11_input/02_tslib/tslib-1.21/tmp/etc</code>这样一个目录下，这显然太麻烦了。为了将<code>ts.conf</code>放在开发板的<code>/etc/</code>目录时能够找的到，需要改变一下prefix参数值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --host=arm-buildroot-linux-gnueabihf --prefix=/</span><br><span class="line">make                </span><br><span class="line">make install prefix=$PWD/tmp</span><br></pre></td></tr></table></figure>
<p>按照上述命令，在执行<code>make install</code>会报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">libtool:   error: error: cannot install &#x27;linear.la&#x27; to a directory not ending in //lib/ts</span><br><span class="line">Makefile:813: recipe for target &#x27;install-pluginexecLTLIBRARIES&#x27; failed</span><br><span class="line">make[2]: *** [install-pluginexecLTLIBRARIES] Error 1</span><br><span class="line">make[2]: 离开目录“/home/book/vscodeFile/embbed_study/11_input/02_tslib/tslib-1.21/plugins”</span><br><span class="line">Makefile:1098: recipe for target &#x27;install-am&#x27; failed</span><br><span class="line">make[1]: *** [install-am] Error 2</span><br><span class="line">make[1]: 离开目录“/home/book/vscodeFile/embbed_study/11_input/02_tslib/tslib-1.21/plugins”</span><br><span class="line">Makefile:488: recipe for target &#x27;install-recursive&#x27; failed</span><br><span class="line">make: *** [install-recursive] Error 1</span><br></pre></td></tr></table></figure>
<p>查找对应<code>plugins/Makefile</code>对应的代码：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">install-pluginexecLTLIBRARIES: <span class="variable">$(pluginexec_LTLIBRARIES)</span></span></span><br><span class="line">        @<span class="variable">$(NORMAL_INSTALL)</span></span><br><span class="line">        @list=&#x27;<span class="variable">$(pluginexec_LTLIBRARIES)</span>&#x27;; test -n <span class="string">&quot;<span class="variable">$(pluginexecdir)</span>&quot;</span> || list=; \</span><br><span class="line">        list2=; for p in $$list; do \</span><br><span class="line">          if test -f $$p; then \</span><br><span class="line">            list2=<span class="string">&quot;$$list2 $$p&quot;</span>; \</span><br><span class="line">          <span class="keyword">else</span> :; fi; \</span><br><span class="line">        done; \</span><br><span class="line">        test -z <span class="string">&quot;$$list2&quot;</span> || &#123; \</span><br><span class="line">          echo <span class="string">&quot; <span class="variable">$(MKDIR_P)</span> &#x27;<span class="variable">$(DESTDIR)</span><span class="variable">$(pluginexecdir)</span>&#x27;&quot;</span>; \</span><br><span class="line">          <span class="variable">$(MKDIR_P)</span> <span class="string">&quot;<span class="variable">$(DESTDIR)</span><span class="variable">$(pluginexecdir)</span>&quot;</span> || exit 1; \</span><br><span class="line">          echo <span class="string">&quot; <span class="variable">$(LIBTOOL)</span> <span class="variable">$(AM_LIBTOOLFLAGS)</span> <span class="variable">$(LIBTOOLFLAGS)</span> --mode=install <span class="variable">$(INSTALL)</span> <span class="variable">$(INSTALL_STRIP_FLAG)</span> $$list2 &#x27;<span class="variable">$(DESTDIR)</span><span class="variable">$(pluginexecdir)</span>&#x27;&quot;</span>; \</span><br><span class="line">          <span class="variable">$(LIBTOOL)</span> <span class="variable">$(AM_LIBTOOLFLAGS)</span> <span class="variable">$(LIBTOOLFLAGS)</span> --mode=install <span class="variable">$(INSTALL)</span> <span class="variable">$(INSTALL_STRIP_FLAG)</span> $$list2 <span class="string">&quot;<span class="variable">$(DESTDIR)</span><span class="variable">$(pluginexecdir)</span>&quot;</span>; \</span><br></pre></td></tr></table></figure>
<p>这段代码在安装动态库文件<code>pluginexec_LTLIBRARIES</code>，原因大概率是目标目录<code>$(DESTDIR)$(pluginexecdir)</code>设置的有问题，通过查找<code>DESTDIR</code>发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   The second method involves providing the `DESTDIR&#x27; variable.  For</span><br><span class="line">example, `make install DESTDIR=/alternate/directory&#x27; will prepend</span><br><span class="line">`/alternate/directory&#x27; before all installation names.  The approach of</span><br><span class="line">`DESTDIR&#x27; overrides is not required by the GNU Coding Standards, and</span><br><span class="line">does not work on platforms that have drive letters.  On the other hand,</span><br><span class="line">it does better at avoiding recompilation issues, and works well even</span><br><span class="line">when some directory options were not specified in terms of `$&#123;prefix&#125;&#x27;</span><br><span class="line">at `configure&#x27; time.</span><br></pre></td></tr></table></figure>
<p>所以，可以通过<code>DESTDIR</code>来指定安装目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install DESTDIR=$PWD/tmp</span><br></pre></td></tr></table></figure>
<p>这样，即可实现安装在当前目录下，同时配置文件的寻找路径为<code>/etc/</code>了</p>
<h4 id="将动态库和可执行程序放到开发板上">2.2.1
将动态库和可执行程序放到开发板上</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /mnt/tslib-1.21/tmp/lib/*so* -d /lib </span><br><span class="line">cp /mnt/tslib-1.21/tmp/lib/ts/*so* -d /lib</span><br><span class="line">cp /mnt/tslib-1.21/tmp/bin/* /bin </span><br><span class="line">cp /mnt/tslib-1.21/tmp/etc/ts.conf -d /etc</span><br></pre></td></tr></table></figure>
<h3 id="使用tslib读取多点触摸数据">2.3 使用tslib读取多点触摸数据</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//触点信息结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ts_sample_mt</span> &#123;</span></span><br><span class="line">	<span class="type">int</span>		x;</span><br><span class="line">	<span class="type">int</span>		y;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	pressure;</span><br><span class="line">	<span class="type">int</span>		slot;</span><br><span class="line">	<span class="type">int</span>		tracking_id;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span>		tool_type;</span><br><span class="line">	<span class="type">int</span>		tool_x;</span><br><span class="line">	<span class="type">int</span>		tool_y;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	touch_major;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	width_major;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	touch_minor;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	width_minor;</span><br><span class="line">	<span class="type">int</span>		orientation;</span><br><span class="line">	<span class="type">int</span>		distance;</span><br><span class="line">	<span class="type">int</span>		blob_id;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>	<span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* BTN_TOUCH state */</span></span><br><span class="line">	<span class="type">short</span>		pen_down;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* valid is set != 0 if this sample</span></span><br><span class="line"><span class="comment">	 * contains new data; see below for the</span></span><br><span class="line"><span class="comment">	 * bits that get set.</span></span><br><span class="line"><span class="comment">	 * valid is set to 0 otherwise</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">short</span>		valid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参考<code>ts_test_mt.c</code>，编写一个读取触点程序，实现如果有两个触点，则输出两个触点的距离的功能：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tsdev</span> *<span class="title">ts</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_absinfo</span> <span class="title">slot</span>;</span></span><br><span class="line"><span class="type">int</span> i, max_slots, ret, touch_cnt;</span><br><span class="line"><span class="type">int</span> point_pressed[<span class="number">20</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ts_sample_mt</span> **<span class="title">sample_mt</span>, **<span class="title">pre_sample_mt</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开触摸屏设备文件</span></span><br><span class="line">ts = ts_setup(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//读取触摸屏的配置信息</span></span><br><span class="line"><span class="keyword">if</span>(ioctl(ts_fd(ts), EVIOCGABS(ABS_MT_SLOT), &amp;slot) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	perror(<span class="string">&quot;ioctl EVIOCGABS&quot;</span>);</span><br><span class="line">	ts_close(ts);</span><br><span class="line">	<span class="keyword">return</span> errno;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取触摸屏最大支持的触点数(15 - 0 + 1)</span></span><br><span class="line">max_slots = slot.maximum - slot.minimum + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//分配内存</span></span><br><span class="line">sample_mt = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ts_sample_mt *));</span><br><span class="line">*sample_mt = <span class="built_in">calloc</span>(max_slots, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ts_sample_mt));</span><br><span class="line">pre_sample_mt = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ts_sample_mt *));</span><br><span class="line">*pre_sample_mt = <span class="built_in">calloc</span>(max_slots, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ts_sample_mt));</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; max_slots; i++)</span><br><span class="line">	(*pre_sample_mt)[i].valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 读取max_slots个触点的信息，读取1次</span></span><br><span class="line">	ret = ts_read_mt(ts, sample_mt, max_slots, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 将最新的有效信息更新到pre_sample_mt中</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; max_slots; i++)</span><br><span class="line">		<span class="keyword">if</span>((*sample_mt)[i].valid)</span><br><span class="line">			<span class="built_in">memcpy</span>(&amp;pre_sample_mt[<span class="number">0</span>][i], &amp;sample_mt[<span class="number">0</span>][i], <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ts_sample_mt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//point_pressed中保存所有还在接触的触点下标</span></span><br><span class="line">	touch_cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; max_slots; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(pre_sample_mt[<span class="number">0</span>][i].valid &amp;&amp; pre_sample_mt[<span class="number">0</span>][i].tracking_id != <span class="number">-1</span>)</span><br><span class="line">			point_pressed[touch_cnt++] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果有两个触点，则计算距离</span></span><br><span class="line">	<span class="keyword">if</span>(touch_cnt == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;distance %08d\n&quot;</span>, distance(&amp;pre_sample_mt[<span class="number">0</span>][point_pressed[<span class="number">0</span>]], &amp;pre_sample_mt[<span class="number">0</span>][point_pressed[<span class="number">1</span>]]));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以使用pre_sample_mt来备份信息，是因为如果触点接触之后没有移动，则第二次读取时该触点对应的有效位<code>valid</code>为非（不使用pre_sample_mt的话，判断tracking_id也可以实现类似的功能）</p>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用设备树的LED驱动框架</title>
    <url>/2024/01/02/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="设备树">1. 设备树</h2>
<h3 id="设备树的引入">1.1 设备树的引入</h3>
<p>如果按照上面的方式来让我们的Linux内核支持所有的主控和开发板；也许常用的主控芯片并不是很多，但是基于主控芯片所设计出的开发板就是那就是千千万万了。如果要将所有的开发板的引脚配置编译到内核中，那内核中将充斥大量的高度重复的文件。为此，引入了设备树的概念，<strong>设备树用来给内核里的驱动程序指定硬件的信息</strong>：</p>
<figure>
<img src="../images/使用设备树的LED驱动框架/image-20231218155959125.png"
alt="image-20231218155959125" />
<figcaption aria-hidden="true">image-20231218155959125</figcaption>
</figure>
<h3 id="设备树的语法">1.2 设备树的语法</h3>
<p>我们需要编写设备树文件(dts: device tree source)，它需要编译为
dtb(device tree blob)文件，内核使用的是 dtb 文件。</p>
<p>下面是一个设备树示例：</p>
<figure>
<img src="../images/使用设备树的LED驱动框架/image-20231220165324421.png"
alt="image-20231220165324421" />
<figcaption aria-hidden="true">image-20231220165324421</figcaption>
</figure>
<figure>
<img src="../images/使用设备树的LED驱动框架/image-20231220170050864.png"
alt="image-20231220170050864" />
<figcaption aria-hidden="true">image-20231220170050864</figcaption>
</figure>
<h4 id="设备树的格式">1.2.1 设备树的格式</h4>
<h5 id="dts文件的格式">（1）DTS文件的格式</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/;                 // 表示版本</span><br><span class="line">[memory reservations]     // 格式为：/memreserver &lt;address&gt; &lt;length&gt;;</span><br><span class="line">/&#123;</span><br><span class="line">	[property definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="node的格式">（2）node的格式</h5>
<p>设备树中的基本单元，称为“node”，其格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[label:] node-name[@unit-address] &#123;</span><br><span class="line">	[properties definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>label 是标号，可以省略。label 的作用是为了方便地引用 node，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">	uart0: uart@fe001000 &#123;</span><br><span class="line">		compatible=&quot;ns16550&quot;;</span><br><span class="line">		reg=&lt;0xfe001000 0x100&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以使用下面 2 种方法来修改 <code>uart@fe001000</code> 这个
node：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在根节点之外使用 label 引用 node：</span><br><span class="line">&amp;uart0 &#123;</span><br><span class="line">	status = “disabled”;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 或在根节点之外使用全路径</span><br><span class="line">&amp;&#123;/uart@fe001000&#125; &#123; </span><br><span class="line">	status = “disabled”; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="properties的格式">（3）properties的格式</h5>
<ul>
<li>两种格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[label:] property-name;</span><br><span class="line"></span><br><span class="line">[label:] property-name = value;</span><br></pre></td></tr></table></figure>
<ul>
<li>三种取值：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arrays of cells(1 个或多个 32 位数据, 64 位数据使用 2 个 32 位数据表示), </span><br><span class="line">string(字符串), </span><br><span class="line">bytestring(1 个或多个字节)</span><br></pre></td></tr></table></figure>
<ul>
<li>示例：</li>
</ul>
<p><strong>arrays of cells</strong>，cell 就是一个 32
位的数据，用尖括号包围起来。而至于两个32位数据是分别表示两个数值，还是表示一个64bit数据的高低位，则由常用属性<code>#address-cells</code>和<code>#size-cells</code>决定，参见后面的介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interrupts = &lt;17 0xc&gt;;    </span><br><span class="line">clock-frequency = &lt;0x00000001 0x00000000&gt;;</span><br></pre></td></tr></table></figure>
<p><strong>string</strong>，有结束符的字符串，用双引号包围起来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compatible = &quot;simple-bus&quot;;</span><br></pre></td></tr></table></figure>
<p><strong>bytestring</strong>，字节序列，用中括号包围起来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local-mac-address = [00 00 12 34 56 78]; // 每个byte使用2个16进制数来表示</span><br><span class="line">local-mac-address = [000012345678];      // 每个byte使用2个16进制数来表示</span><br></pre></td></tr></table></figure>
<p><strong>各种值的组合</strong>，用逗号隔开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compatible = &quot;ns16550&quot;, &quot;ns8250&quot;; </span><br><span class="line">example = &lt;0xf00f0000 19&gt;, &quot;a strange property format&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="dts-文件包含-dtsi-文件">1.2.2 dts 文件包含 dtsi 文件</h4>
<p>设备树文件不需要我们从零写出来，内核支持了某款芯片比如
imx6ull，在内核的 <code>arch/arm/boot/dts</code>
目录下就有了能用的设备树模板，一般命名为 xxxx.dtsi。“
i”表示“include”，被别的文件引用的。</p>
<p>我们使用某款芯片制作出了自己的单板，所用资源跟 xxxx.dtsi
是大部分相同，小部分不同，所以需要引脚 xxxx.dtsi 并修改。</p>
<p>dtsi 文件跟 dts 文件的语法是完全一样的。</p>
<p>dts 中可以包含.h 头文件，也可以包含 dtsi 文件，在.h 头文件中可以定义
一些宏，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/; </span><br><span class="line">#include &lt;dt-bindings/input/input.h&gt; </span><br><span class="line">#include &quot;imx6ull.dtsi&quot; </span><br><span class="line">/ &#123; </span><br><span class="line">...... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="常用属性">1.2.3 常用属性</h4>
<ol type="1">
<li><p>#address-cells、#size-cells</p>
<p>#address-cells指示硬件的address要用多少个32位数表示；#size-cells表示硬件所占用的内存size要用多少个32位数来表示。</p></li>
<li><p>compatible</p>
<p>“compatible”表示“兼容”，对于某个 LED，内核中可能有 A、B、C
三个驱动都支持它，那可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">led &#123; </span><br><span class="line">	compatible = “A”, “B”, “C”; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内核启动时，就会为这个 LED
按这样的优先顺序为它找到驱动程序：A、B、C。</p>
<p>根节点下也有 compatible
属性，用来选择哪一个<code>machine desc</code>：一个内核可以支持 machine
A，也支持 machine B，<strong>内核启动后会根据根节点的 compatible
属性找到对应的
<code>machine desc</code>结构体，执行其中的初始化函数</strong>。
compatible
的值，建议取这样的形式："manufacturer,model"，即“厂家名，模块名”。</p>
<p>注：<code>machine desc</code>
的意思就是“机器描述”，学到内核启动流程时才涉及。</p></li>
<li><p>model</p>
<p>model 属性与 compatible 属性有些类似，但是有差别。</p>
<p>compatible 属性是一个字符串列表，表示可以你的硬件兼容 A、B、C
等驱动；</p>
<p>model 用来准确地定义这个硬件是什么，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">	compatible = &quot;samsung,smdk2440&quot;, &quot;samsung,mini2440&quot;; </span><br><span class="line">	model = &quot;jz2440_v3&quot;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它表示这个单板，可以兼容内核中的“smdk2440”，也兼容“mini2440”。
<strong>从 compatible 属性中可以知道它兼容哪些板，但是它到底是什么板？用
model 属性来明确</strong>。</p></li>
<li><p>status</p>
<p>dtsi
文件中定义了很多设备，但是在你的板子上某些设备是没有的。这时你可以给这个设备节点添加一个
status 属性，设置为“disabled”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;uart1 &#123; </span><br><span class="line">	status = &quot;disabled&quot;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr class="header">
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>"okay"</td>
<td>设备正常运行</td>
</tr>
<tr class="even">
<td>"disabled"</td>
<td>设备不可操作，但是后面可以恢复工作</td>
</tr>
<tr class="odd">
<td>"fail"</td>
<td>发生了严重错误，需要修复</td>
</tr>
<tr class="even">
<td>"fail-sss"</td>
<td>发生了严重错误，需要修复；sss表示错误信息</td>
</tr>
</tbody>
</table></li>
<li><p>reg</p>
<p>用来描述一段空间。对于 ARM
系统，寄存器和内存是统一编址的，即访问寄存器时用某块地址，访问内存时用某块地址，在访问方法上没有区别。</p>
<p>reg 属性的值，是一系列的<code>address &amp; size</code>，用多少个 32
位的数来表示 address 和 size，由其父节点的#address-cells、#size-cells
决定，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/; </span><br><span class="line">/&#123; </span><br><span class="line">	#address-cells = &lt;1&gt;; </span><br><span class="line">	#size-cells = &lt;1&gt;; </span><br><span class="line">	memory &#123; </span><br><span class="line">		reg = &lt;0x80000000 0x20000000&gt;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>name(过时了，建议不用)</p>
<p>它的值是字符串，用来表示节点的名字。在跟 platform_driver 匹配时，
优先级最低。 compatible 属性在匹配过程中，优先级最高。</p></li>
<li><p>device_type(过时了，建议不用)</p>
<p>它的值是字符串，用来表示节点的类型。在跟 platform_driver 匹配时，
优先级为中。 compatible 属性在匹配过程中，优先级最高。</p></li>
</ol>
<h4 id="常用节点node">1.2.4 常用节点（node）</h4>
<ol type="1">
<li><p>根节点</p>
<p>dts文件中必须有一个根节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">model = &quot;SMDK24440&quot;;</span><br><span class="line">compatible = &quot;samsung,smdk2440&quot;;</span><br><span class="line"></span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根节点中必须有这些属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#address-cells // 在它的子节点的 reg 属性中, 使用多少个 u32 整数来描述地址(address) </span><br><span class="line">#size-cells    // 在它的子节点的 reg 属性中, 使用多少个 u32 整数来描述大小(size) </span><br><span class="line">compatible     // 定义一系列的字符串, 用来指定内核中哪个 machine_desc 可以支持本设备 </span><br><span class="line">               // 即这个板子兼容哪些平台 </span><br><span class="line">               // uImage : smdk2410 smdk2440 mini2440 ==&gt; machine_desc </span><br><span class="line">model          // 咱这个板子是什么</span><br><span class="line">               // 比如有 2 款板子配置基本一致, 它们的 compatible 是一样的 </span><br><span class="line">               // 那么就通过 model 来分辨这 2 款板子</span><br></pre></td></tr></table></figure></li>
<li><p>CPU节点</p>
<p>一般不需要我们设置，在 dtsi 文件中都定义好了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpus &#123; </span><br><span class="line">	#address-cells = &lt;1&gt;; </span><br><span class="line">	#size-cells = &lt;0&gt;; </span><br><span class="line">	cpu0: cpu@0 &#123; </span><br><span class="line">	....... </span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>memory节点</p>
<p>芯片厂家不可能事先确定你的板子使用多大的内存，所以 memory
节点需要板厂设置，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memory &#123;</span><br><span class="line">	reg = &lt;0x80000000 0x20000000&gt;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>chosen节点</p>
<p>我们可以通过设备树文件给内核传入一些参数，这要在chosen节点中设置bootargs属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chosen &#123; </span><br><span class="line">	bootargs = &quot;noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200&quot;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="编译更换设备树">1.3 编译、更换设备树</h3>
<ol type="1">
<li><p>一般设备树文件在内核源码目录下<code>arch/arm/boot/dts/</code>（对于64位系统，需要将<code>arm</code>替换为<code>arm64</code>）下。</p></li>
<li><p>我们一般不会从零写 dts 文件，而是修改。</p></li>
<li><p>当我们修改完设备树文件之后需要将设备树源码文件<code>dts</code>编译为设备树二进制文件<code>dtb</code>。</p></li>
<li><p>然后将修改后的<code>dtb</code>文件放到板子的<code>/boot/</code>目录中；重启开发板，在上电过程中进入Bootload，指定板子所使用的设备树文件，从而完成修改、编译和更换设备树的需求。</p></li>
</ol>
<h4 id="在内核中直接make">1.3.1 在内核中直接make</h4>
<p>设置 ARCH、CROSS_COMPILE、PATH 这三个环境变量后，进入 ubuntu
上板子内核源码的根目录，在根目录下执行如下命令编译 dtb 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make dtbs V=1   // V=1表示输出详细信息，可省略</span><br></pre></td></tr></table></figure>
<p>这种编译方式<strong>首先会使用 gcc
对<code>dts</code>文件进行预编译，然后对预编译生成的临时文件使用 dtc
工具进行编译。</strong></p>
<h4 id="手工编译">1.3.2 手工编译</h4>
<p>除非你对设备树比较了解，否则不建议手工使用 dtc 工具直接编译。</p>
<p>内核目录下 <code>scripts/dtc/dtc</code>
是设备树的编译工具，直接使用它的话，<strong>包含其他文件时不能使用<code>#include</code>，而必须使用<code>/incldue/</code></strong>。
编译、反编译的示例命令如下，<code>-I</code>指定输入格式，<code>-O</code>指定输出格式，<code>-o</code>指定输出文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dts -O dtb -o tmp.dtb arch/arm/boot/dts/xxx.dts // 编译 dts 为 dtb </span><br><span class="line">./scripts/dtc/dtc -I dtb -O dts -o tmp.dts arch/arm/boot/dts/xxx.dtb // 反编译 dtb 为 dts</span><br></pre></td></tr></table></figure>
<h4 id="板子启动后查看设备树">1.3.3 板子启动后查看设备树</h4>
<p>板子启动后执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /sys/firmware/ </span><br></pre></td></tr></table></figure>
<p>在该目录下有目录 <code>devicetree</code> 和文件 <code>fdt</code>
，下面分别对二者进行介绍</p>
<h5 id="目录devicetree">（1）目录<code>devicetree</code></h5>
<p><code>/sys/firmware/devicetree</code>
目录下是以目录结构呈现的dtb文件，根节点对应 base
目录，每一个节点对应一个目录，每一个属性对应一个文件。</p>
<p><strong>这些属性的值如果是字符串，可以使用 cat
命令把它打印出来；对于数值， 可以用 hexdump 把它打印出来。</strong></p>
<p>例如 <code>dts</code>中存在以下节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">krocz_led_test&#123;</span><br><span class="line">	led_test_resource = &quot;LED1&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后在
<code>sys/firmware/devicetree/base/krocz_led_test</code>目录下有：</p>
<figure>
<img src="../images/使用设备树的LED驱动框架/image-20231222200900705.png"
alt="image-20231222200900705" />
<figcaption aria-hidden="true">image-20231222200900705</figcaption>
</figure>
<ul>
<li><code>cat name</code> 显示字符串"krocz_led_test"</li>
<li><code>cat led_test_resource</code> 显示字符串"LED1"</li>
</ul>
<h5 id="文件fdt">（2）文件<code>fdt</code></h5>
<p><code>/sys/firmware/fdt</code> 文件，是 <code>dtb</code>
格式的设备树文件，可以把它复制出来放到 ubuntu
上，使用dtc编译器，执行下面的命令反编译为 <code>dts</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dtb -O dts /目录/fdt -o tmp.dts</span><br></pre></td></tr></table></figure>
<h3 id="内核对设备树的处理">1.4 内核对设备树的处理</h3>
<p>从源代码文件 dts 文件开始，设备树的处理过程为：</p>
<figure>
<img src="../images/使用设备树的LED驱动框架/image-20231222202559378.png"
alt="image-20231222202559378" />
<figcaption aria-hidden="true">image-20231222202559378</figcaption>
</figure>
<ol type="1">
<li>dts 在 PC 机上被编译为 dtb 文件；</li>
<li>u-boot 把 dtb 文件传给内核；</li>
<li>内核解析 dtb 文件，把每一个节点都转换为 device_node 结构体；</li>
<li>对于某些 device_node 结构体，会被转换为 platform_device
结构体。</li>
</ol>
<h4 id="dtb-中的每个节点都会被转换-device_node-结构体">1.4.1 dtb
中的每个节点都会被转换 device_node 结构体</h4>
<p>device_node结构体表示每一个节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *type;</span><br><span class="line">	phandle phandle;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *full_name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">property</span> *<span class="title">properties</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">property</span> *<span class="title">deadprops</span>;</span>	<span class="comment">/* removed properties */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">device_node</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">device_node</span> *<span class="title">sibling</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _flags;</span><br><span class="line">	<span class="type">void</span>	*data;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path_component_name;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unique_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>device_node</code>
结构体通过以下三个成员来表示设备树中节点的关系：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span>  <span class="comment">/* 指向父亲节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span>   <span class="comment">/* 指向第一个孩子节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">sibling</span>;</span> <span class="comment">/* 指向同级别的下一个节点 */</span></span><br></pre></td></tr></table></figure>
<p>例如一个设备树节点结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \</span><br><span class="line">D   E</span><br></pre></td></tr></table></figure>
<p>在这个例子中，节点 A 的 <code>child</code> 指向 B，节点 B 的
<code>sibling</code> 指向 C，节点 B 的 <code>child</code> 指向 D，节点 D
的 <code>sibling</code> 指向 E。这样，就可以通过 <code>child</code> 和
<code>sibling</code>
字段在设备树中表示节点之间的关系，包括一个节点有多个孩子的情况。</p>
<p><strong>根节点被保存在全局变量 of_root 中，从 of_root
开始可以访问到任意节 点。</strong></p>
<p>节点中属性成员：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>	<span class="title">property</span> *<span class="title">properties</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>	<span class="title">property</span> *<span class="title">deadprops</span>;</span>	<span class="comment">/* removed properties */</span></span><br></pre></td></tr></table></figure>
<p><code>properties</code>成员指向一个链表，表示当前节点的属性列表。这个链表中的每个节点都是一个属性，包含键（name）和值（value）</p>
<p><code>deadprops</code>成员用于表示已被移除（removed）的属性。当设备树中的节点属性被修改或删除时，原有的属性可能会被移动到
<code>deadprops</code>
链表中，以便记录这些已经被移除的属性。这样设计的一个原因是为了在设备树的修改过程中能够追踪先前的属性信息，即便这些属性已经被删除或修改。通过保留这些“死去”的属性，系统可以在需要时回溯到先前的状态，或者进行一些历史记录和调试。</p>
<p>成员 name 和 type对应已经过时废弃的属性 name 和
device_type。节点的其他属性使用结构体<code>property</code>表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>	*name;</span><br><span class="line">	<span class="type">int</span>	length;</span><br><span class="line">	<span class="type">void</span>	*value;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unique_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="哪些-device_node-会被转换为-platform_device">1.4.2 哪些
device_node 会被转换为 platform_device</h4>
<ol type="1">
<li><p>根节点下含有 compatile 属性的<strong>子节点</strong></p></li>
<li><p>含有特定 compatile 属性的<strong>节点的子节点</strong></p>
<p>如果一个节点的 compatile 属性，它的值包括这 4
者之一：<code>simple-bus</code>，<code>simple-mfd</code>，<code>isa</code>，<code>arm,amba-bus</code>，那么它的子结点(
<strong>需含 compatile 属性</strong>)也可以转换为
platform_device。</p></li>
<li><p>总线 I2C、SPI 节点下的子节点：<strong>不转换</strong>为
platform_device</p>
<p>某个总线下到子节点，应该交给对应的总线驱动程序来处理,
它们不应该被转换为 platform_device。</p></li>
</ol>
<p>例如以下<code>dts</code>文件，每个节点是否会转换为platform_device如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    mytest&#123;                                   <span class="comment">// √</span></span><br><span class="line">        compatile = <span class="string">&quot;mytest&quot;</span>, <span class="string">&quot;simple-bus&quot;</span></span><br><span class="line">		mytest@<span class="number">0</span>&#123;                             <span class="comment">// √</span></span><br><span class="line">            compatile = <span class="string">&quot;mytest_0&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    i2c&#123;                                      <span class="comment">// √</span></span><br><span class="line">        compatile = <span class="string">&quot;samsung,i2c&quot;</span>;</span><br><span class="line">        at24c02&#123;                              <span class="comment">// ×</span></span><br><span class="line">            compatile = <span class="string">&quot;at24c02&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    spi&#123;                                      <span class="comment">// √</span></span><br><span class="line">        compatile = <span class="string">&quot;samsung,spi&quot;</span>;</span><br><span class="line">        flash@<span class="number">0</span>&#123;                              <span class="comment">// ×</span></span><br><span class="line">            compatible = <span class="string">&quot;winbond,w25q32dw&quot;</span>;</span><br><span class="line">            spi-max-frequency = &lt;<span class="number">25000000</span>&gt;;</span><br><span class="line">            reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="device_node-怎么转为-platform_device">1.4.3 device_node 怎么转为
platform_device</h4>
<ul>
<li><code>platform_device</code> 中含有 <code>resource</code>
数组，它来自 <code>device_node</code> 的 <code>reg\interrupts</code>
属性；</li>
<li><code>platform_device.dev.of_node</code> 指向
<code>struct device_node</code>，可以通过该指针来获取<code>of_node-&gt;property</code>
从而获取设备节点中自定义的其他属性。</li>
</ul>
<h3 id="完善-platform_device-与-platform_driver-匹配过程">1.5 完善
platform_device 与 platform_driver 匹配过程</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">platform_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> =</span> to_platform_device(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">pdrv</span> =</span> to_platform_driver(drv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class="line">	<span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line">		<span class="keyword">return</span> !<span class="built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt an OF style match first */</span></span><br><span class="line">	<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then try ACPI style match */</span></span><br><span class="line">	<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then try to match against the id table */</span></span><br><span class="line">	<span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最先比较是否强制选择某个driver">1.5.1
最先比较：是否强制选择某个driver</h4>
<p>最先比较 <code>platform_device.driver_override</code> 和
<code>platform_driver.driver.name</code></p>
<h4 id="然后比较设备树信息">1.5.2 然后比较：设备树信息</h4>
<p>比较 <code>platform_device.dev.of_node</code> 和
<code>platform_driver.driver.of_match_table</code></p>
<figure>
<img src="../images/使用设备树的LED驱动框架/image-20231223160427435.png"
alt="image-20231223160427435" />
<figcaption aria-hidden="true">image-20231223160427435</figcaption>
</figure>
<ol type="1">
<li>如果 of_match_table 中含有 compatible 值，就跟 dev 的 compatile
属性比较，若一致则成功，否则返回失败；</li>
<li>如果 of_match_table 中含有 type 值，就跟 dev 的 device_type 属性
比较，若一致则成功，否则返回失败；</li>
<li>如果 of_match_table 中含有 name 值，就跟 dev 的 name 属性比
较，若一致则成功，否则返回失败。</li>
</ol>
<p><strong>而设备树中建议不再使用 devcie_type 和 name
属性</strong>，所以基本上只使用设备节点的 compatible 属性来寻找匹配的
platform_driver。</p>
<h4 id="接下来比较-platform_device_id">1.5.3 接下来比较：
platform_device_id</h4>
<p>比较 platform_device.name 和 platform_driver.id_table[i].name，
id_table 中可能有多项。</p>
<p>platform_driver.id_table 表示该 drv 支持若干个
device，它里面列出了各个 device 的<code>&#123;.name, .driver_data&#125;</code>，
其中的 name表示该 drv 支持的设备的名字，driver_data 是些提供给该 device
的私有数据。</p>
<h4 id="最后比较name">1.5.4 最后比较：name</h4>
<p>platform_driver.id_table 可能为空， 这时可以根据
platform_driver.driver.name 和 platform_device.name 是否匹配进行比较</p>
<h4 id="匹配过程总结">1.5.5 匹配过程总结：</h4>
<figure>
<img src="../images/使用设备树的LED驱动框架/image-20231223153849297.png"
alt="image-20231223153849297" />
<figcaption aria-hidden="true">image-20231223153849297</figcaption>
</figure>
<h2 id="led驱动程序改造设备树">2. LED驱动程序改造：设备树</h2>
<p><img
src="../images/使用设备树的LED驱动框架/使用设备树的通用驱动框架.png" /></p>
<p>上图是使用设备树的通用驱动框架：</p>
<ul>
<li>开发板的硬件资源使用 board_devicetree.dts 文件描述</li>
<li>chip_drv.c
实现针对某一款主控芯片的硬件操作结构体和平台驱动结构体</li>
<li>universal_drv.c 是兼容所有开发板的通用驱动程序</li>
<li>app_test.c 是应用层的硬件测试程序</li>
</ul>
<p>使用该驱动框架，<strong>实现了通用驱动程序和主控芯片的解耦，主控芯片和开发板的解耦，避免了大量重复的开发板硬件描述文件充斥内核</strong>。</p>
<h3 id="代码">2.1 代码</h3>
<h4 id="设备树-1">2.1.1 设备树</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define GROUP_PIN(g,p) ((g&lt;&lt;16) | (p))</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">	krocz_led@0 &#123;</span><br><span class="line">		compatible = &quot;krocz,leddrv&quot;;</span><br><span class="line">		pin = &lt;GROUP_PIN(1, 1)&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	krocz_led@1 &#123;</span><br><span class="line">		compatible = &quot;krocz,leddrv&quot;;</span><br><span class="line">		pin = &lt;GROUP_PIN(5, 3)&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在开发板的设备树文件中添加两个节点，用于实验。</p>
<h4 id="芯片层">2.1.2 芯片层</h4>
<p><strong>IMX6ULL芯片操作LED的结构体</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_led_init</span><span class="params">(<span class="type">int</span> which)</span>&#123;&#125; <span class="comment">/* 初始化LED, which-哪个LED */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_led_ctl</span><span class="params">(<span class="type">int</span> which, <span class="type">char</span> status)</span>&#123;&#125; <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_led_close</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_board_led_num</span><span class="params">(<span class="type">void</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> <span class="title">chip_imx6ll_led_opr</span> =</span> &#123;</span><br><span class="line">    .init = chip_led_init,</span><br><span class="line">    .ctl = chip_led_ctl,</span><br><span class="line">    .close = chip_led_close,</span><br><span class="line">    .get_led_num = get_board_led_num,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>操作函数具体内容和“LED驱动程序框架”中对应章节中的代码类似，这里就不放了，都是操作寄存器的繁琐代码。</p>
<p><strong>IMX6ULL芯片的LED驱动结构体</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> led_pin;</span><br><span class="line"></span><br><span class="line">    np = pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="keyword">if</span> (!np)   <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">// platform_device 不一定是由device_node转换而来的，of_node可能为空因此需要判断</span></span><br><span class="line"></span><br><span class="line">    err = of_property_read_u32(np, <span class="string">&quot;pin&quot;</span>, &amp;led_pin);</span><br><span class="line">    g_ledpins[g_ledcnt] = led_pin;</span><br><span class="line">    led_class_create_device(g_ledcnt);  <span class="comment">// 创建设备文件</span></span><br><span class="line">    g_ledcnt++;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line">    <span class="type">int</span> led_pin;</span><br><span class="line"></span><br><span class="line">    np = pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="keyword">if</span> (!np)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    err = of_property_read_u32(np, <span class="string">&quot;pin&quot;</span>, &amp;led_pin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_ledcnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_ledpins[i] == led_pin)</span><br><span class="line">        &#123;</span><br><span class="line">            led_class_destroy_device(i);  <span class="comment">//销毁设备文件</span></span><br><span class="line">            <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; g_ledcnt; j++)</span><br><span class="line">                g_ledpins[j - <span class="number">1</span>] = g_ledpins[j];</span><br><span class="line">            g_ledcnt --;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">krocz_leds</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;krocz,leddrv&quot;</span> &#125;,  <span class="comment">//通过该属性与platform_device进行匹配</span></span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">chip_imx6ull_gpio_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = chip_demo_gpio_probe,</span><br><span class="line">    .remove     = chip_demo_gpio_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;krocz_led_drv&quot;</span>,</span><br><span class="line">        .of_match_table = krocz_leds,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 platform_driver 结构体中制定了和
platform_device匹配时的初始化函数(probe)，以及解绑时的去初始化函数(remove)；通过
of_device_id 结构体指定了该驱动所支持的设备。</p>
<p><strong>最后就是必须的内核模块安装/卸载函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chip_demo_gpio_drv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    </span><br><span class="line">    err = platform_driver_register(&amp;chip_imx6ull_gpio_driver); </span><br><span class="line">    register_led_operations(&amp;chip_imx6ll_led_opr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">lchip_demo_gpio_drv_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_unregister(&amp;chip_imx6ull_gpio_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chip_demo_gpio_drv_init);</span><br><span class="line">module_exit(lchip_demo_gpio_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>主要执行 platform_driver 的总线注册和删除</p>
<h4 id="通用led驱动">2.1.3 通用LED驱动</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">led_class_create_device</span><span class="params">(<span class="type">int</span> minor)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_create(led_class, <span class="literal">NULL</span>, MKDEV(major, minor), <span class="literal">NULL</span>, <span class="string">&quot;100ask_led%d&quot;</span>, minor); <span class="comment">/* /dev/krocz_led0,1,... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_destroy_device</span><span class="params">(<span class="type">int</span> minor)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(led_class, MKDEV(major, minor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_led_operations</span><span class="params">(<span class="keyword">struct</span> led_operations *opr)</span></span><br><span class="line">&#123;</span><br><span class="line">	p_led_opr = opr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(led_class_create_device);</span><br><span class="line">EXPORT_SYMBOL(led_class_destroy_device);</span><br><span class="line">EXPORT_SYMBOL(register_led_operations);</span><br></pre></td></tr></table></figure>
<p>该程序和”LED驱动程序框架“对应章节中的程序相比变化不大。由于设备文件应该在
platform_driver 和 platform_deivce
匹配/删除时动态的创建或销毁，所以将设备文件的创建和销毁作为函数提供给下层驱动程序进行调用（<strong>使用EXPORT_SYMBOL宏修饰函数，使其在其他内核模块中可以被调用</strong>）。</p>
<h3 id="测试">2.2 测试</h3>
<h4 id="编译安装">2.2.1 编译、安装</h4>
<ol type="1">
<li>参考1.3节“编译、更换设备树”，为开发板更换设备树文件</li>
</ol>
<p>更换安装完成之后，可以在<code>/sys/firmware/devicetree/base</code>目录下查看设备树节点（device_node）：</p>
<figure>
<img src="../images/使用设备树的LED驱动框架/image-20240102112542082.png"
alt="image-20240102112542082" />
<figcaption aria-hidden="true">image-20240102112542082</figcaption>
</figure>
<p>还可以在<code>/sys/bus/platform/devices/</code>目录下查看所有的
platform_device 节点，例如：</p>
<figure>
<img src="../images/使用设备树的LED驱动框架/image-20240102113358690.png"
alt="image-20240102113358690" />
<figcaption aria-hidden="true">image-20240102113358690</figcaption>
</figure>
<p>程序中 platform_device 和 platform_driver 使用 compatible
属性进行匹配，当匹配成功之后，platform_device
节点中就会出现指向对应驱动节点（platform_driver）的链接文件。</p>
<ol start="2" type="1">
<li>编译内核模块并安装内核模块。</li>
</ol>
<p>在<code>/sys/bus/platform/drivers/</code>目录下查看所有的
platform_driver 节点，例如：</p>
<figure>
<img src="../images/使用设备树的LED驱动框架/image-20240102114920931.png"
alt="image-20240102114920931" />
<figcaption aria-hidden="true">image-20240102114920931</figcaption>
</figure>
<p>虽然我也不知道为什么 driver 匹配的 device 会链接到
<code>/sys/devices/soc0/krocz_led@0</code>上</p>
<p>同时，在安装内核模块<code>chip_imx6ull_gpio.ko</code>时，会在和
platform_device
匹配之后，创建一个设备文件，在目录<code>/dev/</code>下：</p>
<figure>
<img src="../images/使用设备树的LED驱动框架/image-20240102115755062.png"
alt="image-20240102115755062" />
<figcaption aria-hidden="true">image-20240102115755062</figcaption>
</figure>
<ol start="3" type="1">
<li>运行APP进行测试</li>
</ol>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程编程</title>
    <url>/2023/10/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="线程的标识-pthread_t">1. 线程的标识 pthread_t</h2>
<p>对于每一个进程都有唯一PID号与之对应，而对于线程而言，也有类似的tid号，即一个pthread_t类型的变量。线程号是表示线程的唯一标识，<strong>但是对于线程号而言，其仅仅在其所属的进程上下文中才有意义。</strong></p>
<p>获取当前线程的线程号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="线程的创建">2. 线程的创建</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,<span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数第一个参数为 pthread_t 指针，用来保存新建线程的线程号；</li>
<li>第二个参数表示了线程的属性，一般传入 NULL 表示默认属性；</li>
<li>第三个参数是一个函数指针，就是线程执行的函数。这个函数返回值为
void*， 形参为 void*。</li>
<li>第四个参数则表示为向线程处理函数传入的参数，若不传入，可用 NULL
填充</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">my_thread_func</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pthread_New = %lu\n&quot;</span>,(<span class="type">unsigned</span> <span class="type">long</span>)pthread_self());<span class="comment">//打印线程的 tid 号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> iRet;</span><br><span class="line"></span><br><span class="line">    iRet = pthread_create(&amp;tid, <span class="literal">NULL</span>, my_thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(iRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create err!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid_main = %lu tid_new = %lu \n&quot;</span>,(<span class="type">unsigned</span> <span class="type">long</span>)pthread_self(),(<span class="type">unsigned</span> <span class="type">long</span>)tid);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分配资源是以进程为单位的，调度是以线程为单位的</strong>，上述代码中主线程和创建出的线程执行的顺序是随机调度的</p>
<h3 id="向线程传入参数">2.1 向线程传入参数</h3>
<h4 id="值传递和地址传递">2.1.1 值传递和地址传递</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">func1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:a = %d Addr = %p \n&quot;</span>, __FUNCTION__, *(<span class="type">int</span> *)arg, arg);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">func2</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:a = %ld Addr = %p \n&quot;</span>, __FUNCTION__, (<span class="type">long</span>)arg, arg);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, iRet;</span><br><span class="line">    iRet = pthread_create(&amp;tid1, <span class="literal">NULL</span>, func1, (<span class="type">void</span> *)&amp;a);</span><br><span class="line">    <span class="keyword">if</span>(iRet != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: pthread_create\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iRet = pthread_create(&amp;tid2, <span class="literal">NULL</span>, func2, (<span class="type">void</span> *)(<span class="type">long</span>)a);</span><br><span class="line">    <span class="keyword">if</span>(iRet != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: pthread_create\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        a++;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:a = %d Addr = %p \n&quot;</span>, __FUNCTION__, a, &amp;a);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>func1对应地址传递，比较常用好理解</li>
<li>func2对应值传递：
<ul>
<li><code>pthread_create(&amp;tid2, NULL, func2, (void *)(long)a);</code>：先将a转成long类型(8byte)，则指针<code>void *arg</code>的值为<code>a=5</code>，即指针指向地址5</li>
<li><code>printf("%s:a = %d Addr = %p \n", __FUNCTION__, (int)(long)arg, arg);</code>：指针转换为long类型，值为5。</li>
</ul></li>
</ul>
<p>因此，不难理解，部分输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func1:a = 5 Addr = 0x7fff2dcd2eb0 </span><br><span class="line">func2:a = 5 Addr = 0x5 </span><br><span class="line">main:a = 6 Addr = 0x7fff2dcd2eb0 </span><br><span class="line">func1:a = 7 Addr = 0x7fff2dcd2eb0 </span><br><span class="line">func2:a = 5 Addr = 0x5 </span><br></pre></td></tr></table></figure>
<h4 id="多参数结构体传递">2.2.2 多参数/结构体传递</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> iId;</span><br><span class="line">    <span class="type">char</span> cName[<span class="number">32</span>];</span><br><span class="line">    <span class="type">float</span> fMark;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">func1</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> *<span class="title">tmp</span> =</span> (<span class="keyword">struct</span> Stu*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s:Id = %d Name = %s Mark = %.2f\n&quot;</span>, __FUNCTION__, tmp-&gt;iId, tmp-&gt;cName, tmp-&gt;fMark);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> iRet;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> <span class="title">stu</span> =</span> &#123;<span class="number">1000</span>, <span class="string">&quot;lili&quot;</span>, <span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    iRet = pthread_create(&amp;tid, <span class="literal">NULL</span>, func1, (<span class="type">void</span> *)&amp;stu);</span><br><span class="line">    <span class="keyword">if</span>(iRet != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: pthread_create\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s:Id = %d Name = %s Mark = %.2f\n&quot;</span>, __FUNCTION__, stu.iId, stu.cName, stu.fMark);</span><br><span class="line">    sleep(<span class="number">1</span>);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程的退出与回收">3. 线程的退出与回收</h2>
<p>线程的退出情况有三种：</p>
<ol type="1">
<li><p>第一种是进程结束，进程中所有的线程也会随之结束。</p></li>
<li><p>第二种是通过函数 <code>pthread_exit</code>
来主动的退出线程。</p></li>
<li><p>第三种被其他线程调用 <code>pthread_cancel</code>
来被动退出。</p></li>
</ol>
<p>当线程结束后，主线程可以通过函数
<code>pthread_join/pthread_tryjoin_np</code>
来回收线程的资源，并且获得线程结束后需要返回的数据。</p>
<h3 id="线程退出">3.1 线程退出</h3>
<h5 id="线程主动退出">(1) 线程主动退出</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_exit</code> 函数为线程退出函数，在退出时候可以传递一个
void*类型的数据带给主线程，若选择不传出数据，可将参数填充为 NULL。</p>
<h5 id="线程被动退出">(2) 线程被动退出</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数传入一个 tid 号，会强制退出该 tid
所指向的线程，若成功执行会返回 0。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pthread:1 Come !\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pthread:2 Come !\n&quot;</span>);</span><br><span class="line">    pthread_cancel((<span class="type">pthread_t</span>)arg);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> i, iRet, flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iRet = pthread_create(&amp;tid[<span class="number">0</span>], <span class="literal">NULL</span>, func1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(iRet)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iRet = pthread_create(&amp;tid[<span class="number">1</span>], <span class="literal">NULL</span>, func2, (<span class="type">void</span> *)tid[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(iRet)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(pthread_tryjoin_np(tid[i], <span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Pthread:%d back !\n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">2</span>)  <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个的线程执行死循环睡眠逻辑，理论上除非进程结束，其永远不会结束，但在第二个线程中调用了
<code>pthread_cancel</code>
函数，相当于向该线程发送一个退出的指令，导致线程被退出，最终资源被非阻塞回收掉。</p>
<h3 id="线程资源回收">3.2 线程资源回收</h3>
<h5 id="线程资源回收阻塞方式">(1) 线程资源回收(阻塞方式)</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数为线程回收函数，默认状态为阻塞状态，直到成功回收线程后才返回。第一个参数为要回收线程的
tid 号，第二个参数为线程回收后接受线程传出的数据。</p>
<h5 id="线程资源回收非阻塞方式">(2) 线程资源回收(非阻塞方式)</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_tryjoin_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数为非阻塞模式回收函数，通过返回值判断是否回收掉线程，成功回收则返回
0，其余参数与 pthread_join 一致。</p>
<h4 id="示例代码">3.2.3 示例代码</h4>
<h5 id="示例代码1">(1) 示例代码1：</h5>
<p>通过阻塞方式回收线程资源</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s:a = %d Addr = %p \n&quot;</span>, __FUNCTION__, *(<span class="type">int</span> *)arg, arg);</span><br><span class="line">    tmp =  *(<span class="type">int</span> *) arg + <span class="number">100</span>;</span><br><span class="line">    pthread_exit((<span class="type">void</span> *) &amp;tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> iRet, a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">void</span> *vTmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    iRet = pthread_create(&amp;tid, <span class="literal">NULL</span>, func1, (<span class="type">void</span> *)&amp;a);</span><br><span class="line">    <span class="keyword">if</span>(iRet)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, &amp;vTmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s:Addr = %p Val = %d\n&quot;</span>,__FUNCTION__,vTmp,*(<span class="type">int</span> *)vTmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="示例代码2">(2) 示例代码2：</h5>
<p>通过非阻塞方式回收线程资源</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pthread:%ld Come !\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    pthread_exit(arg);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> i, iRet, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span> *vTmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        iRet = pthread_create(&amp;tid[i - <span class="number">1</span>], <span class="literal">NULL</span>, func1, (<span class="type">void</span> *)(<span class="type">long</span>)i);</span><br><span class="line">        <span class="keyword">if</span>(iRet)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pthread_tryjoin_np(tid[i - <span class="number">1</span>], &amp;vTmp) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Pthread:%ld back !\n&quot;</span>, (<span class="type">long</span>)vTmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过阻塞方式回收线程几乎规定了线程回收的顺序，若最先回收的线程未退出，则一直会被阻塞，导致后续先退出的线程无法及时的回收。</p>
<p>通过函数
<code>pthread_tryjoin_np</code>，使用非阻塞回收，线程可以根据退出先后顺序及时进行资源的回收。</p>
<h2 id="线程的控制">4. 线程的控制</h2>
<h3 id="互斥锁">4.1 互斥锁</h3>
<p>多个线程都要访问某个临界资源，比如某个全局变量时，需要互斥地进行访问。</p>
<h5 id="初始化互斥量">(1) 初始化互斥量</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">phtread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是改互斥量指针，第二个参数为控制互斥量的属性，一般为
NULL。当函数成功后会返回 0，代表初始化互斥量成功。</p>
<p>互斥量的初始化也可以调用宏快速初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITALIZER;</span><br></pre></td></tr></table></figure>
<h5 id="互斥量加锁解锁">(2) 互斥量加锁/解锁</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;     <span class="comment">//阻塞方式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;  <span class="comment">//非阻塞方式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>
<p>成功后会返回 0。当某一个线程获得了执行权后，执行 lock
函数，一旦加锁成功后，其余线程遇到 lock
函数时候会发生阻塞，直至获取资源的线程执行 unlock 函数后。 unlock
函数会唤醒其他正在等待互斥量的线程。</p>
<h5 id="销毁互斥量">(3) 销毁互斥量</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>
<p>成功后会返回 0。</p>
<h4 id="示例">4.1.1 示例</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;  <span class="comment">// 互斥量一般申请全局变量</span></span><br><span class="line"><span class="type">int</span> iNum;               <span class="comment">// 临界变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(iNum &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iNum++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:iNum = %d \n&quot;</span>, __FUNCTION__, iNum);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> i, iRet;</span><br><span class="line"></span><br><span class="line">    iRet = pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(iRet != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_mutex_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iRet = pthread_create(&amp;tid, <span class="literal">NULL</span>, func1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(iRet)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    <span class="keyword">while</span>(iNum &gt; <span class="number">-3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iNum--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s:iNum = %d \n&quot;</span>, __FUNCTION__, iNum);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);        <span class="comment">// 回收线程</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);  <span class="comment">// 销毁互斥量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="信号量">4.2 信号量</h3>
<p>信号量跟互斥量不一样，<strong>互斥量用来防止多个线程同时访问某个临界资源</strong>。<strong>信号量起通知作用</strong>，线程
A 在等待某件事，线程 B 完成了这件事后就可以给线程 A 发信号</p>
<h5 id="初始化信号量">(1) 初始化信号量</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem,<span class="type">int</span> pshared,<span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数可以初始化一个信号量，第一个参数传入 sem_t 类型指针；</li>
<li>第二个参数传入 0 代表线程控制，否则为进程控制；</li>
<li>第三个参数表示信号量的初始值，0
表示没有资源，正数表示资源的个数，不允许为负数。</li>
<li>待初始化结束信号量后，若执行成功会返回 0。</li>
</ul>
<h5 id="信号量pv操作">(2) 信号量PV操作</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;      <span class="comment">// 阻塞方式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;   <span class="comment">// 非阻塞方式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sem_wait</code>
函数作用为检测指定信号量是否有资源可用，若无资源可用会阻塞等待，若有资源可用会自动的执行"sem-1"的操作。所谓的"sem-1"是与上述初始化函数中第三个参数值一致，成功执行会返回
0</li>
<li><code>sem_trywait</code>：此函数是信号量申请资源的非阻塞函数，功能与
sem_wait 一致。</li>
<li><code>sem_post</code> 函数会释放指定信号量的资源，执行"sem+1"操作。
通过以上 2 个函数可以完成所谓的 PV 操作，即信号量的申请与释放，完成
对线程执行顺序的控制。</li>
</ul>
<h5 id="信号量销毁">(3) 信号量销毁</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_destory</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数为信号量销毁函数，执行过后可将信号量进行销毁。成功时返回0。</p>
<h4 id="示例代码-1">4.2.1 示例代码</h4>
<p>通过加入信号量，使得线程的执行顺序变得可控。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> sem[<span class="number">3</span>];</span><br><span class="line"><span class="type">void</span>* <span class="title function_">func1</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sem[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s executed\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    sem_post(&amp;sem[<span class="number">1</span>]);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sem[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s executed\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    sem_post(&amp;sem[<span class="number">2</span>]);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func3</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sem[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s executed\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> i, iRet, flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;sem[<span class="number">0</span>], <span class="number">0</span>, <span class="number">1</span>);   <span class="comment">// 信号量初始化要在线程之前</span></span><br><span class="line">    sem_init(&amp;sem[<span class="number">1</span>], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem[<span class="number">2</span>], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    pthread_create(&amp;tid[<span class="number">0</span>], <span class="literal">NULL</span>, func1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid[<span class="number">1</span>], <span class="literal">NULL</span>, func2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid[<span class="number">2</span>], <span class="literal">NULL</span>, func3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">        sem_destroy(&amp;sem[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件变量">4.3 条件变量</h3>
<p>条件变量时一种<strong>同步机制</strong>，用来通知其他线程条件满足了。一般是用来通知对方<strong>共享数据</strong>的状态信息，因此条件变量时结合互斥量来使用的。</p>
<h5 id="初始化">(1) 初始化</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_condattr_t</span> *cond_attr)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数可以初始化一个条件变量，第一个参数传入
pthread_cond_t类型指针；</li>
<li>第二个参数传入控制条件变量的属性，一般为 NULL。</li>
<li>待初始化结束信号量后，若执行成功会返回 0。</li>
</ul>
<p>可以通过如下宏直接初始化条件变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER; </span><br></pre></td></tr></table></figure>
<h5 id="waitsignal">(2) wait/signal</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_cond_wait</code>函数需要结合互斥量一起使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;g_tMutex); </span><br><span class="line"><span class="comment">// 如果条件不满足则，会 unlock g_tMutex </span></span><br><span class="line"><span class="comment">// 条件满足后被唤醒，会 lock g_tMutex </span></span><br><span class="line">pthread_cond_wait(&amp;g_tConVar, &amp;g_tMutex); </span><br><span class="line"><span class="comment">/* ----- 操作临界资源 ----- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -------- End  -------- */</span></span><br><span class="line">pthread_mutex_unlock(&amp;g_tMutex);</span><br></pre></td></tr></table></figure>
<p>如果条件满足，则继续往下执行；如果条件不满足，则会释放互斥量，阻塞直到条件满足并且可以获得互斥锁时，继续往下执行。</p>
<h5 id="销毁条件变量">(3) 销毁条件变量</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure>
<p>成功时返回0。</p>
<h4 id="示例代码-2">4.3.1 示例代码</h4>
<p>在主线程中从stdin中接收输入，并在创建的线程中进行打印</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> g_buf[<span class="number">1000</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> g_tMutex  = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span>  g_tConVar = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">my_thread_func</span> <span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;g_tMutex);</span><br><span class="line">		pthread_cond_wait(&amp;g_tConVar, &amp;g_tMutex);	</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;recv: %s\n&quot;</span>, g_buf);</span><br><span class="line">		pthread_mutex_unlock(&amp;g_tMutex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pthread_t</span> tid;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">1000</span>];</span><br><span class="line">	</span><br><span class="line">	ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, my_thread_func, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		fgets(buf, <span class="number">1000</span>, <span class="built_in">stdin</span>);</span><br><span class="line">		pthread_mutex_lock(&amp;g_tMutex);</span><br><span class="line">		<span class="built_in">memcpy</span>(g_buf, buf, <span class="number">1000</span>);</span><br><span class="line">		pthread_cond_signal(&amp;g_tConVar); <span class="comment">/* 通知接收线程 */</span></span><br><span class="line">		pthread_mutex_unlock(&amp;g_tMutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结">5.总结</h2>
<h3 id="线程使用流程图">5.1 线程使用流程图</h3>
<figure>
<img src="../images/多线程编程/image-20231004201228798.png"
alt="image-20231004201228798" />
<figcaption aria-hidden="true">image-20231004201228798</figcaption>
</figure>
<h3 id="互斥量使用流程图">5.2 互斥量使用流程图</h3>
<figure>
<img src="../images/多线程编程/image-20231004201303646.png"
alt="image-20231004201303646" />
<figcaption aria-hidden="true">image-20231004201303646</figcaption>
</figure>
<h3 id="信号量使用流程图">5.3 信号量使用流程图</h3>
<figure>
<img src="../images/多线程编程/image-20231004201343650.png"
alt="image-20231004201343650" />
<figcaption aria-hidden="true">image-20231004201343650</figcaption>
</figure>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6null-mini开发板</title>
    <url>/2023/09/05/%E5%BC%80%E5%8F%91%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="硬件资源简介">1.硬件资源简介</h2>
<figure>
<img src="../images/开发板/image-20230905203618081.png"
alt="image-20230905203618081" />
<figcaption aria-hidden="true">image-20230905203618081</figcaption>
</figure>
<figure>
<img src="../images/开发板/image-20230905204358901.png"
alt="image-20230905204358901" />
<figcaption aria-hidden="true">image-20230905204358901</figcaption>
</figure>
<h2 id="启动方式">2. 启动方式</h2>
<figure>
<img src="../images/开发板/image-20230905204619465.png"
alt="image-20230905204619465" />
<figcaption aria-hidden="true">image-20230905204619465</figcaption>
</figure>
<h2 id="开发板挂载ubuntu的nfs目录">3. 开发板挂载Ubuntu的NFS目录</h2>
<h3 id="network-file-systemnfs">3.1 Network File System(NFS)</h3>
<p>NFS协议基于C/S架构，通过RPC协议进行通信。NFS的最大特点就是将服务端的文件系统目录树映射到客户端，而在客户端访问该
目录树与访问本地文件系统没有任何差别。</p>
<figure>
<img src="../images/开发板/image-20230905205227025.png"
alt="image-20230905205227025" />
<figcaption aria-hidden="true">image-20230905205227025</figcaption>
</figure>
<h3 id="挂载">3.2 挂载</h3>
<ol type="1">
<li><p>Ubuntu开放相关目录的访问权限，即配置
<code>/etc/exports</code>文件</p></li>
<li><p>Ubuntu启动NFS服务</p></li>
<li><p>开发板上挂载Ubuntu上的相关目录到本地</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t nfs -o nolock,vers=3 192.168.5.11:/home/book/nfs_rootfs /mnt</span><br></pre></td></tr></table></figure>
<ul>
<li><code>mount</code>: 这个命令用于挂载文件系统到指定的目录上。</li>
<li><code>-t nfs</code>: 该选项指定要挂载的文件系统类型为NFS。</li>
<li><code>-o nolock,vers=3</code>:
这些选项是用于指定挂载NFS文件系统时的一些选项。<code>nolock</code>选项用于禁用文件锁定机制，而<code>vers=3</code>选项指定使用NFS版本3协议。</li>
</ul></li>
</ol>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>异常和中断</title>
    <url>/2024/01/05/%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h2 id="异常和中断">1.异常和中断</h2>
<h3 id="异常和中断的概念">1.1 异常和中断的概念</h3>
<p>异常不可屏蔽，中断可以屏蔽，中断一种特殊的异常。</p>
<figure>
<img src="../images/异常和中断/image-20240105105633741.png"
alt="image-20240105105633741" />
<figcaption aria-hidden="true">image-20240105105633741</figcaption>
</figure>
<ol type="1">
<li>初始化，设置中断源（设置中断源、设置中断控制器、使能CPU总开关）</li>
<li>执行程序</li>
<li>产生中断：中断源 -&gt; 中断控制器 -&gt; CPU</li>
<li>CPU每执行完一条指令，都会检查有无中断/异常产生</li>
<li>CPU发现有中断/异常产生，开始处理</li>
<li>对于不同的异常，跳去不同的地址执行指令（中断向量表），这些指令只是一条跳转指令，跳去执行某个函数</li>
<li>处理函数：保存现场，<strong>分辨中断源并调用相应的处理函数</strong>，恢复现场</li>
</ol>
<h3 id="异常向量表">1.2 异常向量表</h3>
<p>u-boot 或是 Linux 内核，都有类似如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_start: b reset </span><br><span class="line">	ldr pc, _undefined_instruction </span><br><span class="line">	ldr pc, _software_interrupt </span><br><span class="line">	ldr pc, _prefetch_abort </span><br><span class="line">	ldr pc, _data_abort </span><br><span class="line">	ldr pc, _not_used </span><br><span class="line">	ldr pc, _irq           //发生中断时，CPU 跳到这个地址执行该指令 **假设地址为 0x18** </span><br><span class="line">	ldr pc, _fiq</span><br></pre></td></tr></table></figure>
<p>这就是异常向量表，每一条指令对应一种异常。当发生不同的异常时，CPU会由硬件执行向量表中对应位置的指令。</p>
<p>这些指令存放的位置是固定的，比如对于 ARM9 芯片中断向量的地址是
0x18。当发生中断时，CPU 就强制跳去执行 0x18 处的代码。</p>
<p>在向量表里，一般都是放置一条跳转指令，发生该异常时，CPU
就会执行向量表中的跳转指令，去调用更复杂的函数。</p>
<p>当然，向量表的位置并不总是从 0 地址开始，很多芯片可以设置某个 vector
base 寄存器，指定向量表在其他位置，比如设置 vector base 为 0x80000000，
指定为 DDR
的某个地址。但是<strong>表中的各个异常向量的偏移地址是固定的</strong>：复位向量偏移地址是
0，中断是 0x18。</p>
<blockquote>
<p>对于 ARM 的中断控制器，称为 GIC (Generic Interrupt
Controller)，到目前已经更新到 v4 版本了。</p>
<p>各个版本的差别可以看这里：https://developer.arm.com/ip-products/system-ip/systemcontrollers/interrupt-controllers</p>
<p>简单地说，GIC v3/v4 用于 ARMv8 架构，即 64 位 ARM 芯片。 而 GIC v2
用于 ARMv7 和其他更低的架构。</p>
</blockquote>
<p>## 2. Linux 对于中断的处理</p>
<p><strong>(1) 进程/线程/中断的核心：栈</strong></p>
<p>当 Linux
在执行进程、线程的切换或者中断函数的处理时，需要保护现场，也就是将CPU内寄存器的值先保存在内存中，将寄存器的空间“腾”出来给待执行程序用。而保存现场这部分内存就是栈结构。</p>
<p><strong>(2) 进程/线程的概念</strong></p>
<ul>
<li><p>进程的引入：为例实现程序的并发执行</p></li>
<li><p>线程的引入：进程之间传递资源消耗过大，而一个进程内的多个线程可以共享资源（如全局变量）。</p></li>
<li><p>进程是资源分配的单位，线程是调度的单位，所以每一个线程都有自己的“栈”，以便在调度时保存/恢复现场。</p></li>
</ul>
<h3 id="linux-中断的演进">2.1 Linux 中断的演进</h3>
<h4 id="硬件中断和软件中断">2.1.1 硬件中断和软件中断</h4>
<p>硬件中断我们比较熟悉，由硬件本身产生中断信号触发，执行对应的处理函数。而软件中断是一种灵活的，人为的制造中断。</p>
<h5 id="硬件中断">（1）硬件中断</h5>
<p>对于硬件中断，触发信号由硬件产生，产生之后会尽快被处理。Linux系统对于硬件中断的处理原则：<strong>硬件中断不能嵌套，并且硬件中断的处理越快越好</strong>。</p>
<p>不能嵌套是为了防止突发的大量中断将栈空间耗尽。</p>
<p>在中断的处理过程中，CPU
是不能进行进程调度的，所以中断的处理要越快越好，尽早让其他中断能被处理，例如进程调度靠定时器中断来实现。</p>
<p>在 Linux 为某一虚拟中断号 irq 配置处理函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check </span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure>
<p>虚拟中断号 irq 的处理函数 handler
的代码尽可能高效，耗时越短越好。</p>
<blockquote>
<p>为什么是虚拟中断号，后面会讲（硬件中断号 hwirq ←→ irq
虚拟中断号）</p>
</blockquote>
<h5 id="软件中断">（2）软件中断</h5>
<p>而对于软件中断，需要知道软件中断的触发如何产生，以及何时进行软件中断的处理：</p>
<ol type="1">
<li>由软件来触发，对于 X 号软件中断，只需要将它的 flag 设置为 1
就表示发生了该中断。</li>
<li>软件中断不像硬件中断那样急迫，不必立刻处理；在 Linux
系统中因为各种硬件中断频发，例如定时器中断（心跳）就每 10ms
发生一次；所以在处理完硬件中断后，检查是否有软件中断被触发，如果有触发就去处理相应的软件中断。</li>
</ol>
<p>Linux
的软件中断，参见内核源码<code>include/linux/interrupt.h</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	HI_SOFTIRQ=<span class="number">0</span>,</span><br><span class="line">	TIMER_SOFTIRQ,</span><br><span class="line">	NET_TX_SOFTIRQ,</span><br><span class="line">	NET_RX_SOFTIRQ,</span><br><span class="line">	BLOCK_SOFTIRQ,</span><br><span class="line">	IRQ_POLL_SOFTIRQ,</span><br><span class="line">	TASKLET_SOFTIRQ,</span><br><span class="line">	SCHED_SOFTIRQ,</span><br><span class="line">	HRTIMER_SOFTIRQ, <span class="comment">/* Unused, but kept as tools rely on the</span></span><br><span class="line"><span class="comment">			    numbering. Sigh! */</span></span><br><span class="line">	RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">	NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>配置软件中断的处理函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span>;</span><br></pre></td></tr></table></figure>
<p>触发软件中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="耗时中断">2.1.2 耗时中断</h4>
<p>有些硬件中断不可能在短时间内处理完成，例如按键中断，需要等待几十毫秒的时间来消除抖动，不可能在硬件中断的处理函数中等待这么长的时间，使得其他硬件中断不能够及时响应，因此需要一些方法来解决此类问题。</p>
<p>可以将中断拆分成上半部和（硬件中断）下半部（软件中断是一种实现方式），在上半部中快速处理一些紧急的操作，在下半部中进行耗时的，可以被打断的操作：</p>
<figure>
<img src="../images/异常和中断/image-20240105162631985.png"
alt="image-20240105162631985" />
<figcaption aria-hidden="true">image-20240105162631985</figcaption>
</figure>
<p>主要讲两种中断下半部的处理方式：tasklet（小任务）、work queue
（工作队列）</p>
<h4 id="下半部耗时不长-tasklet">2.1.3 下半部耗时不长-tasklet</h4>
<p>当下半部比较耗时但是能忍受，并且它的处理比较简单时，可以用软件中断
tasklet 来实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TASKLET_SOFTIRQ</span><br></pre></td></tr></table></figure>
<p>通过下图中的函数调用关系，可以比较清楚的看出中断上半部和下半部的处理流程：</p>
<figure>
<img src="../images/异常和中断/image-20240105163909446.png"
alt="image-20240105163909446" />
<figcaption aria-hidden="true">image-20240105163909446</figcaption>
</figure>
<p>在上半部中，处于关中断状态，会根据硬件中断触发源来执行对应的中断处理函数；</p>
<p>如果当前<strong>没有下半部的软件中断正在执行并且有软件中断被触发</strong>，就根据
softirq_vec
数组来执行对应的软件中断处理函数（注意，<strong>多个中断的下半部是汇集在一起进行处理的</strong>，即sfotirq_vec数组中可能有多个信号被触发）。</p>
<blockquote>
<p>中断上半部、下半部的执行过程中，不能执行休眠函数：在中断中休眠的话，以后谁来调度进程啊</p>
</blockquote>
<h4 id="下半部复杂耗时长-工作队列">2.1.4 下半部复杂耗时长-工作队列</h4>
<p>在中断下半部的执行过程中，虽然是开中断的，期间可以处理各类中断。但<strong>毕竟整个中断的处理还没走完，这期间
APP
是无法执行的</strong>，因此如果下半部耗时过长，并且使用软件中断的方式实现，则
APP
在中断执行过程中将无法相应，这同样是不可接收的，因此这种情况下，下半部可以使用<strong>内核线程</strong>来实现：<strong>在中断上半部唤醒内核线程。内核线程和
APP 都 一样竞争执行，APP 有机会执行，系统不会卡顿</strong>。</p>
<p>这个内核线程是系统帮我们创建的，一般是 kworker
线程，内核中有很多这样的线程：</p>
<figure>
<img src="../images/异常和中断/image-20240105172133397.png"
alt="image-20240105172133397" />
<figcaption aria-hidden="true">image-20240105172133397</figcaption>
</figure>
<p><strong>kworker 线程要去 work queue 上取出一个一个 work，
来执行它里面的函数。</strong>使用方式如下：</p>
<ol type="1">
<li><p>创建 work，将 work 和对应的处理函数绑定：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WORK(n, f)						\</span></span><br><span class="line"><span class="meta">	struct work_struct n = __WORK_INITIALIZER(n, f)</span></span><br></pre></td></tr></table></figure>
<p>将一个 work_struct 结构体和对应的处理函数 f 绑定</p></li>
<li><p>要执行处理函数时，仅需要将 work 提交给 work queue 即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work(system_wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数会把 work 提供给系统默认的 work queue：system_wq，它是一
个队列。</p>
<p>在中断场景中，可以在中断上半部调用 schedule_work 函数。</p></li>
<li><p>schedule_work 函数不仅仅是把 work 放入队列，还会把 kworker
线程唤醒。此线程抢到时间运行时，它就会从队列中取出
work，执行里面的函数。</p></li>
</ol>
<blockquote>
<p>很耗时的中断处理，应该放到线程里去，从而防止 APP 不能够及时响应</p>
<p>既然是在线程中运行，那对应的函数可以休眠</p>
</blockquote>
<h4 id="新技术---threaded-irq">2.1.5 新技术 - threaded irq</h4>
<p>以前用 work 来线程化地处理中断，一个 worker 线程只能由一个 CPU 执行，
多个中断的 work 都由同一个 worker 线程来处理，在单 CPU
系统中没有问题，但是在SMP（Symmetric
multiprocessing）系统中，这种方式不能够完全发挥多核的性能。因此，新技术
threaded irq
干脆为每一个中断都创建一个内核线程；多个中断的内核线程可以分配到多个 CPU
上执行，这提高了效率。threaded irq 使用方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>irq：指示哪个中断</li>
<li>handler：表示中断处理的上半部函数，可以为空</li>
<li>thread_fn：表示在线程中运行的函数</li>
</ul>
<h3 id="linux-中断系统中的重要数据结构">2.2 Linux
中断系统中的重要数据结构</h3>
<p>Linux 中断系统最核心的结构体是
irq_desc，它是一个结构体数组，该结构体内通过成员 action
构建了一个链表，该数组用以记录所有硬件中断的相关数据。</p>
<figure>
<img src="../images/异常和中断/image-20240105194202446.png"
alt="image-20240105194202446" />
<figcaption aria-hidden="true">image-20240105194202446</figcaption>
</figure>
<blockquote>
<p>如果内核配置了 CONFIG_SPARSE_IRQ，那么它就会用基数树(radix tree)
来代替 irq_desc 数组。SPARSE 的意思是“稀疏”，假设大小为 1000
的数组中只用到 2
个数组项，那不是浪费嘛？所以在中断比较“稀疏”的情况下可以用基数树来代替数组。</p>
</blockquote>
<h4 id="irq_desc-数组">2.2.1 irq_desc 数组</h4>
<p>irq_desc 结构体在 <code>include/linux/irqdesc.h</code>
中定义，它的主要成员如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span> <span class="title">irq_data</span>;</span></span><br><span class="line"><span class="type">irq_flow_handler_t</span> handle_irq; </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br></pre></td></tr></table></figure>
<p>我们首先通过一个例子来理解 irq_desc 数组的整体结构：</p>
<figure>
<img src="../images/异常和中断/image-20240105200529422.png"
alt="image-20240105200529422" />
<figcaption aria-hidden="true">image-20240105200529422</figcaption>
</figure>
<p>外部设备 1、外部设备 n 共享一个 GPIO 中断 B，多个 GPIO 中断汇聚到 GIC
(Generic Interrupt Controller)的 A 号中断，GIC 再去中断
CPU。所以中断触发信号在图中一路从左向右传递到CPU。</p>
<p>当CPU收到中断触发信号之后，软件应该在图中从右到左依次询问，来定位到底是那个硬件触发了中断，具体来说：</p>
<ol type="1">
<li><p>GIC 的处理函数：</p>
<p>假设 irq_desc[A].handle_irq 是 XXX_gpio_irq_handler(XXX 指厂家)，
这个函数需要读取芯片的 GPIO 控制器，细分发生的是哪一个 GPIO 中断(假设是
B)，再去调用 irq_desc[B]. handle_irq。</p></li>
<li><p>模块的中断处理函数：</p>
<p>irq_desc[B]. handle_irq，BSP 开发人员会设置对应的处理函数，一般是
handle_level_irq 或
handle_edge_irq，从名字上看是用来处理电平触发的中断、边沿触发的中断。该函数会去判断哪个<strong>设备</strong>触发了中断，可能有某个设备触发了中断，也可能有多个设备触发了中断，因此irq_desc[B].handle_irq
会遍历 action
成员指向的链表，并调用链表元素中的“<strong>具体的中断处理函数</strong>”，这些函数自行判断该中断是否由自己产生，若是则处理。</p></li>
<li><p>外部设备提供的中断处理函数：</p>
<p>对应 irqaction 结构体中的 handler 或者 thread_fn
成员，这些处理函数由自己驱动程序提供，应该具有判断设备是否发生了中断，如何处理中断的能力。</p></li>
</ol>
<p>总的来说，<strong>irq_desc 数组对应“中断控制器模块”，链表中 irqaction
结构体对应产生中断源的外部设备</strong>。</p>
<blockquote>
<p>上述过程中忽略了一点：当执行中断处理函数时，从中获取的是硬件中断号
(hwirq)，而irq_desc 数组的寻址使用的是虚拟中断号 (irq) ，二者的映射在
2.2.3 &amp; 2.2.4 节中讨论</p>
</blockquote>
<h4 id="irqaction-结构体">2.2.2 irqaction 结构体</h4>
<p>irqaction 结构体在 <code>include/linux/interrupt.h</code>
中定义，主要内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">	<span class="type">irq_handler_t</span>		handler;</span><br><span class="line">    <span class="type">irq_handler_t</span>		thread_fn;</span><br><span class="line">	<span class="type">void</span>			*dev_id;</span><br><span class="line">	<span class="type">void</span> __percpu		*percpu_dev_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">thread</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">secondary</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		thread_mask;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span>	*<span class="title">dir</span>;</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
<p>当调用 request_irq、request_threaded_irq
注册中断处理函数时，内核就会构造一个 irqaction
结构体，该结构体最重要的是 handler、thread_fn、thread 成员：</p>
<ol type="1">
<li>handler 是中断处理的上半部函数，用来处理紧急的事情。</li>
<li>thread_fn 对应一个内核线程 thread，当 handler 执行完毕，Linux
内核会唤醒对应的内核线程。在内核线程里，会调用 thread_fn 函数。</li>
<li>可以提供 handler 而不提供 thread_fn，就退化为一般的 request_irq
函数。</li>
<li>可以不提供 handler 只提供 thread_fn，完全由内核线程来处理中断。</li>
<li>也可以既提供 handler 也提供
thread_fn，这就是中断上半部、下半部。</li>
</ol>
<p>其次是 dev_id 成员，在 reqeust_irq 时可以传入
dev_id，它的作用如下：</p>
<ol type="1">
<li>中断处理函数执行时，可以使用 dev_id</li>
<li>卸载中断时要传入 dev_id，这样才能在 action 链表中根据 dev_id
找到对应项</li>
</ol>
<h4 id="irq_data-结构体">2.2.3 irq_data 结构体</h4>
<p>irq_data 结构体在 <code>include/linux/irq.h</code>
中定义，主要内容如下图：</p>
<figure>
<img src="../images/异常和中断/image-20240105204536400.png"
alt="image-20240105204536400" />
<figcaption aria-hidden="true">image-20240105204536400</figcaption>
</figure>
<p>它就是个中转站，里面有 irq_chip 指针 和 irq_domain
指针，都是指向别的结构体。</p>
<h4 id="irq_domain-结构体">2.2.4 irq_domain 结构体</h4>
<p>irq_domain 结构体在 <code>include/linux/irqdomain.h</code>
中定义，主要内容如下图：</p>
<figure>
<img src="../images/异常和中断/image-20240105205204566.png"
alt="image-20240105205204566" />
<figcaption aria-hidden="true">image-20240105205204566</figcaption>
</figure>
<p>当我们后面从设备树讲起，如何在设备树中指定中断，设备树的中断如何被
转换为 irq 时，irq_domain
将会起到极大的作用，举例来说，假设在设备树中有这样的属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">interrupt-parent = &lt;&amp;gpio1&gt;; </span><br><span class="line">interrupts = &lt;<span class="number">5</span> IRQ_TYPE_EDGE_RISING&gt;;</span><br></pre></td></tr></table></figure>
<p>它表示要使用 gpio1 里的第 5 号中断，因此，当我们调用 GPIO1
的中断处理函数，会获取到的 hwirq = 5。但是我们在 irq_desc
数组中寻址使用的是全局的虚拟中断号 irq。二者之间的转换就是由 GPIO1
对应的 irq_domain 结构体中的相关成员实现的。具体来说，irq_domain
结构体中有一个 irq_domain_ops 结构体，里面有各种操作函数：</p>
<ol type="1">
<li>xlate：用来解析设备树的中断属性，提取出 hwirq、type 等信息。</li>
<li>map：把 hwirq 转换为 irq。</li>
</ol>
<h4 id="irq_chip-结构体">2.2.5 irq_chip 结构体</h4>
<p>irq_chip 结构体在 <code>include/linux/irq.h</code>
中定义，主要内容如下图：</p>
<figure>
<img src="../images/异常和中断/image-20240105210040202.png"
alt="image-20240105210040202" />
<figcaption aria-hidden="true">image-20240105210040202</figcaption>
</figure>
<p>这个结构体封装了主控芯片有关中断的相关硬件操作，例如我们在
request_irq 后，并不需要手工去使能中断，原因就是系统调用对应的 irq_chip
里的函数帮我们使能了中断；我们提供的中断处理函数中，也不需要执行主芯片相关的清中断操作，也是系统帮我们调用
irq_chip 中的相关函数。</p>
<p><strong>但是对于外部设备相关的清中断操作，还是需要我们自己做的，外部设备对应我们编写的驱动程序。</strong></p>
<h3 id="配置中断资源">2.3 配置中断资源</h3>
<h4 id="设备树中断节点的语法">2.3.1 设备树中断节点的语法</h4>
<blockquote>
<p>参考文档：内核-controller.txt</p>
</blockquote>
<figure>
<img src="../images/异常和中断/image-20240106101640026.png"
alt="image-20240106101640026" />
<figcaption aria-hidden="true">image-20240106101640026</figcaption>
</figure>
<p>上图为 IMX6ULL 的中断体系，比之前多了一个 GPC INTC （General Power
Controller，Interrupt Controller），我们参考 imx6ull.dtsi
中有关中断的部分内容来学习设备树中有关中断的语法：</p>
<h5 id="image-20240106102152360"><img
src="../images/异常和中断/image-20240106102152360.png"
alt="image-20240106102152360" /></h5>
<h5 id="intc">(1) intc</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#interrupt-cells = &lt;3&gt;;</span><br><span class="line">#interrupt-controller;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>凡是包含 <code>#interrupt-controller;</code>
表明该节点是一个中断控制器节点</li>
<li><code>#interrupt-cells = &lt;3&gt;;</code>指明想要指定该中断控制器的某个中断源应该使用多少个
cell 来表示</li>
</ol>
<p>对于顶层中断控制器 GIC 而言，3 个 cell 分别表示：</p>
<ol type="1">
<li>第一个 cell 表示中断类别，可选<code>GIC_PPI,GIC_SPI,GIC_SGI</code>：
<ul>
<li>Private Peripheral Interrupt
(PPI)：以单个特定CPU核为目标的外围中断</li>
<li>Shared Peripheral Interrrupt
(SPI)：可以以任意CPU核为目标的外围中断</li>
<li>Software-generated interrupt (SGI)：用于CPU核之间通信的中断</li>
</ul></li>
<li>第二个 cell 表示中断控制器内的中断序号</li>
<li>第三个 cell 表示触发条件</li>
</ol>
<blockquote>
<p>详情可参考GIC架构规格书：IHI0069E_gic_architecture_specification.pdf</p>
</blockquote>
<h5 id="gpc">(2) gpc</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#interrupt-controller;</span><br><span class="line">#interrupt-cells = &lt;3&gt;;</span><br><span class="line">interrupts = &lt;GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH&gt;</span><br><span class="line">interrupts-parent = &lt;&amp;intc&gt;;</span><br></pre></td></tr></table></figure>
<p>这也是一个中断控制器，并且它的子节点声明中断时要使用 3 个 cell</p>
<ol type="1">
<li><code>interrupts-parent =</code> ：指明该中断设备的父节点</li>
<li><code>interrupts =</code>：描述本中断节点的中断触发条件</li>
</ol>
<h5 id="gpio1">(3) gpio1</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interrupts = &lt;GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH&gt;, 					     </span><br><span class="line">			 &lt;GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH&gt;; 						</span><br><span class="line">interrupt-controller; 				</span><br><span class="line">#interrupt-cells = &lt;2&gt;;</span><br></pre></td></tr></table></figure>
<p>这是一个中断控制器，并且它的子节点声明中断时要使用 2 个
cell。参考内核文档<code>interrupt.txt</code> 可知两个 cell
分别表示：</p>
<ol type="1">
<li><p>第一个 cell 表示中断控制器内的中断序号</p></li>
<li><p>第二个 cell 表示中断触发条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- bits[3:0] trigger type and level flags         </span><br><span class="line">1 = low-to-high edge triggered         </span><br><span class="line">2 = high-to-low edge triggered         </span><br><span class="line">4 = active high level-sensitive         </span><br><span class="line">8 = active low level-sensitive</span><br></pre></td></tr></table></figure></li>
</ol>
<p>此外，它的属性中没有指明该节点的中断父节点，因此在该节点直接继承其父节点的
<code>interrupts-parent</code> 属性表明其中断父节点为 gpc</p>
<p>此外，通过查询IMX6ULL的数据手册，可知GPIO的共享中断触发源信息：</p>
<figure>
<img src="../images/异常和中断/image-20240106114012876.png"
alt="image-20240106114012876" />
<figcaption aria-hidden="true">image-20240106114012876</figcaption>
</figure>
<h5 id="spidev">(4) spidev</h5>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interrupt-parent = &lt;&amp;gpio1&gt;;         </span><br><span class="line">interrupts = &lt;1 1&gt;;</span><br></pre></td></tr></table></figure>
<p>该节点就不是中断控制器了，是设备节点的中断信息。它的中断父节点是
gpio1，它在 gpio1
内的中断序号是1，并且中断触发条件是上升沿。这种设备节点的相关信息是要由我们来设置的。</p>
<h5 id="新写法---interrupts-extended-属性">(5) 新写法 -
interrupts-extended 属性</h5>
<p>一个“interrupts-extended”属性就可以既指定“interrupt-parent”，
也指定“interrupts”，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interrupts-extended = &lt;&amp;gpio1 5 1&gt;, &lt;&amp;gpio1 1 1&gt;;</span><br></pre></td></tr></table></figure>
<h4 id="在代码中获得中断">2.3.2 在代码中获得中断</h4>
<p>在 “使用设备树的LED驱动框架”文章的的 1.4.2 节记录了设备树的哪些
device_node 会被转换为 platform_device，对于</p>
<h5 id="对于-platform_device">（1）对于 platform_device</h5>
<p>一个节点能被转换为
platform_device，并且它的设备树里指定了中断属性，那么可以从
platform_device 中获得“中断资源”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**  </span><br><span class="line">* platform_get_resource - get a resource for a device  </span><br><span class="line">* @dev: platform device  </span><br><span class="line">* @type: resource type    // 取哪类资源？IORESOURCE_MEM、IORESOURCE_REG、IORESOURCE_IRQ 等</span><br><span class="line">* @num: resource index    // 这类资源中的哪一个？</span><br><span class="line">*/ </span><br><span class="line">struct resource *platform_get_resource(struct platform_device *dev, 				       unsigned int type, unsigned int num)</span><br></pre></td></tr></table></figure>
<h5 id="对于-i2c-设备spi-设备">（2）对于 I2C 设备、SPI 设备</h5>
<p>对于 I2C 设备节点，I2C 总线驱动在处理设备树里的 I2C
子节点时，也会处理其中的中断信息。一个 I2C 设备会被转换为一个 i2c_client
结构体，中断号会保存在 i2c_client 的 irq 成员里，代码如下
<code>drviers/i2c/i2c-core.c</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_probe</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>	*<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>	*<span class="title">driver</span>;</span></span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!client-&gt;irq) &#123;</span><br><span class="line">		<span class="type">int</span> irq = -ENOENT;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">			irq = of_irq_get_byname(dev-&gt;of_node, <span class="string">&quot;irq&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> (irq == -EINVAL || irq == -ENODATA)</span><br><span class="line">				irq = of_irq_get(dev-&gt;of_node, <span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACPI_COMPANION(dev)) &#123;</span><br><span class="line">			irq = acpi_dev_gpio_irq_get(ACPI_COMPANION(dev), <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (irq == -EPROBE_DEFER)</span><br><span class="line">			<span class="keyword">return</span> irq;</span><br><span class="line">		<span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">			irq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		client-&gt;irq = irq;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>对于 SPI 设备节点，SPI 总线驱动在处理设备树里的 SPI
子节点时，也会处理其中的中断信息。一个 SPI 设备会被转换为一个 spi_device
结构体，中断号会保存在 spi_device 的 irq 成员里，代码如下
<code>drivers/spi/spi.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_drv_probe</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span>		*<span class="title">sdrv</span> =</span> to_spi_driver(dev-&gt;driver);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>		*<span class="title">spi</span> =</span> to_spi_device(dev);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = of_clk_set_defaults(dev-&gt;of_node, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dev-&gt;of_node) &#123;</span><br><span class="line">		spi-&gt;irq = of_irq_get(dev-&gt;of_node, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (spi-&gt;irq == -EPROBE_DEFER)</span><br><span class="line">			<span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line">		<span class="keyword">if</span> (spi-&gt;irq &lt; <span class="number">0</span>)</span><br><span class="line">			spi-&gt;irq = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="调用-of_irq_get-获得中断号">（3）调用 of_irq_get 获得中断号</h5>
<p>如果你的设备节点既不能转换为 platform_device，它也不是 I2C 设备，
不是 SPI 设备，那么在驱动程序中可以自行调用 of_irq_get
函数去解析设备树，得到中断号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * of_irq_get - Decode a node&#x27;s IRQ and return it as a Linux IRQ number</span></span><br><span class="line"><span class="comment"> * @dev: pointer to device tree node</span></span><br><span class="line"><span class="comment"> * @index: zero-based index of the IRQ</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns Linux IRQ number on success, or 0 on the IRQ mapping failure, or</span></span><br><span class="line"><span class="comment"> * -EPROBE_DEFER if the IRQ domain is not yet created, or error code in case</span></span><br><span class="line"><span class="comment"> * of any other failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">of_irq_get</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>
<h5 id="对于-gpio">（3）对于 GPIO</h5>
<p>在<code>drivers/input/keyboard/gpio_keys.c</code>，可以使用
gpio_to_irq 或 gpiod_to_irq 获得中断号：</p>
<p>首先使用该函数来获取第 i 个引脚的 GPIO 的编号，并将其 flags （例如
GPIO_ACTIVE_HIGH ）保存下来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">of_get_gpio_flags</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">int</span> index, <span class="keyword">enum</span> of_gpio_flags *flags)</span></span><br></pre></td></tr></table></figure>
<p>然后根据 GPIO 编号转换为该 GPIO 的描述符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  * Convert a GPIO number to its descriptor  */</span> </span><br><span class="line"><span class="keyword">struct</span> gpio_desc *<span class="title function_">gpio_to_desc</span><span class="params">(<span class="type">unsigned</span> gpio)</span></span><br></pre></td></tr></table></figure>
<p>最后使用 gpio_to_irq 或 gpiod_to_irq 获得中断号：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gpiod_to_irq() - return the IRQ corresponding to a GPIO</span></span><br><span class="line"><span class="comment"> * @desc: gpio whose IRQ will be returned (already requested)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return the IRQ corresponding to the passed GPIO, or an error code in case of</span></span><br><span class="line"><span class="comment"> * error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_to_irq</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> gpio_desc *desc)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gpio_to_irq	__gpio_to_irq    </span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __<span class="title function_">gpio_to_irq</span><span class="params">(<span class="type">unsigned</span> gpio)</span> </span><br><span class="line">&#123; 	</span><br><span class="line">    <span class="keyword">return</span> gpiod_to_irq(gpio_to_desc(gpio)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写-gpio-触发中断">3. 编写 GPIO 触发中断</h2>
<h4 id="在设备树中添加节点">（1）在设备树中添加节点</h4>
<figure>
<img src="../images/异常和中断/image-20240107150811885.png"
alt="image-20240107150811885" />
<figcaption aria-hidden="true">image-20240107150811885</figcaption>
</figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">krocz_gpio &#123;</span><br><span class="line">    compatible = &quot;krocz,buttondrv&quot;;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_krocz_button&gt;;</span><br><span class="line">    gpios = &lt;&amp;gpio5 1 GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pinctrl_krocz_button: krocz_buttongrp &#123;        </span><br><span class="line">     fsl,pins = &lt;</span><br><span class="line">		MX6ULL_PAD_SNVS_TAMPER1__GPIO5_IO01        0x000110A0</span><br><span class="line">            &gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>因为在内核中有 <code>gpiod_to_irq</code>
这个函数，所以不必在设备节点中指定中断。</p>
<h4 id="编写驱动程序">（2）编写驱动程序</h4>
<blockquote>
<p>参考内核源码：drivers/input/keyboard/gpio_keys.c</p>
</blockquote>
<p>注册内核模块的代码省略，主要是 platform_driver 的注册：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	reverse_led_status();  <span class="comment">// 每触发一次，翻转一下LED引脚的输出</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">krocz_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;krocz,buttondrv&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 定义platform_driver */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;krocz_button_key&quot;</span>,</span><br><span class="line">        .of_match_table = krocz_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err, count, i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> flags = GPIOF_IN;</span><br><span class="line">		</span><br><span class="line">	printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 获取设备节点中第i个gpio引脚及其flag</span></span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="comment">// gpio引脚转gpio_desc结构体</span></span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flag &amp; OF_GPIO_ACTIVE_LOW)  flags |= GPIOF_ACTIVE_LOW;</span><br><span class="line">        <span class="comment">// 看函数描述好像是用来初始化GPIO引脚的</span></span><br><span class="line">		err = devm_gpio_request_one(&amp;pdev-&gt;dev, gpio_keys_100ask[i].gpio, flags, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 设置GPIO引脚为输入</span></span><br><span class="line">		err = gpiod_direction_input(gpio_keys_100ask[i].gpiod);</span><br><span class="line">        <span class="comment">// gpio引脚号转虚拟中断号</span></span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注册中断处理函数 gpio_key_isr，触发条件为下降沿</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, IRQF_TRIGGER_FALLING, <span class="string">&quot;krocz_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//int err;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count, i;</span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>probe 函数的核心就是将中断处理函数 gpio_key_isr
进行注册，以便我们在按下按键时能够得到处理，因为硬件设计上有电容用来去抖动，所以不需要其他软件上的处理了。</p>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构模板</title>
    <url>/2023/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="链表">1.链表</h2>
<h3 id="静态链表数组模拟">1.静态链表（数组模拟）</h3>
<h4 id="单链表">1.1 单链表</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N], idx, head = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_head</span><span class="params">(<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = v, ne[idx] = head, head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = v, ne[idx] = ne[k], ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(~k) ne[k] = ne[ne[k]];</span><br><span class="line">    <span class="keyword">else</span> head = ne[head];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k, v;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        <span class="keyword">switch</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">                cin &gt;&gt; v;</span><br><span class="line">                <span class="built_in">add_head</span>(v);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 题中对于k的计数从1开始，但是存储下标从0开始，因此需要k - 1</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                cin &gt;&gt; k &gt;&gt; v;</span><br><span class="line">                <span class="built_in">add</span>(k - <span class="number">1</span>, v);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                cin &gt;&gt; k;</span><br><span class="line">                <span class="built_in">remove</span>(k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head; ~i; i = ne[i])</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注1：为了逻辑清晰代码简洁，无论是静态链表还是动态链表都最好加上头节点，但是仅在数组模拟单链表时没有头节点，因为算法题中使用单链表时一般仅使用在头插入新节点，不涉及其他操作，所以没有必要加入头节点</p>
<p>注2：在数组模拟单/双链表时在第k个位置之前/之后插入新节点，其中第k个位置是指按时间顺序依次插入的数即使删除了其中某些元素，这些被删除的元素依然占用位置(静态链表不会释放空间)。之所以没有像动态链表那样“在链表中第k个元素之前/之后插入”，是为了模板的简洁起见吧，静态链接一样可以在"在链表中第k个元素之前/之后插入".</p>
<h4 id="双链表">1.2 双链表</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span>  <span class="comment">// 这里k是待插入节点左邻居的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = v;</span><br><span class="line">    r[idx] = r[k], l[idx] = k;</span><br><span class="line">    l[r[k]] = idx; r[k] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span>  <span class="comment">// 这里k是待删除节点的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>, idx = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="type">int</span> k, v;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;R&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; v;</span><br><span class="line">            <span class="built_in">insert</span>(l[<span class="number">1</span>], v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;L&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; v;</span><br><span class="line">            <span class="built_in">insert</span>(<span class="number">0</span>, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;IL&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; v;</span><br><span class="line">            <span class="built_in">insert</span>(l[k+<span class="number">1</span>], v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;IR&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; v;</span><br><span class="line">            <span class="built_in">insert</span>(k+<span class="number">1</span>, v);            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i])</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在数组模拟双链表中，使用了头节点和尾节点，来简化逻辑。</p>
<h3 id="动态链表">2.动态链表</h3>
<h3 id="单链表-1">2.1 单链表</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>* LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> k, LinkList head)</span> <span class="comment">//在第k个节点之后插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *new_node;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    new_node = (<span class="keyword">struct</span> LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    new_node-&gt;val = v;</span><br><span class="line">    new_node-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k, LinkList head)</span> <span class="comment">// 删除第k个节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)  </span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *tmp;</span><br><span class="line">    tmp = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkList head = (<span class="keyword">struct</span> LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n, x;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">add</span>(x, i, head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LNode *p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;val);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含头节点的动态单链表</p>
<h3 id="双链表-1">2.2 双链表</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *l, *r;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DLinkList</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *lhead, *rhead;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DNode</span>* <span class="built_in">find</span>(<span class="type">int</span> k, DLinkList *h)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *p;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= (h-&gt;cnt &gt;&gt; <span class="number">1</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        p = h-&gt;lhead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) p = p-&gt;r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = h-&gt;rhead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= (h-&gt;cnt - k); i++) p = p-&gt;l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设左头节点的下标为0，k表示在第k节点之后插入一个新节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> k, DLinkList* h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *p = <span class="built_in">find</span>(k, h);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *new_node = (<span class="keyword">struct</span> DNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> DNode));</span><br><span class="line">    new_node-&gt;val = v;</span><br><span class="line">    new_node-&gt;l = p;  new_node-&gt;r = p-&gt;r;</span><br><span class="line">    p-&gt;r-&gt;l = new_node;</span><br><span class="line">    p-&gt;r = new_node;</span><br><span class="line">    h-&gt;cnt ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设左头节点的下标为0，删除第k个节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k, DLinkList* h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *p = <span class="built_in">find</span>(k, h);</span><br><span class="line">    p-&gt;l-&gt;r = p-&gt;r;</span><br><span class="line">    p-&gt;r-&gt;l = p-&gt;l;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    h-&gt;cnt --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DLinkList* h = (<span class="keyword">struct</span> DLinkList *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> DLinkList));</span><br><span class="line">    h-&gt;lhead = (<span class="keyword">struct</span> DNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> DNode));</span><br><span class="line">    h-&gt;rhead = (<span class="keyword">struct</span> DNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> DNode));</span><br><span class="line">    h-&gt;lhead-&gt;r = h-&gt;rhead;</span><br><span class="line">    h-&gt;rhead-&gt;l = h-&gt;lhead;</span><br><span class="line">    h-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n, x;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="built_in">add</span>(x, i, h);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    DNode *p = h-&gt;lhead-&gt;r;</span><br><span class="line">    <span class="keyword">while</span>(p != h-&gt;rhead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;val);</span><br><span class="line">        p = p-&gt;r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含左右头节点的双链表</p>
<h2 id="栈">2.栈</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组模拟方式</span></span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; x;   stk[ ++ tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;pop&quot;</span>) tt -- ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;empty&quot;</span>) cout &lt;&lt; (tt ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; stk[tt] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// STL方式</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>) </span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; x;   stk.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>)  stk.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>) cout &lt;&lt; (stk.<span class="built_in">size</span>()? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; stk.<span class="built_in">pop</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="单调栈">2.1 单调栈</h3>
<p><strong>适用问题</strong>：求数组中某一元素左边/右边第一个比该元素本身大/小的元素</p>
<p><strong>单调栈的定义</strong>：满足单调性的栈结构（从栈底到栈顶的元素依次递增/递减）</p>
<p>例如单调递增栈，在插入元素为为了满足栈的单调性，需要在尽可能弹出最少的元素下将其插入：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(tt &amp;&amp; stk[tt] &gt; x) tt--;</span><br><span class="line">stk[++tt] = x;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<span
class="math inline">\(O(n)\)</span></p>
<p>首先，暴力求解该问题需要二重循环，时间复杂度为<span
class="math inline">\(O(n^2)\)</span>。而分析使用单调栈的时间复杂度，每一个元素最多会入栈一次和出栈一次，因此内层时间复杂度为<span
class="math inline">\(O(1)\)</span>，整体时间复杂度为<span
class="math inline">\(O(n)\)</span></p>
<h4 id="例题">2.1.1 例题</h4>
<blockquote>
<p>原题链接：<a
href="https://www.acwing.com/problem/content/description/832/">单调栈 -
AcWing题库</a></p>
</blockquote>
<p>求数组中某一元素左边第一个比该元素本身小的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; stk[tt] &gt; x) tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, stk[tt]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">        stk[++tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列">3.队列</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组模拟方式</span></span><br><span class="line"><span class="type">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cin &gt;&gt; x;  q[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;pop&quot;</span>)    hh++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;query&quot;</span>)  cout &lt;&lt; q[hh] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(hh &lt;= tt)  cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// STL方式</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; x; q.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;pop&quot;</span>)  q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;query&quot;</span>) cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(q.<span class="built_in">size</span>()) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>   cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列">3.1 单调队列</h3>
<p><strong>适用问题</strong>：求一个数组中滑动窗口中的最大/最小值</p>
<p><strong>单调队列的定义</strong>：满足单调性的“<strong>双端</strong>“队列（从队首到队尾元素依次递增/递减）</p>
<p>例如单调递增队列，在向队尾插入元素时，需要在满足从队首到队尾元素单调递增的情况下，尽可能少的弹出队尾元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(hh &lt;= tt &amp;&amp; q[tt] &gt; a[i])  tt--;</span><br><span class="line">q[++tt] = a[i];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单调队列不是普通的队列，因为单调队列需要从队尾弹出元素，不满足FIFIO</p>
</blockquote>
<p><strong>时间复杂度</strong>：<span
class="math inline">\(O(n)\)</span></p>
<p>假设数组的大小为<span
class="math inline">\(n\)</span>，滑动窗口的大小为<span
class="math inline">\(k\)</span>，如果暴力求解该问题则时间复杂度为<span
class="math inline">\(O(nk)\)</span>。如果使用单调队列来解决该问题，同样每一个元素最多会入队一次和出队一次，所以总时间复杂度为<span
class="math inline">\(O(n)\)</span></p>
<p><strong>求解过程</strong>：</p>
<p>以使用非严格单调递增队列求滑动窗口中的最小值为例：</p>
<ol type="1">
<li>对于新滑入的元素，需要在满足从队首到队尾元素非严格单调递增的情况下，尽可能少的弹出队尾元素。</li>
<li>对于新滑出的元素，如果该元素和队头元素(或下标)的值相等，则弹出队头元素；如果该元素和队头元素(或下标)的值不等，则说明滑动窗口内存在比滑出元素更小的值，因此按照单调队列的定义，滑出元素已经出队。</li>
<li>对于每一个滑动窗口，单调队列的队头元素即为窗口内的最小值。</li>
</ol>
<h4 id="例题-1">3.1.1 例题</h4>
<blockquote>
<p><a
href="https://www.acwing.com/problem/content/description/156/">滑动窗口
- AcWing题库</a></p>
</blockquote>
<p>求滑动窗口内的最大值和最小值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N], q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)  cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; q[tt] &gt; a[i])  tt--;      <span class="comment">// 构建非严格单调递增队列</span></span><br><span class="line">        q[++tt] = a[i];</span><br><span class="line">        <span class="keyword">if</span>(i - k &gt;= <span class="number">0</span> &amp;&amp; q[hh] == a[i - k]) hh++;   <span class="comment">//如果滑出元素是队头，则出队</span></span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &gt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[hh]);        <span class="comment">// 输出队头元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; q[tt] &lt; a[i])  tt--;      <span class="comment">// 构建非严格单调递减队列</span></span><br><span class="line">        q[++tt] = a[i];</span><br><span class="line">        <span class="keyword">if</span>(i - k &gt;= <span class="number">0</span> &amp;&amp; q[hh] == a[i - k]) hh++;   <span class="comment">//如果滑出元素是队头，则出队</span></span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> &gt;= k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[hh]);        <span class="comment">// 输出队头元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="kmp算法">4.KMP算法</h2>
<p><strong>适用问题</strong>：求模式串P在一个字符串S中所有出现位置的起始下标</p>
<h3 id="概念">4.1 概念：</h3>
<ol type="1">
<li><p>非平凡前缀：除最后一个字符外，一个字符串的全部头部组合；如"abab"，它的非平凡前缀有"a,
ab, aba"</p></li>
<li><p>非平凡后缀：除第一个字符外，一个字符串的全部尾部组合；如"abab"，它的非平凡后缀有"b,
ab, bab"</p></li>
<li><p>部分匹配值：前缀和后缀的<strong>最长共有</strong>元素的<strong>长度</strong>；如"abab"，它的部分匹配值是2，最长共有元素为"ab"。</p></li>
<li><p>部分匹配值表：记录模式串的所有前缀子串的部分匹配值的表，即next[]数组，例如模式串P"abababc"：</p>
<p>假设模式串P从下标1开始存储</p>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 34%" />
<col style="width: 34%" />
<col style="width: 14%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th>下标</th>
<th>非平凡前缀</th>
<th>非平凡后缀</th>
<th>最长共有元素</th>
<th>部分匹配值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>{}</td>
<td>{}</td>
<td>{}</td>
<td>ne[0] = 0</td>
</tr>
<tr class="even">
<td>1</td>
<td>{}</td>
<td>{}</td>
<td>{}</td>
<td>ne[1] = 0</td>
</tr>
<tr class="odd">
<td>2</td>
<td>{a}</td>
<td>{b}</td>
<td>{}</td>
<td>ne[2] = 0</td>
</tr>
<tr class="even">
<td>3</td>
<td>{a,ab}</td>
<td>{a,ba}</td>
<td>{a}</td>
<td>ne[3] = 1</td>
</tr>
<tr class="odd">
<td>4</td>
<td>{a,ab,aba}</td>
<td>{b,ab,bab}</td>
<td>{ab}</td>
<td>ne[4] = 2</td>
</tr>
<tr class="even">
<td>5</td>
<td>{a,ab,aba,abab}</td>
<td>{a,ba,aba,baba}</td>
<td>{aba}</td>
<td>ne[5] = 3</td>
</tr>
<tr class="odd">
<td>6</td>
<td>{a,ab,aba,abab,ababa}</td>
<td>{b,ab,bab,abab,babab}</td>
<td>{abab}</td>
<td>ne[6] = 4</td>
</tr>
<tr class="even">
<td>7</td>
<td>{a,ab,aba,abab,ababa,ababab}</td>
<td>{c,bc,abc,babc,ababc,bababc}</td>
<td>{}</td>
<td>ne[7] = 0</td>
</tr>
</tbody>
</table></li>
</ol>
<h3 id="求部分匹配值表的意义">4.2 求部分匹配值表的意义：</h3>
<p>举个例子，假设字符串S为"abababac"，模式串P为"abababc"：</p>
<figure>
<img src="../images/数据结构模板/image-20231118111643487.png"
alt="image-20231118111643487" />
<figcaption aria-hidden="true">image-20231118111643487</figcaption>
</figure>
<p>在第二步时，可知S串和P串的已匹配子串相等，又根据部分匹配值表可知P串最长非平凡前缀和后缀共有子串，因此可知橙色框中的两个子串相等，从而再该位置继续进行模式匹配，尽可能减少匹配次数，从而降低时间复杂度。</p>
<h3 id="kmp算法的代码实现">4.3 KMP算法的代码实现：</h3>
<p>从上面的介绍中可以总结KMP算法的求解分为两个主要步骤：</p>
<ol type="1">
<li>求部分匹配值表next[]数组</li>
<li>利用next[]数组进行字符串S和模式串P的匹配</li>
</ol>
<p>这两个步骤的实现上几乎是一致的，步骤一需要进行模式串P的非平凡前缀和非平凡后缀的匹配，同时记录并利用ne[]数组，步骤二需要进行字符串S和模式串P的匹配，同时利用ne[]数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.求ne数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; p[j + <span class="number">1</span>] != p[i]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.进行字符串S和模式串P的匹配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; p[j + <span class="number">1</span>] != s[i]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span>(p[j + <span class="number">1</span>] == s[i]) j++;</span><br><span class="line">    <span class="keyword">if</span>(j == n)   <span class="comment">// 成功匹配</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">        j = ne[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kmp算法的时间复杂度">4.4 KMP算法的时间复杂度</h3>
<p><strong>时间复杂度</strong>：<span
class="math inline">\(O(m)\)</span></p>
<p>显然暴力求解该问题的时间复杂度为<span
class="math inline">\(O(nm)\)</span>，而KMP算法将时间复杂度降为<span
class="math inline">\(O(m)\)</span></p>
<p><strong>简单证明</strong>：</p>
<p>KMP算法的两个步骤几乎是一致的，我们对步骤一求ne数组的过程进行分析：</p>
<p>for循环每一次<span class="math inline">\(i\)</span>增加1，而<span
class="math inline">\(j\)</span>可能增加1，因此有<span
class="math inline">\(j &lt;
i\)</span>；根据<code>ne[i] = j</code>，则<span class="math inline">\(0
\le ne[i] = j &lt; i\)</span>，可知<span class="math inline">\(0 \le
ne[i] &lt; i\)</span>，换一个符号有<span class="math inline">\(0 \le
ne[j] &lt; j\)</span>；每一次循环中<span
class="math inline">\(j\)</span>最多增加1，最多循环n次，而<span
class="math inline">\(j\)</span>仅能通过<code>j = ne[j]</code>变小，因此可知while循环在整个循环过程中最多执行n次；所以，求ne[]数组的时间复杂度为<span
class="math inline">\(O(n)\)</span>。类似的，可知进行模板匹配的时间复杂度为<span
class="math inline">\(O(m)\)</span></p>
<h2 id="trie树">5.Trie树</h2>
<p><strong>适用问题</strong>：Trie树又称字典树、单词查找树。适用于字符串集合的的高效存储和快速查找。一般使用Trie树的场景字符的种类不会非常多，字符越少则重复的概率高，存储的效率也就高。</p>
<p><strong>Trie树的图示</strong>：</p>
<figure>
<img src="../images/数据结构模板/image-20231127181623434.png"
alt="image-20231127181623434" />
<figcaption aria-hidden="true">image-20231127181623434</figcaption>
</figure>
<p>我们可以用数组模拟链表的思想来构造树。假设字符串中一共可能有k种类型的字符，则树存储类型<code>son[i][k]</code>，将下标0设置为头节点。此外，为了记录字符串的结束位置和个数，需要额外的记录数组cnt[N]。</p>
<figure>
<img src="../images/数据结构模板/image-20231127181648540.png"
alt="image-20231127181648540" />
<figcaption aria-hidden="true">image-20231127181648540</figcaption>
</figure>
<p>模板如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][v]) son[p][v] = ++idx;</span><br><span class="line">        p = son[p][v];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][v]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> p = son[p][v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例题-2">5.1 例题</h3>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/145/">最大异或对 -
AcWing题库</a></p>
</blockquote>
<p>想要存储所有整数，并求所有整数的异或对，应该以二进制来保存每一个数，则一共有两种字符，则适用Tire树来存储。</p>
<p>为了求最大异或对，高位比低位的贡献要大的多，显然我们需要从高位到低位依次来存储一个二进制数。</p>
<p>由于异或运算的性质，对于任意一个数，从高位到低位，查找相反的数(0查找1，1查找0)即为该数的最大异或对，查找次数为Trie树的高度，本题中为31次。</p>
<p>最后，本题的数据范围是<span class="math inline">\(1 \le N \le
10^5\)</span>，支持复杂度为<span
class="math inline">\(O(n)\)</span>的算法，因此对于分别求每一个数的最大异或对，取最大即可，总的时间复杂度为<span
class="math inline">\(O(31n)\)</span>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">3000010</span>;</span><br><span class="line"><span class="type">int</span> son[M][<span class="number">2</span>], a[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = (x &gt;&gt; i) &amp; <span class="number">0x01</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][v]) son[p][v] = ++ idx;</span><br><span class="line">        p = son[p][v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = (x &gt;&gt; i) &amp; <span class="number">0x01</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!v])</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            p = son[p][!v];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = son[p][v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">add</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">find</span>(a[i]));</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集">6.并查集</h2>
<p><strong>适用问题</strong>：高效的合并集合以及查找数据所属的集合关系。</p>
<p><strong>时间复杂度</strong>：加入路径压缩之后，合并和查询的时间复杂度都<strong>近乎<span
class="math inline">\(O(1)\)</span></strong></p>
<h3 id="并查集的模板和图示">6.1 并查集的模板和图示</h3>
<p><strong>初始化</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  p[i] = i;</span><br></pre></td></tr></table></figure>
<p><strong>查询（未加入路径压缩）</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) <span class="keyword">return</span> <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>合并</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure>
<p><strong>图示</strong>：</p>
<figure>
<img src="../images/数据结构模板/image-20231127203436963.png"
alt="image-20231127203436963" />
<figcaption aria-hidden="true">image-20231127203436963</figcaption>
</figure>
<p><strong>查询（加入路径压缩）</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入路径压缩之后，每一次调用find()函数，可能会使得子节点直接接在根节点下，如图：</p>
<figure>
<img src="../images/数据结构模板/image-20231127203854443.png"
alt="image-20231127203854443" />
<figcaption aria-hidden="true">image-20231127203854443</figcaption>
</figure>
<h3 id="带权并查集">6.1 带权并查集</h3>
<p>朴素版本的并查集仅能够查询集合所属关系，如果集合内部点存在关系的话，则需要额外维护节点的边权信息。</p>
<p>一般用数组d[i]表示节点<span
class="math inline">\(i\)</span>到其<strong>父节点</strong>的距离信息。</p>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/242/">食物链 -
AcWing题库</a></p>
</blockquote>
<p>在本题中，节点之间存在有向依赖关系<span class="math inline">\(a → b →
c → a\)</span>。我们可以用 <span class="math inline">\(d[i]\)</span>
表示节点 <span class="math inline">\(i\)</span> 和其父节点 <span
class="math inline">\(p[i]\)</span> 之间的关系：0表示是同类，1表示 <span
class="math inline">\(i\)</span> 是 <span
class="math inline">\(p[i]\)</span> 的天敌，2表示 <span
class="math inline">\(p[i]\)</span>是 <span
class="math inline">\(i\)</span> 的天敌。</p>
<blockquote>
<p>参考题解：<a
href="https://www.acwing.com/solution/content/1357/">食物链(带权并查集)
- AcWing</a></p>
</blockquote>
<p><strong><em>关系传递的本质是向量的运算</em></strong></p>
<p>假设a的祖先为x，b的祖先是y，可表示为向量：<span
class="math inline">\(\vec{a} = \{a,x\}, \vec{b} = \{b,
y\}\)</span>，每一句话给出a和b的关系可以表示为<span
class="math inline">\(rel = \vec{ab}\)</span>：</p>
<ol type="1">
<li>若<span class="math inline">\(x =
y\)</span>，说明a和b之间存在关系，由于<span
class="math inline">\(x=y\)</span>，则<span
class="math inline">\(\vec{ab} = \vec{a} -
\vec{b}\)</span>；对3取模之后移动到正整数。此时0表示a,b为同类，1表示a吃b，2表示b吃a，直接与<span
class="math inline">\(rel\)</span>进行比较即可得出真伪</li>
<li>若<span class="math inline">\(x \neq
y\)</span>，说明a和b之间不存在关系，则给出的关系一定是对的，合并<code>p[x]=y</code>，假设<span
class="math inline">\(\vec{x} = \{x,y\}\)</span>，则<span
class="math inline">\(\vec{ab} + \vec{b} = \vec{a} +
\vec{x}\)</span>，即<span class="math inline">\(\vec{x} = \vec{b} +
\vec{ab} - \vec{a}\)</span></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) </span><br><span class="line">    &#123;</span><br><span class="line">        u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t, a, b;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; n || b &gt; n) &#123; res ++; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="type">int</span> rel;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">1</span>)  rel = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> rel = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(a), y = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(x == y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( ((d[a] - d[b]) %<span class="number">3</span> + <span class="number">3</span>) % <span class="number">3</span> != rel) res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[x] = y;</span><br><span class="line">            d[x] = d[b] + rel - d[a];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆">7.堆</h2>
<h4 id="堆的性质">(1) 堆的性质：</h4>
<p>堆是一棵完全二叉树（除了最后一层外所有层的节点都是非空的，最后一层从左到右都是满的）。以小根堆为例，满足父节点小于等于左右儿子的完全二叉树。</p>
<h4 id="堆的数组存储方式">(2) 堆的数组存储方式：</h4>
<p>堆是一棵完全二叉树，因此，可以利用数组下标来表示堆节点的父子关系：</p>
<figure>
<img src="../images/数据结构模板/image-20231202101456948.png"
alt="image-20231202101456948" />
<figcaption aria-hidden="true">image-20231202101456948</figcaption>
</figure>
<p>假设父节点的下标为<span
class="math inline">\(i\)</span>，则左儿子的下标为<span
class="math inline">\(2i\)</span>，右儿子的下标为<span
class="math inline">\(2i+1\)</span>。因此，堆的数组存储需要从1开始存储。</p>
<h4 id="堆的两个基本操作">(3) 堆的两个基本操作：</h4>
<p><strong>up()</strong>：</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u &gt; <span class="number">1</span> &amp;&amp; h[u/<span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u/<span class="number">2</span>], u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图示，对8所在节点执行up()操作：</p>
<figure>
<img src="../images/数据结构模板/image-20231202102638376.png"
alt="image-20231202102638376" />
<figcaption aria-hidden="true">image-20231202102638376</figcaption>
</figure>
<p><strong>down()</strong>:</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span>] &lt; h[t])  t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u], h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图示，对10所在节点执行down()操作：</p>
<figure>
<img src="../images/数据结构模板/image-20231202102925959.png"
alt="image-20231202102925959" />
<figcaption aria-hidden="true">image-20231202102925959</figcaption>
</figure>
<h4 id="堆的建立">(4) 堆的建立：</h4>
<p><strong>代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; heap[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)  <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure>
<p><strong>图示</strong>（图中标红的节点为将要执行down操作的节点）：</p>
<figure>
<img src="../images/数据结构模板/image-20231202103912528.png"
alt="image-20231202103912528" />
<figcaption aria-hidden="true">image-20231202103912528</figcaption>
</figure>
<p><strong>时间复杂度分析</strong>：<span
class="math inline">\(O(n)\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; heap[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n / <span class="number">2</span>; i; i--)  <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure>
<p>简单证明为什么是<span class="math inline">\(O(n)\)</span>而不是<span
class="math inline">\(O(nlogn)\)</span>：</p>
<p>操作次数：<span class="math inline">\(S = \frac{n}{4} \times 1 +
\frac{n}{8} \times 2 + \frac{n}{16} \times 3 +   ... = n(\frac{1}{2^2}
\times 1 + \frac{1}{2^3} \times 2 + \frac{1}{2^4} \times
3  +  ...)\)</span></p>
<p>使用错位相减法计算差比数列可知<span class="math inline">\(S =
n(\frac{1}{2} + \frac{1}{2^2} + \frac{1}{2^3} + ...) &lt; n\)</span></p>
<p>因此，总的时间复杂度为<span class="math inline">\(O(n)\)</span></p>
<h4 id="堆支持的操作">(5) 堆支持的操作：</h4>
<p>插入一个数：<code>heap[++cnt] = x; up(cnt);</code></p>
<p>求集合中的最小值：<code>heap[1];</code></p>
<p>删除最小值：<code>heap[1] = heap[cnt]; cnt--; down(1);</code></p>
<p>删除任意一个元素：<code>heap[k] = heap[cnt]; cnt--; up(k); down(k);</code></p>
<p>修改任意一个元素：<code>heap[k] = x; up(k); down(k);</code></p>
<h2 id="哈希表">8.哈希表</h2>
<p><strong>适用问题</strong>：高效的存储和查找值或者键值对</p>
<p><strong>时间复杂度</strong>：如果哈希函数设计的很好，分布均匀几乎不产生冲突，那么存储和查找的<strong>期望时间复杂度</strong>为<span
class="math inline">\(O(1)\)</span></p>
<p>哈希表的设计主要包括哈希函数的设计和解决冲突的方式。</p>
<p><strong>哈希函数</strong>：采用取余法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int key = (x % N + N) % N;</span><br></pre></td></tr></table></figure>
<p>一般处理的问题，数值都是随机的，则可以采用取余作为哈希函数。如果是非随机数列，则可以针对性的设计哈希函数来保证分布均匀。</p>
<p>模数<span
class="math inline">\(N\)</span>取比hash数组规模稍大一点的质数，例如比<span
class="math inline">\(1e^5\)</span>的稍大的质数是<span
class="math inline">\(100003\)</span>，比<span
class="math inline">\(3e^{5}\)</span>稍大的质数是<span
class="math inline">\(300007\)</span></p>
<p><strong>拉链法</strong>：</p>
<p>拉链法将hash数组中每个元素视为一个链表的头节点；如果键产生冲突，就将值存储在键对应的链表中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;</span><br><span class="line"><span class="type">int</span> e[N],ne[N],h[N],idx;</span><br><span class="line"><span class="built_in">memset</span>(h , <span class="number">-1</span> , <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = (x % N + N) % N;</span><br><span class="line">    e[idx] = x , ne[idx] = h[u] , h[u] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i ; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>开放寻址法</strong>：</p>
<p>当产生冲突时，开放寻址法会在键指向的位置后向右寻找空位来存储值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">// 如果查找元素存在，则返回对应下标；不存在则返回第一个空位的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[u] != null &amp;&amp; h[u] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        u++;</span><br><span class="line">        <span class="keyword">if</span>(u == N)  u = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用开放寻址法，哈希数组一般会开成数据规模的<strong>2~3倍</strong>，以减少冲突的概率。此外，如果使用开放寻址法发生<strong>TLE</strong>了，可能是哈希数组开小了所有的元素都用完了。</p>
<blockquote>
<p>为什么使用0x3f3f3f3f来表示无穷大？ 》 <a
href="https://blog.csdn.net/lyj2014211626/article/details/65481630">C++中memset()函数的用法详解-CSDN博客</a></p>
</blockquote>
<p>C++ STL的哈希表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt; h;</span><br><span class="line">h[<span class="string">&quot;123&quot;</span>] = <span class="number">1</span>;  <span class="comment">// 插入</span></span><br><span class="line">h[<span class="string">&quot;123&quot;</span>] = <span class="number">2</span>;  <span class="comment">// 修改</span></span><br><span class="line">h.<span class="built_in">erase</span>(<span class="string">&quot;123&quot;</span>);<span class="comment">// 删除</span></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">h.<span class="built_in">count</span>(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>一般用STL就行，自己写也挺麻烦的</p>
<h3 id="字符串前缀哈希">8.1 字符串前缀哈希</h3>
<p><strong>适用问题</strong>：用来解决<strong>多次查询一个字符串中子串哈希</strong>的问题</p>
<h4 id="字符串前缀哈希法的步骤">8.1.1 字符串前缀哈希法的步骤</h4>
<h5 id="计算字符串所有前缀字符串的哈希值">(1)
计算字符串所有前缀字符串的哈希值</h5>
<p>例如字符串S，该字符串从下标1，长度为n，将该字符串看作一个n位<span
class="math inline">\(P\)</span>进制数，则该字符串的哈希值为：</p>
<p><span class="math display">\[hash[i] = (\sum_{i=1}^{n}S[i] \times
P^{n-i}) \mod Q\]</span></p>
<p>该值可能非常大，因此还需要对一个较小的数字<span
class="math inline">\(Q\)</span>取模，<strong>在具体实现中使用<code>unsigned long long</code>类型存储hash值</strong>，如果hash超过了该类型的最大数值，可以利用C语言的整型溢出机制自动对<span
class="math inline">\(2^{64}\)</span>取模，即<span
class="math inline">\(Q =
2^{64}\)</span>（后面的公式中会省略该取模步骤）</p>
<p><strong>P一般取131或者13331</strong>，这是一个经验取值，99%的情况下不会发生冲突。</p>
<blockquote>
<p>PS：<span
class="math inline">\(S[i]\)</span>可以直接使用字符的ASCLL值，也可以映射到其他数值区间。此外，<strong>不能将一个字符表示为数值0，例如假设字符A的值为0，那么字符串“A”和“AA”的Hash值相同，这显然是不可接受的。</strong></p>
</blockquote>
<h5 id="计算字符串中任意子串的hash值">(2)
计算字符串中任意子串的hash值</h5>
<p>当计算出所有前缀字符串的哈希值之后，利用前缀和的思想即可计算出任意一段字符串S中任意一段字符串<code>S[l,r]</code>的哈希值：</p>
<p><span class="math display">\[hashValue = hash[r] - hash[l] \times
P^{r-l+1}\]</span></p>
<p>我们需要将两个前缀字符串相同的子串部分在数值上对齐，从而确保计算出的hash值能够正确表达字符串<code>s[l,r]</code>的hash值，下图是一个简单的例子：</p>
<figure>
<img src="../images/数据结构模板/image-20231204213328066.png"
alt="image-20231204213328066" />
<figcaption aria-hidden="true">image-20231204213328066</figcaption>
</figure>
<h4 id="示例代码">8.1.2 示例代码</h4>
<blockquote>
<p><a href="https://www.acwing.com/problem/content/843/">字符串哈希 -
AcWing题库</a></p>
</blockquote>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line">ULL h[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">find</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span>  <span class="comment">//计算任意子串的哈希值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;m, s + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        cin &gt;&gt; l1 &gt;&gt; r1 &gt;&gt; l2 &gt;&gt; r2;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(l1, r1) == <span class="built_in">find</span>(l2, r2))  <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图的存储">9.图的存储</h2>
<p>图的存储可以使用邻接表或者邻接矩阵，邻接表一般用于存储稀疏图，邻接矩阵一般用于存储稠密图。</p>
<h3 id="邻接表">9.1 邻接表</h3>
<p>使用数组模拟单链表的方式为图中每一个节点建立一个链表，在链表中存储该点所能达到的所有点。如下图所示：</p>
<figure>
<img src="../images/数据结构模板/image-20231222105915825.png"
alt="image-20231222105915825" />
<figcaption aria-hidden="true">image-20231222105915825</figcaption>
</figure>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> e[N], v[N], ne[N], h[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = r, v[idx] = w, ne[idx] = h[l], h[l] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(a, b, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邻接矩阵">9.2 邻接矩阵</h3>
<figure>
<img src="../images/数据结构模板/image-20231222105901988.png"
alt="image-20231222105901988" />
<figcaption aria-hidden="true">image-20231222105901988</figcaption>
</figure>
<p>示例代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    g[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">    g[a][b] = <span class="built_in">min</span>(g[a][b], w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序">9.3 拓扑排序</h3>
<p><strong>定义</strong>：</p>
<p>若一个由图中所有点构成的序列 A 满足：对于图中的每条边<span
class="math inline">\((x,y)\)</span>，<span
class="math inline">\(x\)</span>都在<span
class="math inline">\(A\)</span>中都出现在<span
class="math inline">\(y\)</span>之前，则称<span
class="math inline">\(A\)</span>是该图的一个拓扑排序</p>
<p><strong>性质</strong>：</p>
<ul>
<li>一个有向无环图一定存在拓扑排序并且一定存在入度为0的点（<strong>入度</strong>：指向一个点的边的数量，<strong>出度</strong>：一个点被指向的边的数量）</li>
</ul>
<p><strong>求拓扑序的思路</strong>：</p>
<ol type="1">
<li>记录各个节点的入度</li>
<li>将入度为0的节点加入队列</li>
<li>将队列中的点出队，遍历所有以该点为始的所有边，并将边所指向点的入度-1；如果所指向点的入度为0，则将其加入队列</li>
<li>如果所有点都进入过队列，则存在拓扑排序，输出队列中节点的出队顺序即为一个拓扑排序。否则，不存在拓扑排序。</li>
</ol>
<p><strong>代码</strong>：</p>
<p>使用数组模拟队列求拓扑排序，可以在求完之后直接输出队列数组中的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> q[N], d[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i]) q[++tt] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v = e[i];</span><br><span class="line">            d[v] --;</span><br><span class="line">            <span class="keyword">if</span>(!d[v])  q[++tt] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路算法">10.最短路算法</h2>
<figure>
<img src="../images/数据结构模板/image-20231219100357019.png"
alt="image-20231219100357019" />
<figcaption aria-hidden="true">image-20231219100357019</figcaption>
</figure>
<h3 id="dijkstra算法">10.1 Dijkstra算法</h3>
<h4 id="朴素dijkstra算法">10.1.1 朴素Dijkstra算法</h4>
<p><strong>时间复杂度</strong>：<span
class="math inline">\(O(n^2)\)</span></p>
<p><strong>适用于</strong>：无负权边，稠密图（<span
class="math inline">\(m \sim n^2\)</span>）</p>
<p><strong>算法思想</strong>：贪心</p>
<p><strong>伪代码描述</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> point:<span class="number">1</span>~n</span><br><span class="line">	<span class="keyword">for</span> point:<span class="number">1</span>~n</span><br><span class="line">		find 不属于集合S，并且dist[t]最小的节点t</span><br><span class="line">	</span><br><span class="line">	将节点t放入集合S</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> point:<span class="number">1</span>~n</span><br><span class="line">		dist[j] = <span class="built_in">min</span>(dist[j], dist[j] + w[t][j])</span><br></pre></td></tr></table></figure>
<p>集合 <span class="math inline">\(S\)</span>
为已知最短路径的节点的集合，如果图中包含负权边，则该结论不成立，因此Dijkstra算法仅适用于所有边权为正的情况。</p>
<p><strong>算法模板</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))</span><br><span class="line">                t = j;</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆优化的dijkstra算法">10.1.2 堆优化的Dijkstra算法</h4>
<p><strong>适用于</strong>：无负权边，稀疏图（<span
class="math inline">\(m \sim n\)</span>）</p>
<p><strong>伪代码描述</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> heap.<span class="built_in">size</span>()</span><br><span class="line">	&#123;distance, t&#125; = heap.<span class="built_in">top</span>()</span><br><span class="line">    heap.<span class="built_in">pop</span>()</span><br><span class="line">	</span><br><span class="line">	将节点t放入集合S</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> all edge&lt;t, b, w&gt;</span><br><span class="line">        <span class="keyword">if</span>(dist[b] &gt; distance + w)</span><br><span class="line">            dist[b] = distance + w;</span><br><span class="line">			<span class="keyword">if</span> heap.<span class="built_in">find</span>(b) is <span class="literal">true</span></span><br><span class="line">            	heap.<span class="built_in">update</span>(&#123;dist[b], b&#125;)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">               	heap.<span class="built_in">push</span>(&#123;dist[b], b&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：<span
class="math inline">\(O(mlog^n)\)</span>，每一个节点会遍历一次，每次会遍历该节点的所有边，而堆的插入时间复杂度为<span
class="math inline">\(O(log^n)\)</span>，因此总的时间复杂度为<span
class="math inline">\(O(mlog^n)\)</span></p>
<p>算法模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    </span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = heap.<span class="built_in">top</span>();   heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> a = t.y, distance = t.x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(st[a]) <span class="keyword">continue</span>;  <span class="comment">// 判重</span></span><br><span class="line">        st[a] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[a]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> b = e[i], ev = v[i];</span><br><span class="line">            dist[b] = <span class="built_in">min</span>(dist[b], distance + ev);</span><br><span class="line">            heap.<span class="built_in">push</span>(&#123;dist[b], b&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++的STL对于堆的实现并不能实现修改或删除任意节点值的功能，因此我们将所有的{距离，节点}对都插入到堆中，并通过<code>st</code>数组进行判重，保证每一个节点仅会访问一次即可。</p>
<h3 id="bellman-ford算法">10.2 Bellman-Ford算法</h3>
<p><strong>时间复杂度</strong>：<span
class="math inline">\(O(nm)\)</span></p>
<p><strong>适用于</strong>：负权图，<strong>求最多只经过k条边的最短路</strong></p>
<p><strong>伪代码描述</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for step: 1~n</span><br><span class="line">    备份，用备份数组去去更新距离数组</span><br><span class="line">	for all edges&lt;a,b,w&gt;</span><br><span class="line">		dist[b] = min(dist[b], backup[a] + w);   （松弛操作）</span><br></pre></td></tr></table></figure>
<p><strong>算法性质</strong>：</p>
<ol type="1">
<li><p>第k次迭代后dist数组的实际含义：从源点出发经过不超过k条边，走到每一个点的最短距离</p></li>
<li><p>当算法结束后，对于任意一条边 <span
class="math inline">\(edge&lt;a,b,w&gt;\)</span> 一定有 <span
class="math inline">\(dist[b] \le dist[a] + w\)</span>
（三角不等式）</p></li>
</ol>
<p><strong>算法模板</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="type">int</span> dist[N], backup[N];</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[j].a, b = edge[j].b, w = edge[j].w;</span><br><span class="line">            dist[b] = <span class="built_in">min</span>(dist[b], backup[a] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt;= <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bellman-ford算法不需要建图，仅需要将所有边的信息保存下来即可。</p>
<h4 id="判断负环">10.2.1 判断负环</h4>
<p>如果第n步迭代时，依然更新了某些节点的最短距离，则说明图中存在负环。spfa算法作为对Bellman-ford算法的优化，判断负环的方式是相同的。</p>
<p><strong>简单证明</strong>：</p>
<p>如果第n次迭代更新了某些边的权重，说明存在经过n条边的最短路径，而n条边对应n+1个点，则说明最少有一个点相同，说明图中存在环；经过环反而能够更新权重，说明该环是一个负环。</p>
<p>PS：如果图中存在负权回路，则<strong>可能</strong>不存在到某些点的最短路</p>
<h3 id="spfa算法">10.3 spfa算法</h3>
<p><strong>时间复杂度</strong>：一般 <span
class="math inline">\(O(m)\)</span>，最坏 <span
class="math inline">\(O(nm)\)</span></p>
<p><strong>适用</strong>：比较通用，一般最短路问题都可以用spfa算法，除非出题人有意卡spfa。</p>
<p><strong>spfa算法对Bellman-Ford算法的优化</strong>：仅有在一条边的起点的最短路被更新之后，更新这条边的终点的最短路才有意义。</p>
<p>因此，将被更新的节点加入队列，使用BFS的模板进行优化。</p>
<p><strong>算法模板</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> e[N], v[N], ne[N], h[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st数组用于记录节点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;   st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = q.<span class="built_in">front</span>();  q.<span class="built_in">pop</span>();</span><br><span class="line">        st[a] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[a]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> b = e[i], w = v[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[b] &gt; dist[a] + w)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">                <span class="keyword">if</span>(!st[b])  </span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(b);   st[b] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="spfa算法判断负环">10.3.1 spfa算法判断负环</h4>
<p>spfa判断负环的思路和Bellman-ford算法判断负环的思路一致，但是spfa不能明确的知道一条最短路径所经过节点的个数，因此需要额外开一个数组<code>cnt</code>，记录每一个节点当前最短路所经过的的节点的个数。</p>
<p><strong>算法模板</strong>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> e[N], v[N], ne[N], h[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="comment">//判断负环时，dist数组不要初始化，否则可能会爆int</span></span><br><span class="line">    <span class="comment">//初始化要将所有的节点都加入到队列中，防止子图不连通</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = q.<span class="built_in">front</span>();  q.<span class="built_in">pop</span>();</span><br><span class="line">        st[a] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[a]; ~i; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> b = e[i], w = v[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[b] &gt; dist[a] + w)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">                cnt[b] = cnt[a] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[b] &gt;= n)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[b])  </span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(b);   st[b] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="floyd算法">10.4 Floyd算法</h3>
<p>时间复杂度：<span class="math inline">\(O(n^3)\)</span></p>
<p>算法思想：DP</p>
<p>适用问题：<strong>边权可以为负，但不能存在负环</strong>，求任意一对节点之间的最短路（多源最短路问题）</p>
<h4 id="floyd算法思路分析">10.4.1 Floyd算法思路分析</h4>
<p><strong>状态表示</strong>：假设 <span
class="math inline">\(d[k,i,j]\)</span> 表示从 <span
class="math inline">\(1\sim k\)</span>
这些节点中<strong>选择任意数量的节点作为中间经过节点时</strong>，节点
<span class="math inline">\(i\)</span> 到节点 <span
class="math inline">\(j\)</span> 的最短距离。</p>
<p><strong>状态转移方程</strong>：按照最短路是否经过节点 <span
class="math inline">\(k\)</span> 进行讨论：</p>
<ol type="1">
<li>当最短路不经过节点 <span class="math inline">\(k\)</span> 时，<span
class="math inline">\(d[k,i,j] = d[k-1,i,j]\)</span></li>
<li>当最短路经过节点 <span class="math inline">\(k\)</span> 时，<span
class="math inline">\(d[k,i,j] = d[k-1,i,k] + d[k-1,k,j]\)</span></li>
</ol>
<p>合并两种情况，可得状态转移方程：</p>
<p>​ <span class="math display">\[d[k,i,j] = min(d[k-1,i,j], d[k-1,i,k] +
d[k-1,k,j])\]</span></p>
<p><strong>优化空间复杂度</strong>：</p>
<ol type="1">
<li><p>从状态转移方程中，可知第 <span class="math inline">\(k\)</span>
步时状态数组的值仅和第 <span class="math inline">\(k-1\)</span>
步时的状态数组有关，因此，最起码我们完全没有必要开一个三维数组，最多
<span class="math inline">\(d[2][N][N]\)</span> 就足够使用</p></li>
<li><p>继续分析状态转移方程，看看能不能使用滚动数组的思想仅使用 <span
class="math inline">\(d[N][N]\)</span>
一个二维数组就能完成任务。以下图为例，图右表示经过 <span
class="math inline">\(k=1\)</span> 步骤后得到的状态矩阵。可以发现每一个
<span class="math inline">\(d[i,j]\)</span>
的值仅与自身和橙色区域的元素相关。当 <span class="math inline">\(i\ne k
且 j \ne k\)</span> 时，<span class="math inline">\(d[i,j]\)</span>
自身肯定是上一步得到的数值；当 <span class="math inline">\(i = k 或 j =
k\)</span>， <span class="math inline">\(d[i,j]\)</span>
自身就是橙色区域中的数值。也就是问题集中在于<strong>橙色区域的数值在本次循环中是否会更新</strong>。</p>
<figure>
<img src="../images/数据结构模板/image-20231222170732191.png"
alt="image-20231222170732191" />
<figcaption aria-hidden="true">image-20231222170732191</figcaption>
</figure></li>
<li><p>可以证明不会：当 <span class="math inline">\(i = k 或 j =
k\)</span>，以 <span class="math inline">\(i=k\)</span> 为例，有：</p>
<p>​ <span class="math display">\[d[k,i,j] = min(d[k-1,i,j], d[k-1,i,i] +
d[k-1,i,j])\]</span></p>
<p>由于图中不存在负环，则 <span class="math inline">\(d[i,i] =
0\)</span> 恒成立，因此上式可化为：</p>
<p>​ <span class="math display">\[d[k,i,j] = d[k-1,i,j]\]</span></p>
<p>因此，当 <span class="math inline">\(i = k\)</span>时，在第 <span
class="math inline">\(k\)</span> 轮更新中，<span
class="math inline">\(d[i,j], j = 1,2,...,n\)</span>
（横着的橙色区域）的值不会发生改变，为第 <span
class="math inline">\(k-1\)</span> 轮中的数值。</p></li>
<li><p>综上，可以将状态转移方程简化为：</p>
<p><span class="math display">\[d[i,j] = min(d[i,j], d[i,k] +
d[k,j])\]</span></p></li>
</ol>
<h4 id="算法模板">10.4.2 算法模板</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    d[i][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">    d[a][b] = <span class="built_in">min</span>(d[a][b], w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树算法">11. 最小生成树算法</h2>
<h3 id="prim-算法">11.1 Prim 算法</h3>
<p><strong>时间复杂度</strong>：<span
class="math inline">\(O(n^2)\)</span></p>
<p><strong>适用于</strong>：稠密图</p>
<p><strong>伪代码描述</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> point:<span class="number">1</span>~n</span><br><span class="line">	<span class="keyword">for</span> point:<span class="number">1</span>~n</span><br><span class="line">		find 不属于集合S，并且dist[t]最小的节点t</span><br><span class="line">	</span><br><span class="line">	将节点t放入集合S</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> point:<span class="number">1</span>~n</span><br><span class="line">		dist[j] = min(dist[j], w[t][j])</span><br></pre></td></tr></table></figure>
<p>和 dijkstra 算法比较相似，dijkstra 算法的 dist
数组表示每个节点到源点的最短距离。而这里的 dist
数组表示每个点到已知连通点集合的最短距离</p>
<p><strong>算法模板</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">prim</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span> , <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))</span><br><span class="line">                t = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dist[t] == <span class="number">0x3f3f3f3f</span>)  <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dist[j] = min(dist[j], g[j][t]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kruskal-算法">11.2 kruskal 算法</h3>
<p><strong>时间复杂度</strong>：<span
class="math inline">\(O(mlogm)\)</span></p>
<p><strong>适用于</strong>：稀疏图</p>
<p><strong>伪代码描述</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sort(edge:<span class="number">1</span>~m)</span><br><span class="line"><span class="keyword">for</span> <span class="title function_">edge</span><span class="params">(a,b,w)</span>:1~m</span><br><span class="line">    <span class="keyword">if</span> a,b不连通</span><br><span class="line">        将边m加入集合中</span><br><span class="line"></span><br><span class="line">注：判断点是否连通使用并查集  </span><br></pre></td></tr></table></figure>
<p><strong>算法模板</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kruskal</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sort(edge, edge + m);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edge[i].a, b = edge[i].b, w = edge[i].w;</span><br><span class="line">        <span class="type">int</span> ua = find(a), ub = find(b);</span><br><span class="line">        <span class="keyword">if</span>(ua != ub)</span><br><span class="line">        &#123;</span><br><span class="line">            p[ua] = ub;</span><br><span class="line">            cnt ++;</span><br><span class="line">            res += w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分图">12. 二分图</h2>
<p>二分图：指顶点可以分成两个不相交的集合，使得同一个集合内的点不相邻（没有共同边）的图</p>
<h3 id="染色法判断二分图">12.1 染色法判断二分图</h3>
<p><strong>性质</strong>：一个图是二分图当且仅当图中不含有奇数环</p>
<p><strong>时间复杂度</strong>：<span class="math inline">\(O(n +
m)\)</span></p>
<p><strong>证明</strong>：</p>
<p>必要性：如果一个图是二分图，则该图中不含有奇数环。可以证明其逆否命题，如果一个图中含有奇数环，则该图一定不是二分图：</p>
<figure>
<img src="../images/数据结构模板/image-20240116120146686.png"
alt="image-20240116120146686" />
<figcaption aria-hidden="true">image-20240116120146686</figcaption>
</figure>
<p>充分性：如果一个图不含有奇数环，则该图是一个二分图。可以利用图中不含有奇数环的性质，来对二分图中的点进行染色：通过遍历图的顶点，并将相邻的顶点分配到不同的集合来完成。确保相邻顶点分属不同集合，因为不存在奇数环，这样就可以满足二分图的定义。染色法采用的方式就是这样。</p>
<p><strong>算法模板</strong>：</p>
<p>dfs 或者 bfs 均可，思路也比较简单。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(color[v] == <span class="number">-1</span>)             <span class="comment">// 未染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            color[v] = !color[u];</span><br><span class="line">            res &amp;= dfs(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[v] == color[u])  <span class="comment">//染色冲突</span></span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(!res) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意有些图并非所有顶点全部连通，需要在 dfs
外增加一个循环来将每一个连通子图的某个顶点传入 dfs 中。</p>
<h3 id="匈牙利算法求最大匹配数">12.2 匈牙利算法求最大匹配数</h3>
<blockquote>
<p>二分图的匹配：给定一个二分图 <span
class="math inline">\(G\)</span>，在 <span
class="math inline">\(G\)</span> 的一个子图 <span
class="math inline">\(M\)</span> 中，<span
class="math inline">\(M\)</span> 的边集 <span
class="math inline">\(\{E\}\)</span>
中的任意两条边都不依附于同一个顶点，则称 <span
class="math inline">\(\{M\}\)</span> 是一个匹配。</p>
<p>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p>
</blockquote>
<p>通俗的来说，将二分图两边的顶点看作一群男生和一群女生，顶点之间的连线
<span class="math inline">\(&lt;u,v&gt;\)</span> 表示男生 <span
class="math inline">\(u\)</span> 对女生 <span
class="math inline">\(v\)</span>
有好感，一个男生可能对多个女生有好感，多个男生也可能对同一个女生有好感，我们要做的工作就是“拉郎配”，根据好感关系，使得这群男生女生中凑出最大数量的情侣关系（一对一关系）。如下图：</p>
<figure>
<img src="../images/数据结构模板/image-20240117114928657.png"
alt="image-20240117114928657" />
<figcaption aria-hidden="true">image-20240117114928657</figcaption>
</figure>
<p><strong>时间复杂度</strong>：<span
class="math inline">\(O(nm)\)</span>，实际运行时间一般远小于<span
class="math inline">\(O(nm)\)</span></p>
<p><strong>算法模板</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[v])</span><br><span class="line">        &#123;</span><br><span class="line">            st[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[v] || find(match[v]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(st));</span><br><span class="line">    <span class="keyword">if</span>(find(i)) cnt ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>st 数组用来判断对于每一个左半部节点 u
寻找右半部节点的匹配时，是否已经判断过某个右半部节点 v，因此需要在进入
find 函数之前对 st 数组清零。</p>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法模板</title>
    <url>/2023/10/31/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="快速排序">1.快速排序</h2>
<p>时间复杂度：<span class="math inline">\(O(nlogn)\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x = a[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(a[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(a[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(l, j), <span class="built_in">quick_sort</span>(j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择第k大的数字quick_select">1.1
选择第K大的数字(quick_select)</h3>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_select</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> a[l];</span><br><span class="line">    <span class="type">int</span> x = a[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(a[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(a[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = j - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= k) <span class="keyword">return</span> <span class="built_in">quick_sort</span>(l, j, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quick_sort</span>(j + <span class="number">1</span>, r, k - cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="证明">1.1.1 证明</h4>
<p>快排的时间复杂度是<span
class="math inline">\(O(nlogn)\)</span>直观上还是好理解的，但是这个算法为什么不是<span
class="math inline">\(O(nlogn)\)</span>而是<span
class="math inline">\(O(n)\)</span>呢？</p>
<p>在平均情况下，第一次需要遍历<span
class="math inline">\(n\)</span>个数，第二次需要遍历<span
class="math inline">\(\frac{n}{2}\)</span>个数,...，即：</p>
<p><span class="math display">\[n + \frac{n}{2} + \frac{n}{4} + ... =
n(\frac{1}{2} + \frac{1}{4} + ...) = n\sum_{i=0}^{log_2^n}\frac{1}{2^i}
= 2n - 2 = O(n)\]</span></p>
<p>快速寻找相较快排每一次仅需要遍历一半的数量，所以复杂度降低了</p>
<h2 id="归并排序">2.归并排序</h2>
<p>时间复杂度：<span class="math inline">\(O(nlogn)\)</span></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, i = l, j = mid + <span class="number">1</span>, k = l;</span><br><span class="line">    <span class="built_in">merge_sort</span>(l, mid), <span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[j]) b[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> b[k++] = a[j++];</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) b[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)   b[k++] = a[j++];</span><br><span class="line">    <span class="keyword">for</span>(i = l; i &lt;= r; i++)  a[i] = b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求逆序对的数量">2.1 求逆序对的数量</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>, i = l, j = mid + <span class="number">1</span>, k = l;</span><br><span class="line">    LL cnt = <span class="built_in">merge_sort</span>(l, mid) + <span class="built_in">merge_sort</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt;= a[j]) b[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> b[k++] = a[j++], cnt += mid - i + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) b[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) b[k++] = a[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = l; i &lt;= r; i++) a[i] = b[i];</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分">3. 二分</h2>
<p>时间复杂度：<span class="math inline">\(O(logn)\)</span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(a[mid] &gt;= k)</span><br><span class="line">		r = mid;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(a[mid] &lt;= k)</span><br><span class="line">		l = mid;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了模板还需要说明的是在算法退出循环时，下标<code>l</code>总是在<strong>刚好能够满足</strong>if语句中条件的位置上。例如序列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 4 4 4 5 6 9，k=4</span><br></pre></td></tr></table></figure>
<p>如果条件为<code>if(a[mid] &gt;= k)</code>，则<code>l</code>会指向第一个4所在位置；而当条件为<code>if(a[mid] &gt; k)</code>时，则<code>l</code>会指向5所在的位置。</p>
<h2 id="高精度">4.高精度</h2>
<p>使用<code>string</code>将高精度数读入，然后将每一位依次放入<code>vector&lt;int&gt;</code>中。</p>
<h3 id="高精度加法">4.1 高精度加法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(max(a.size(), b.size()) + <span class="number">10</span>, <span class="number">0</span>)</span></span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++) c[i] += a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i ++) c[i] += b[i];</span><br><span class="line">    <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; c.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">        c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">        c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理前导零</span></span><br><span class="line">    <span class="keyword">while</span> (c.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; c.<span class="built_in">back</span>() == <span class="number">0</span>) c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度乘法">4.2 高精度乘法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(a.size() + b.size() + <span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; b.<span class="built_in">size</span>(); j++)</span><br><span class="line">            c[i + j] += a[i] * b[j];</span><br><span class="line">     <span class="comment">// 处理进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">        c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理前导零</span></span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; c.<span class="built_in">back</span>() == <span class="number">0</span>) c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度减法">4.3 高精度减法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a , vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>() != b.<span class="built_in">size</span>()) <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        <span class="keyword">if</span>(a[i] != b[i]) <span class="keyword">return</span> a[i] &gt; b[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>() || i &lt; b.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; a.<span class="built_in">size</span>()) t += a[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; b.<span class="built_in">size</span>()) t -= b[i];</span><br><span class="line">        c.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; !c.<span class="built_in">back</span>()) c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cmp</span>(a , b))  c = <span class="built_in">sub</span>(a , b);</span><br><span class="line"><span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;-&quot;</span>, c = <span class="built_in">sub</span>(b , a);</span><br></pre></td></tr></table></figure>
<h3 id="高精度除法">4.4 高精度除法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + a[i];</span><br><span class="line">        c.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// vector只能从末尾删除元素</span></span><br><span class="line">    <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; c.<span class="built_in">back</span>() == <span class="number">0</span>) c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前缀和-差分">5.前缀和 &amp; 差分</h2>
<h3 id="前缀和">5.1 前缀和</h3>
<h4 id="一维">(1) 一维</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; s[i];</span><br><span class="line">    s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h4 id="二维">(2) 二维</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i][j];</span><br><span class="line">        s[i][j] = s[i][j] + s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s[x2][y2] - s[x2][y1<span class="number">-1</span>] - s[x1<span class="number">-1</span>][y2] + s[x1<span class="number">-1</span>][y1<span class="number">-1</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="差分">5.2 差分</h3>
<h4 id="一维-1">(1) 一维</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; s[i];</span><br><span class="line">    a[i] = s[i] - s[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a[l] += c;  a[r + <span class="number">1</span>] -= c;</span><br></pre></td></tr></table></figure>
<h4 id="二维-1">(2) 二维</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; s[i][j];</span><br><span class="line">		a[i][j] = s[i][j] - s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j] + s[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">a[x1][y1] += c; a[x2+<span class="number">1</span>][y1] -= c;  a[x1][y2+<span class="number">1</span>] -= c; a[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br></pre></td></tr></table></figure>
<h2 id="离散化">6.离散化</h2>
<p>应用场景：元素的位置下标范围非常大，但是元素分布很稀疏个数不多</p>
<p>主要思路：将所有出现的元素的位置下标收集在数组alls中。<strong>假设排序后去重数组alls有n个元素，就将其映射到新的下标0~n-1，从而仅使用n个空间来存储下标范围远大于n的数</strong>，具体做法是传入元素位置下标，通过二分查找该下标在数组alls中的位置，从而输出新的下标</p>
<h3 id="例题区间求和">6.1 例题：区间求和</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;</span><br><span class="line">vector&lt;PII&gt; add, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &lt;= x)</span><br><span class="line">            l = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, x, c, l, r;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">// 收集使用到的所有元素的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">        add.<span class="built_in">push_back</span>(<span class="built_in">PII</span>(x, c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="built_in">PII</span>(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序 + 去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 先求出原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">find</span>(add[i].x);</span><br><span class="line">        s[idx] += add[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后求出前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; alls.<span class="built_in">size</span>(); i++)</span><br><span class="line">        s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 最后输出区间和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> lidx = <span class="built_in">find</span>(q[i].x), ridx = <span class="built_in">find</span>(q[i].y);</span><br><span class="line">        cout &lt;&lt; s[ridx] - s[lidx - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在排序和去重的步骤中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p><code>unique()</code>将<strong>相邻的重复元素</strong>移动到数组末尾，然后迭代器指向第一个重复元素的下标，因此<strong>需要先排序，然后去重</strong></p>
<h2 id="质数">7. 质数</h2>
<p>一个合数可以质数分解，则必然被前面的某个质数划去</p>
<p>任何一个合数只会被其最小质因子筛掉：</p>
<ol type="1">
<li><p><span class="math inline">\(i\  \% \ p[j] == 0\)</span></p>
<p><span class="math inline">\(p[j]\)</span> 一定是 <span
class="math inline">\(i\)</span> 的最小质因子，<span
class="math inline">\(p[j]\)</span> 一定是 <span
class="math inline">\(p[j] * i\)</span> 的最小质因子</p></li>
<li><p><span class="math inline">\(i \ \% \ p[j] \ != 0\)</span></p>
<p><span class="math inline">\(p[j]\)</span> 一定小于 <span
class="math inline">\(i\)</span> 的所有质因子，<span
class="math inline">\(p[j]\)</span> 也一定是 <span
class="math inline">\(p[j] * i\)</span> 的最小质因子</p></li>
</ol>
<p>任何一个合数都会被其最小质因子筛掉</p>
<p>对于一个合数 <span class="math inline">\(x\)</span>，假设 <span
class="math inline">\(p[j]\)</span> 是 <span
class="math inline">\(x\)</span> 的最小质因子，当 <span
class="math inline">\(i\)</span> 枚举到 <span
class="math inline">\(x\  / \ p[j]\)</span> 时，该合数就会被筛掉</p>
<p>任何一个合数有且仅有一个质因子</p>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程入门</title>
    <url>/2023/09/26/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="tcpudp网络通信流程图">1. TCP/UDP网络通信流程图</h2>
<h3 id="tcp">1.1 TCP</h3>
<figure>
<img src="../images/网络编程/image-20230926192207003.png"
alt="image-20230926192207003" />
<figcaption aria-hidden="true">image-20230926192207003</figcaption>
</figure>
<h4 id="代码">1.1.1 代码</h4>
<h5 id="server.c">server.c</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/sockaddr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKLOG 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECV_BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSocketServer;</span><br><span class="line">    <span class="type">int</span> iSocketClient;</span><br><span class="line">    <span class="type">int</span> iRet, iRecvLen, iClientCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">tSockServerAddr</span>, <span class="title">tSockClientAddr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clientAddrlen;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucRecvBuf[RECV_BUF_SIZE];</span><br><span class="line">   </span><br><span class="line">    <span class="type">socklen_t</span> server_addrlen;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对SIGCHLD信号的操作为忽略 */</span></span><br><span class="line">    signal(SIGCHLD,SIG_IGN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IPV4协议族，类型是可靠传输中的0号协议：TCP</span></span><br><span class="line">    iSocketServer = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == iSocketServer) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tSockServerAddr.sin_family = AF_INET;</span><br><span class="line">    tSockServerAddr.sin_port = htons(SERVER_PORT);  <span class="comment">// 转化主机字节序为网络字节序</span></span><br><span class="line">    tSockServerAddr.sin_addr.s_addr = INADDR_ANY;   <span class="comment">// 监测本机上所有IP</span></span><br><span class="line">    <span class="built_in">memset</span>(tSockServerAddr.sin_zero, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// Socket文件，监听的IP和端口，结构体的Size</span></span><br><span class="line">    iRet = bind(iSocketServer, (<span class="keyword">struct</span> sockaddr *)&amp;tSockServerAddr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == iRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind() failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Socket文件，最多允许多少路连接</span></span><br><span class="line">    iRet = listen(iSocketServer, BACKLOG);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == iRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen() failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start listen...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 服务端Socket文件，客户端地址结构体，结构体长度，成功则返回客户端的Socket文件</span></span><br><span class="line">        clientAddrlen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">        iSocketClient = accept(iSocketServer, (<span class="keyword">struct</span> sockaddr *)&amp;tSockClientAddr, &amp;clientAddrlen);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> != iSocketClient)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;accept success from client %d: %s\n&quot;</span>, ++iClientCnt, inet_ntoa(tSockClientAddr.sin_addr));</span><br><span class="line">            <span class="keyword">if</span>(!fork())  <span class="comment">//fork()对于子进程返回0，对于父进程返回子进程的PID</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 子进程 */</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* 接收客户端发送的数据并显示处理 */</span></span><br><span class="line">                    iRecvLen = recv(iSocketClient, &amp;ucRecvBuf, RECV_BUF_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(iRecvLen == <span class="number">-1</span> || iRecvLen == <span class="number">0</span>)  <span class="comment">//发生错误或者流关闭</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        close(iSocketClient);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        ucRecvBuf[iRecvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;recv string from %d: length %d and string %s\n&quot;</span>, iClientCnt, iRecvLen, ucRecvBuf);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(iSocketServer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="client.c">client.c</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/sockaddr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEND_BUF_SIZE 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSocketClient;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">tSockServerAddr</span>;</span></span><br><span class="line">    <span class="type">int</span> iRet, iSendLength;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucSendBuf[SEND_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s &lt;server_ip&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开一个Socket文件 */</span></span><br><span class="line">    iSocketClient = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == iSocketClient) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 连接到服务器 */</span></span><br><span class="line">    tSockServerAddr.sin_family = AF_INET;</span><br><span class="line">    tSockServerAddr.sin_port = htons(SERVER_PORT);  <span class="comment">// 转化主机字节序为网络字节序</span></span><br><span class="line">    <span class="keyword">if</span>( !inet_aton(argv[<span class="number">1</span>], &amp;tSockServerAddr.sin_addr) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP: %s is invalid!\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(tSockServerAddr.sin_zero, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    iRet = connect(iSocketClient, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;tSockServerAddr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == iRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error connecting\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 发送数据 */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(ucSendBuf, SEND_BUF_SIZE - <span class="number">1</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        iSendLength = send(iSocketClient, ucSendBuf, <span class="built_in">strlen</span>(ucSendBuf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == iSendLength)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error sending\n&quot;</span>);</span><br><span class="line">            close(iSocketClient);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 关闭Socket文件 */</span>   </span><br><span class="line">    close(iSocketClient);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="僵尸进程">1.1.2 僵尸进程</h4>
<p>如果<code>server.c</code>没有加入代码<code>signal(SIGCHLD,SIG_IGN);</code>，在先结束已经建立连接的客户端进程时，与之对应的服务端子进程就会产生如下图所示的情况，变成一个<strong>僵尸进程</strong>：</p>
<figure>
<img src="../images/网络编程/image-20230926223605756.png"
alt="image-20230926223605756" />
<figcaption aria-hidden="true">image-20230926223605756</figcaption>
</figure>
<h5 id="僵尸进程产生的原因">(1) 僵尸进程产生的原因</h5>
<p>当一个子进程终止时，它的进程表项仍然保留在系统中，直到父进程通过
<code>wait</code> 或者 <code>waitpid</code>
等系统调用来获取子进程的终止状态。如果父进程没有正确处理子进程终止的消息，那么子进程的进程表项就会一直保留下来，成为僵尸进程。僵尸进程会占用有限的系统资源，并且如果产生大量的僵尸进程，可能会导致系统资源耗尽。</p>
<p>而 <code>SIGCHLD</code>
信号是在子进程终止或者停止时发送给父进程的。默认情况下，父进程会忽略该信号，并不会自动处理僵尸进程。</p>
<h5 id="解决僵尸进程的一种方式">(2) 解决僵尸进程的一种方式</h5>
<p>当在父进程中调用 <code>signal(SIGCHLD, SIG_IGN)</code>
时，意味着设置了 <code>SIGCHLD</code>
信号的处理方式为忽略。这样，父进程在子进程终止时不会收到
<code>SIGCHLD</code>
信号，也不会产生僵尸进程。系统的init进程会立即回收子进程的资源，并且不需要父进程调用
<code>wait</code> 或者 <code>waitpid</code> 来处理子进程的终止状态。</p>
<h3 id="udp">1.2 UDP</h3>
<figure>
<img src="../images/网络编程/image-20230926192248900.png"
alt="image-20230926192248900" />
<figcaption aria-hidden="true">image-20230926192248900</figcaption>
</figure>
<h4 id="代码-1">1.2.1 代码</h4>
<h5 id="server.c-1">server.c</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/sockaddr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RECV_BUF_SIZE 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSocketServer, iRet, iRecvLen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">tSocketServerAddr</span>, <span class="title">tSocketClientAddr</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucRecvBuf[RECV_BUF_SIZE];</span><br><span class="line">    <span class="type">socklen_t</span> clientAddrLen;</span><br><span class="line"></span><br><span class="line">    iSocketServer = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == iSocketServer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tSocketServerAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    tSocketServerAddr.sin_family = AF_INET;</span><br><span class="line">    tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="built_in">memset</span>(tSocketServerAddr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(tSocketServerAddr.sin_zero));</span><br><span class="line">    iRet = bind(iSocketServer, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;tSocketServerAddr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == iRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start listen...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clientAddrLen = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">        iRecvLen = recvfrom(iSocketServer, ucRecvBuf, RECV_BUF_SIZE - <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;tSocketClientAddr, &amp;clientAddrLen);</span><br><span class="line">        <span class="keyword">if</span>(iRecvLen == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv error\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ucRecvBuf[iRecvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv string from %s: length %d and string %s\n&quot;</span>, inet_ntoa(tSocketClientAddr.sin_addr), iRecvLen, ucRecvBuf); </span><br><span class="line">    &#125;</span><br><span class="line">    close(iSocketServer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="client.c-1">client.c</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>         </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/sockaddr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_SEND_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> iSocketClient, iSendLen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">tSocketServerAddr</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucSendBuf[CLIENT_SEND_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;server_ip&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iSocketClient = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == iSocketClient) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!inet_aton(argv[<span class="number">1</span>], &amp;tSocketServerAddr.sin_addr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP: %s is invalid!\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tSocketServerAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    tSocketServerAddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">memset</span>(tSocketServerAddr.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(tSocketServerAddr.sin_zero));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(ucSendBuf, CLIENT_SEND_SIZE - <span class="number">1</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        iSendLen = sendto(iSocketClient, ucSendBuf, <span class="built_in">strlen</span>(ucSendBuf), <span class="number">0</span>, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;tSocketServerAddr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == iSendLen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Error sending\n&quot;</span>);</span><br><span class="line">            close(iSocketClient);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    close(iSocketClient);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>编写第一个驱动程序</title>
    <url>/2023/10/23/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="编写驱动程序的框架">1. 编写驱动程序的框架</h2>
<h3 id="app-打开的文件在内核中如何表示">1.1 APP
打开的文件在内核中如何表示</h3>
<p>APP 打开文件时，可以得到一个整数，这个整数被称为文件句柄。对于 APP
的每一个文件句柄，在内核里面都有一个<code>struct file</code>结构体与之对应:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br></pre></td></tr></table></figure>
<p>在APP中调用open函数打开文件时，传入的flags、mode等参数会记录在内核相应的<code>struct file</code>成员<code>f_flags\f_mode</code>中；读写文件的偏移地址也会保存在<code>struct file</code>结构体的<code>f_pos</code>成员中。</p>
<p>并且当APP中调用open函数时，会向下调用系统的sys_open函数，而sys_open函数又会根据主设备号来调用相应驱动的open函数；这些驱动函数的地址会保存在成员<code>file_operations</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">	<span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">	<span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br></pre></td></tr></table></figure>
<p>将上面描述的过程用一张图进行说明：</p>
<figure>
<img src="../images/编写第一个驱动程序/image-20231024200354443.png"
alt="image-20231024200354443" />
<figcaption aria-hidden="true">image-20231024200354443</figcaption>
</figure>
<h5 id="ps主设备号">PS：主设备号</h5>
<p>主设备号是内核模块分配给设备驱动程序的唯一标识符，用于标识特定设备的整数值，它由设备驱动程序进行分配。设备驱动程序通过主设备号将特定的操作转发给相应的驱动程序中断例程和文件操作函数。文件描述符是应用程序与打开的文件之间的连接，而主设备号是<strong>内核用于路由I/O请求到正确设备驱动程序的标识符</strong>。</p>
<h3 id="编写驱动程序的步骤">1.2 编写驱动程序的步骤</h3>
<ol type="1">
<li>确定主设备号，可以自己指定主设备号，也可以传入0，让内核给驱动程序分配主设备号</li>
<li>定义自己的 <code>file_operations</code> 结构体实现对应的
<code>drv_open/drv_read/drv_write</code> 等函数，填入
<code>file_operations</code> 结构体</li>
<li>把 <code>file_operations</code>
结构体告诉内核：使用<code>register_chrdev</code>函数</li>
<li>谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数</li>
<li>有入口函数就应该有出口函数：卸载驱动程序时，出口函数调用
<code>unregister_chrdev</code></li>
<li>其他完善：提供设备信息，自动创建设备节点：<code>class_create, device_create</code></li>
</ol>
<h3 id="驱动程序框架示例">1.3 驱动程序框架示例</h3>
<p><strong>字符设备驱动程序的框架</strong>：</p>
<figure>
<img src="../images/编写第一个驱动程序/image-20231129180502476.png"
alt="image-20231129180502476" />
<figcaption aria-hidden="true">image-20231129180502476</figcaption>
</figure>
<p><strong>代码示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm/uaccess.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/err.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/kdev_t.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/printk.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/stddef.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_open</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_close</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 确定主设备号   */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major_number = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kernel_buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) ((a &lt; b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 定义自己的file_operations结构体                                          */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = hello_drv_open,</span><br><span class="line">    .read = hello_drv_read,</span><br><span class="line">    .write = hello_drv_write,</span><br><span class="line">    .release = hello_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 实现对应的open/read/write等函数，填入file_operations结构体                   */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_open</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当前所在的源代码文件的文件名 当前所在的函数的名称 代码行号</span></span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    err = copy_to_user(buf, kernel_buf, MIN(size, <span class="number">1024</span>));</span><br><span class="line">    <span class="keyword">return</span> MIN(size, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    err = copy_from_user(kernel_buf, buf, MIN(size, <span class="number">1024</span>));</span><br><span class="line">    <span class="keyword">return</span> MIN(size, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_close</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4. 把file_operations结构体告诉内核：注册驱动程序  */</span></span><br><span class="line"><span class="comment">/* 5. 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">hello_device</span>;</span></span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="comment">// 注册驱动程序</span></span><br><span class="line">    major_number = register_chrdev(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv);</span><br><span class="line">    <span class="comment">// 创建类</span></span><br><span class="line">    hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(hello_class))   </span><br><span class="line">    &#123;</span><br><span class="line">        unregister_chrdev(major_number, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(hello_class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建设备节点：/dev/hello</span></span><br><span class="line">    hello_device = device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major_number, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(hello_device)) </span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(hello_device);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数   */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    device_destroy(hello_class, MKDEV(major_number, <span class="number">0</span>));</span><br><span class="line">    class_destroy(hello_class);</span><br><span class="line">    unregister_chrdev(major_number, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. 其他完善：提供设备信息，自动创建设备节点        */</span></span><br><span class="line">module_init(hello_init);  <span class="comment">//将hello_init修饰成驱动程序的入口函数</span></span><br><span class="line">module_exit(hello_exit);  <span class="comment">//将hello_exit修饰成驱动程序的出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);    <span class="comment">//声明遵守GPL协议</span></span><br></pre></td></tr></table></figure>
<p>相应的APP测试程序很简单，使用open()函数打开设备节点“/dev/hello”，然后调用read()/write()读取/写入数据即可。</p>
<h4 id="makefile">1.3.1 Makefile</h4>
<p>使用如下Makefile将.c文件交叉编译为内核驱动模块.ko文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KERN_DIR = /home/book/100ask_imx6ull_mini-sdk/Linux-4.9.88</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">   <span class="comment"># 使用make命令在KERN_DIR中构建内核模块，M=$(pwd)表示模块的源码路径为当前目录</span></span><br><span class="line">	make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules </span><br><span class="line">	<span class="variable">$(CROSS_COMPILE)</span>gcc -o hello_drv_test hello_drv_test.c </span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="comment"># 使用make命令在KERN_DIR中清理构建的内核模块</span></span><br><span class="line">	make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules clean</span><br><span class="line">	rm -rf modules.order</span><br><span class="line">	rm -f hello_drv_test </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将hello_drv.o加入obj-m列表，用于构建内核模块</span></span><br><span class="line">obj-m += hello_drv.o</span><br></pre></td></tr></table></figure>
<h4 id="测试">1.3.2 测试</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">insmod hello_drv.ko    //安装内核驱动模块</span><br><span class="line">cat /proc/devices     // 查看/proc/devices文件,该文件列出字符和块设备的主设备号,以及分配到这些设备号的设备名称</span><br><span class="line">lsmod                // 列出所有已安装的内核模块</span><br><span class="line">ls /dev/hello -l     // 查看设备节点是否存在</span><br><span class="line">rmmod hello_drv      // 卸载内核驱动模块</span><br><span class="line">dmesg                // 查看内核输出的打印信息</span><br></pre></td></tr></table></figure>
<h2 id="hello驱动程序的中的知识点">1.4 Hello驱动程序的中的知识点</h2>
<h4 id="module_initmodule_exit-的实现">1.4.1 module_init/module_exit
的实现</h4>
<p>一个驱动程序有入口/出口函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module_init(hello_init);  <span class="comment">//将hello_init修饰成驱动程序的入口函数</span></span><br><span class="line">module_exit(hello_exit);  <span class="comment">//将hello_exit修饰成驱动程序的出口函数</span></span><br></pre></td></tr></table></figure>
<p>驱动程序可以被直接编入内核，也可以被编译为ko文件后手工加载。对于这两种方式，<code>module_init/module_exit</code>宏是不一样的，在内核文件<code>include\linux\module.h</code>可以找到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MODULE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_init(x)	__initcall(x);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_exit(x)	__exitcall(x);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* MODULE */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Each module must use one module_init(). */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_init(initfn)					\</span></span><br><span class="line"><span class="meta">	static inline initcall_t __inittest(void)		\</span></span><br><span class="line"><span class="meta">	&#123; return initfn; &#125;					\</span></span><br><span class="line"><span class="meta">	int init_module(void) __attribute__((alias(#initfn)));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is only required if you want to be unloadable. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_exit(exitfn)					\</span></span><br><span class="line"><span class="meta">	static inline exitcall_t __exittest(void)		\</span></span><br><span class="line"><span class="meta">	&#123; return exitfn; &#125;					\</span></span><br><span class="line"><span class="meta">	void cleanup_module(void) __attribute__((alias(#exitfn)));</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h5 id="编译为ko文件">(1) 编译为ko文件</h5>
<p>编译驱动程序时，我们执行<code>make modules</code>这样的命令，它在编译
c 文件时会定义宏 <code>MODULE</code>，例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">arm-buildroot-linux-gnueabihf-gcc -DMODULE -c -o hello_drv.o hello_drv.c</span><br></pre></td></tr></table></figure>
<p>那么将else下面的宏展开之后可以得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline initcall_t __inittest(void) \ </span><br><span class="line">&#123; return hello_init; &#125; \ </span><br><span class="line">int init_module(void) __attribute__((alias(&quot;hello_init&quot;)));</span><br><span class="line"></span><br><span class="line">static inline exitcall_t __exittest(void) \ </span><br><span class="line">&#123; return hello_exit; &#125; </span><br><span class="line">\ void cleanup_module(void) __attribute__((alias(&quot;hello_exit&quot;)));</span><br></pre></td></tr></table></figure>
<p>分别定义了 2 个函数：第 1 个函数名为 <code>init_module</code>，它是
<code>hello_init</code> 函数的别名；第 2 个函数名为
<code>cleanup_module</code>，它是 <code>hello_exit</code> 函数的别名。
以后我们使用 <code>insmod</code> 命令加载驱动时，内核都是调用
<code>init_module</code> 函数， 实际上就是调用 <code>hello_init</code>
函数；使用 <code>rmmod</code> 命令卸载驱动时，内核都是调用
<code>cleanup_module</code> 函数，实际上就是调用 <code>hello_exit</code>
函数。</p>
<h5 id="编译进内核">(2) 编译进内核</h5>
<p>将#ifndef下面的宏展开之后可以得到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">initcall_t</span> __initcall_hello_init6 __used \ __attribute__((__section__(<span class="string">&quot;.initcall6.init&quot;</span>))) = hello_init; </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">exitcall_t</span> __exitcall_hello_exit __used __section(.exitcall.<span class="built_in">exit</span>) = hello_exit;</span><br></pre></td></tr></table></figure>
<p>其中的<code>initcall_t</code>、<code>exitcall_t</code>就是函数指针类型，所以上述代码就是定义了两个函数指针：第
1
个函数指针名为<code>__initcall_hello_init6</code>，放在段<code>.initcall6.init</code>里；第
2 个函数指针名为<code>__exitcall_hello_exit</code>，
放在段<code>.exitcall.exit</code>里。</p>
<p>内核启动时，会去段<code>.initcall6.init</code>里取出这些函数指针来执行，所以
驱动程序的入口函数就被执行了。</p>
<p>一个驱动被编进内核后，它是不会被卸载的，所以段<code>.exitcall.exit</code>
不会被用到，内核启动后会释放这块段空间。</p>
<h4 id="register_chrdev的内部实现">1.4.2 register_chrdev的内部实现</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __register_chrdev(major, <span class="number">0</span>, <span class="number">256</span>, name, fops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用<code>__register_chrdev</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __register_chrdev(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">unsigned</span> <span class="type">int</span> baseminor,</span><br><span class="line">		      <span class="type">unsigned</span> <span class="type">int</span> count, <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">		      <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">cd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">cdev</span>;</span></span><br><span class="line">	<span class="type">int</span> err = -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.查看chrdevs相应位置的空间是否被占用</span></span><br><span class="line">	cd = __register_chrdev_region(major, baseminor, count, name);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(cd))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(cd);</span><br><span class="line"></span><br><span class="line">	cdev = cdev_alloc();</span><br><span class="line">	<span class="keyword">if</span> (!cdev)</span><br><span class="line">		<span class="keyword">goto</span> out2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.将cdev结构体注册进入内核</span></span><br><span class="line">	cdev-&gt;owner = fops-&gt;owner;</span><br><span class="line">	cdev-&gt;ops = fops;</span><br><span class="line">	kobject_set_name(&amp;cdev-&gt;kobj, <span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">	err = cdev_add(cdev, MKDEV(cd-&gt;major, baseminor), count);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	cd-&gt;cdev = cdev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> major ? <span class="number">0</span> : cd-&gt;major;</span><br><span class="line">out:</span><br><span class="line">	kobject_put(&amp;cdev-&gt;kobj);</span><br><span class="line">out2:</span><br><span class="line">	kfree(__unregister_chrdev_region(cd-&gt;major, baseminor, count));</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5
id="register_chrdev_regionmajor-baseminor-count-name">（1）__register_chrdev_region(major,
baseminor, count, name)</h5>
<p><strong>作用</strong>：查看设备号<code>(major, baseminor)</code>到<code>(major, baseminor+count-1)</code>
有没有被占用，如果未被占用的话，就使用这块区域。</p>
<p>之前为了方便理解简化模型，认为内核里有一个 <code>chrdevs</code>
数组， 根据主设备号 <code>major</code> 在 <code>chrdevs[major]</code>
中放入 <code>file_operations</code> 结构体，以后
<code>open/read/write</code> 某个设备文件时，就是根据主设备号从
<code>chrdevs[major]</code> 中取出 <code>file_operations</code>
结构体，调用里面的 <code>open/read/write</code> 函数指针。</p>
<p>实际上，内核中确实有一个<code>chrdevs</code>数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> major;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> baseminor;</span><br><span class="line">	<span class="type">int</span> minorct;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">cdev</span>;</span>		<span class="comment">/* will die */</span></span><br><span class="line">&#125; *chrdevs[CHRDEV_MAJOR_HASH_SIZE];</span><br></pre></td></tr></table></figure>
<p>但是去访问它的时候，并不是直接使用主设备号 major
来确定数组项，而是使用如下函数来确定数组项：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* index in the above */</span> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">major_to_index</span><span class="params">(<span class="type">unsigned</span> major)</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">return</span> major % CHRDEV_MAJOR_HASH_SIZE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，<code>CHRDEV_MAJOR_HASH_SIZE</code> 等于
255。比如主设备号1、256， 都会使用 <code>chrdevs[1]</code> 。
<code>chrdevs[1]</code> 是一个链表，链表里有多个
<code>char_device_struct</code> 结构体，某个结构体表示主设备号为 1
的设备，某个结构体表示主设备号为 256 的设备，如下图：</p>
<p><img src="../images/编写第一个驱动程序/image-20231027203241612.png"
alt="image-20231027203241612" />·</p>
<ol type="1">
<li><p><code>chrdevs[i]</code>数组项是一个链表头，链表中的每一个元素都是<code>char_device_struct</code>结构体，每一个元素都表示一个驱动程序。<code>char_device_struct</code>结构体每一个成员表示如下：</p>
<ul>
<li><code>major</code>：主设备号</li>
<li><code>baseminor</code>：次设备号</li>
<li><code>minorct</code>：个数</li>
<li><code>cdev</code>：在<code>cdev</code>中含有<code>file_operations</code>结构体</li>
</ul></li>
<li><p>在上图中，<code>chrdevs[1]</code>中有3个驱动程序：</p>
<ul>
<li>第 1 个 <code>char_device_struct</code>
结构体对应主次设备号<code>(1, 0)、(1, 1)</code>，这 是第 1
个驱动程序。</li>
<li>第 2 个 <code>char_device_struct</code>
结构体对应主次设备号<code>(1, 2)、(1, 2)、......、 (1, 11)</code>，这是第
2 个驱动程序。</li>
<li>第 3 个 <code>char_device_struct</code>
结构体对应主次设备号<code>(256, 0)</code>，这是第 3 个驱动程序。</li>
</ul></li>
</ol>
<h5 id="cdev_addcdev-mkdevcd-major-baseminor-count">（2）cdev_add(cdev,
MKDEV(cd-&gt;major, baseminor), count)</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	p-&gt;dev = dev;</span><br><span class="line">	p-&gt;count = count;</span><br><span class="line"></span><br><span class="line">	error = kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>,</span><br><span class="line">			 exact_match, exact_lock, p);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	kobject_get(p-&gt;kobj.parent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数涉及 kobj 的操作，这是一个通用的链表操作函数。它的作用是： 把
<code>cdev</code> 结构体放入 <code>cdev_map</code>
链表中，对应的索引值是<code>dev</code>到<code>dev+count-1</code>。以后可以从
<code>cdev_map</code> 链表中快速地使用索引值取出对应的
<code>cdev</code>。</p>
<p>例如执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = cdev_add(cdev, MKDEV(<span class="number">1</span>, <span class="number">2</span>), <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>其中<code>MKDEV(1,2)</code>构造出一个整数<code>1&lt;&lt;8 | 2</code>；上述代码将结构体<code>cdev</code>放入<code>cdev_map</code>链表中，对应的索引值是<code>0x102</code>到<code>0x102+10</code>；根据<code>(0x102~0x102+10)</code>范围内的10个数值中的任意一个，都可以从<code>cdev_map</code>链表中取出<code>cdev</code>结构体。</p>
<p>APP
打开某个字符设备节点时，进入内核。在内核里根据字符设备节点的主、次设备号，计算出一个数值<code>major&lt;&lt;8 | minor</code>，即
<code>inode-&gt;i_rdev</code>，然后使用这个数值从 <code>cdev_map</code>
中快速得到 <code>cdev</code>，再从 <code>cdev</code> 中得到
<code>file_operations</code> 结构体。</p>
<p>关键函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called every time a character special file is opened</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">new</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;cdev_lock);</span><br><span class="line">	p = inode-&gt;i_cdev;</span><br><span class="line">	<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>;</span></span><br><span class="line">		<span class="type">int</span> idx;</span><br><span class="line">		spin_unlock(&amp;cdev_lock);</span><br><span class="line">		<span class="comment">// 1.根据设备号从cdev_map得到kobj</span></span><br><span class="line">		kobj = kobj_lookup(cdev_map, inode-&gt;i_rdev, &amp;idx);</span><br><span class="line">		<span class="keyword">if</span> (!kobj)</span><br><span class="line">			<span class="keyword">return</span> -ENXIO;</span><br><span class="line">		<span class="comment">// 2.将kobj转换为cdev</span></span><br><span class="line">		new = container_of(kobj, <span class="keyword">struct</span> cdev, kobj);</span><br><span class="line">		spin_lock(&amp;cdev_lock);</span><br></pre></td></tr></table></figure>
<h4 id="class_destroydevice_create浅析">1.4.3
class_destroy/device_create浅析</h4>
<p>驱动程序的核心是 <code>file_operations</code>
结构体：分配、设置、注册它。
<code>class_destroy/device_create</code>函数知识起一些辅助作用：在/sys
目录下创建一些目录、文件，这样 Linux 系统中的 APP(比如
udev、mdev)就可以根据这些目录或文件来创建设备节点。</p>
<p>以下代码将会在 /sys/class 目录下创建一个子目录 hello_class：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>以下代码会在 /sys/class/hello_class 目录下创建一个文件 hello：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure>
<img src="../images/编写第一个驱动程序/image-20231027222251531.png"
alt="image-20231027222251531" />
<figcaption aria-hidden="true">image-20231027222251531</figcaption>
</figure>
<h4 id="主次设备号">1.4.4 主次设备号</h4>
<p>字符设备的次设备号通常用于区分同一类型的不同设备实例，这些设备在类型上是相同的，但它们是不同的设备实例，通常代表不同的物理设备或虚拟设备，例如：</p>
<ol type="1">
<li><strong>串口设备</strong>：串口设备通常使用字符设备接口来表示。在一台计算机上，你可能会有多个串口，每个串口都有一个唯一的设备文件（例如
<code>/dev/ttyS0</code>,
<code>/dev/ttyS1</code>）。这些串口设备都属于相同的类型（串口设备），但是每个串口是不同的设备实例。</li>
<li><strong>磁盘分区</strong>：磁盘设备通常被划分成多个分区，每个分区都可以被视为一个不同的字符设备。这些分区都属于相同的磁盘类型，但每个分区是不同的设备实例。</li>
<li><strong>虚拟终端设备</strong>：虚拟终端设备（例如
<code>/dev/pts/0</code>,
<code>/dev/pts/1</code>）用于提供终端会话。每个虚拟终端代表一个不同的终端会话，尽管它们都属于相同的虚拟终端设备类型。</li>
<li><strong>网络设备</strong>：在某些情况下，网络设备也可以表示为字符设备。不同的网络接口（例如
<code>eth0</code>,
<code>eth1</code>）属于相同类型的字符设备，但它们是不同的设备实例，每个代表一个不同的网络接口。</li>
</ol>
<p>在这些情况下，主设备号通常用于标识设备类型，而次设备号用于区分不同的设备实例。这使得用户空间程序可以正确识别和与多个设备进行交互，而内核可以根据主设备号和次设备号来路由请求到适当的设备驱动程序。这种灵活性对于操作系统和应用程序来说非常重要，因为它们需要同时处理多个设备实例，每个实例都有不同的特性和状态。</p>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>输入系统应用编程</title>
    <url>/2023/09/17/%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="输入系统框架及调试">1. 输入系统框架及调试</h2>
<h3 id="框架概述">1.1 框架概述</h3>
<figure>
<img src="../images/输入系统应用编程/image-20230917174044630.png"
alt="image-20230917174044630" />
<figcaption aria-hidden="true">image-20230917174044630</figcaption>
</figure>
<ol type="1">
<li><p>APP 发起读操作，若无数据则休眠；</p></li>
<li><p>用户操作设备，硬件上产生中断；</p></li>
<li><p>输入系统驱动层对应的驱动程序处理中断：</p>
<p>读取到数据，转换为标准的输入事件，向核心层汇报。
所谓输入事件就是一个<code>input_event</code>结构体。</p></li>
<li><p>核心层可以决定把输入事件转发给上面哪个 handler 来处理：</p>
<ul>
<li><p>从 handler 的名字来看，它就是用来处输入操作的。有多种 handler，比
如：evdev_handler、kbd_handler、joydev_handler 等等。</p></li>
<li><p>最常用的是 evdev_handler：它只是把 input_event
结构体保存在内核buffer 等，APP 来读取时就原原本本地返回。它支持多个 APP
同时访问输入设备，每个 APP 都可以获得同一份输入事件。</p></li>
<li><p>当 APP 正在等待数据时，evdev_handler 会把它唤醒，这样 APP
就可以返回数据。</p></li>
</ul></li>
<li><p>APP 对输入事件的处理：</p></li>
<li><p>APP获得数据的方法有2种：直接访问设备节点(
比如<code>/dev/input/event0,1,2,...</code>)，或者通过<code>tslib、libinput</code>这类库来间接访问设备节点。这些库简化了对数据的处理。</p></li>
</ol>
<h3 id="编写app需要掌握的知识">1.2 编写APP需要掌握的知识</h3>
<h4 id="app可以得到什么数据">1.2.1 APP可以得到什么数据</h4>
<figure>
<img src="../images/输入系统应用编程/image-20230918201156815.png"
alt="image-20230918201156815" />
<figcaption aria-hidden="true">image-20230918201156815</figcaption>
</figure>
<ul>
<li><p><code>timeval</code>结构体：</p>
<ul>
<li><code>tv_sec</code>：表示自1970年1月1日00:00:00（即UNIX纪元起点）以来的秒数</li>
<li><code>tv_usec</code>：表示微秒数，即秒后面的零头</li>
</ul></li>
<li><p><code>input_event</code>结构体：</p>
<ul>
<li><p><code>type</code>：表示触发了哪类事件；比如<code>EV_KEY</code>表示按键类，<code>EV_REL</code>表示相对位移(例如鼠标)，<code>EV_ABS</code>
表示 绝对位置(比如触摸屏)</p>
<figure>
<img src="../images/输入系统应用编程/image-20230918202331798.png"
alt="image-20230918202331798" />
<figcaption aria-hidden="true">image-20230918202331798</figcaption>
</figure></li>
<li><p><code>code</code>：表示该类事件下的哪一个事件；例如<code>EV_KEY</code>表示键盘，键盘上有很多按键，每个分别对应不同事件：</p>
<figure>
<img src="../images/输入系统应用编程/image-20230918202559709.png"
alt="image-20230918202559709" />
<figcaption aria-hidden="true">image-20230918202559709</figcaption>
</figure>
<p>对于<code>EV_ABS</code>事件，触摸屏提供绝对位置信息，包括X，Y还有压力方向的值：</p>
<figure>
<img src="../images/输入系统应用编程/image-20230918202823767.png"
alt="image-20230918202823767" />
<figcaption aria-hidden="true">image-20230918202823767</figcaption>
</figure></li>
<li><p><code>value</code>：表示事件的值；例如按键的值可以是0(按下)或者1(松开)</p></li>
</ul></li>
</ul>
<h5 id="使用命令读取设备上报数据">(1) 使用命令读取设备上报数据</h5>
<p>调试输入系统时，直接执行类似下面的命令，然后操作对应的输入设备即可读出数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexdump /dev/input/event0</span><br></pre></td></tr></table></figure>
<p>部分输出如下：</p>
<figure>
<img src="../images/输入系统应用编程/image-20230918205712204.png"
alt="image-20230918205712204" />
<figcaption aria-hidden="true">image-20230918205712204</figcaption>
</figure>
<p>根据输出信息，结合<code>input-event-codes.h</code>，即可知道操作触发了那类事件中的那个事件，触发的值是什么</p>
<h5 id="事件的结尾标识">(2) 事件的结尾标识</h5>
<p>APP读取输入事件时，不同设备可能会上报不同数量的事件，但是所有设备的驱动程序都会在上报所有的数据之后，<strong>最后上报一个“同步事件”，表示数据上报完成</strong>。APP读到该事件时知道已经读完当前数据。<strong>“同步事件”也是一个<code>input_event</code>结构体，他的<code>type、code、value</code>属性都为0</strong>，如上图所示。</p>
<h4 id="查询开发板上有哪些设备节点">1.2.2
查询开发板上有哪些设备节点</h4>
<h5 id="使用命令查询设备节点">(1) 使用命令查询设备节点：</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /dev/input/* -l</span><br></pre></td></tr></table></figure>
<p>在开发板上输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crw-rw---- 1 root input 13, 64 Jan  1 00:00 /dev/input/event0</span><br><span class="line">crw-rw---- 1 root input 13, 65 Jan  1 00:00 /dev/input/event1</span><br></pre></td></tr></table></figure>
<h5 id="使用命令查询设备信息及其对应的设备节点">(2)
使用命令查询设备信息及其对应的设备节点</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/bus/input/devices</span><br></pre></td></tr></table></figure>
<p>部分输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I: Bus=0018 Vendor=dead Product=beef Version=28bb</span><br><span class="line">N: Name=&quot;goodix-ts&quot;                       //触摸屏</span><br><span class="line">P: Phys=input/ts</span><br><span class="line">S: Sysfs=/devices/virtual/input/input1</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=event1 evbug                 //设备节点：/dev/input/event1</span><br><span class="line">B: PROP=2</span><br><span class="line">B: EV=b</span><br><span class="line">B: KEY=1c00 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">B: ABS=6e18000 0</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>I：设备ID</p>
<p>该参数由结构体<code>input_id</code>来描述：</p>
<figure>
<img src="../images/输入系统应用编程/image-20230918210100361.png"
alt="image-20230918210100361" />
<figcaption aria-hidden="true">image-20230918210100361</figcaption>
</figure></li>
<li><p>N：设备名称</p></li>
<li><p>P：系统层次结构中设备的物理路径（physical path to the device in
the system hierarchy）</p></li>
<li><p>S：位于 sys 文件系统的路径（sysfs path）</p></li>
<li><p>U：设备的唯一标识码（unique identification code for the device(if
device has it)）</p></li>
<li><p>H：与设备关联的输入句柄列表（list of input handles associated
with the device）</p></li>
<li><p>B：位图（bitmaps）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PROP:device properties and quirks(设备属性) </span><br><span class="line">EV:types of events supported by the device(设备支持的事件类型) </span><br><span class="line">KEY:keys/buttons this device has(此设备具有的键/按钮) </span><br><span class="line">MSC:miscellaneous events supported by the device(设备支持的其他事件) </span><br><span class="line">LED:leds present on the device(设备上的指示灯)</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="理解位图">(3) 理解位图</h5>
<p>还是以上面的输出为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B: EV=b                             //b:1011</span><br><span class="line">B: KEY=1c00 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">B: ABS=6e18000 0                   //6e18000 0:0110 1110 0001 1000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<ul>
<li><code>EV=b</code>：根据其二进制第0，1，3位为1，可知其支持值为0，1，3这三类事件，查询<code>input-event-codes.h</code>可知其支持<code>EV_SYN</code>同步事件、<code>EV_KEY</code>按键事件、`EV_ABS绝对位移事件</li>
<li><code>ABS=6e18000 0</code>：根据下面<code>input_dev</code>结构体，可知每一个数据都是<code>unsigned long</code>为32位。同理得到其二进制表示，查询<code>input-event-codes.h</code>可知该设备具体支持绝对位移类事件中的哪些子事件</li>
</ul>
<h5 id="内核如何表示一个输入设备">(4) 内核如何表示一个输入设备</h5>
<p>使用 <code>input_dev</code> 结构体来表示输入设备：</p>
<figure>
<img src="../images/输入系统应用编程/image-20230918211408770.png"
alt="image-20230918211408770" />
<figcaption aria-hidden="true">image-20230918211408770</figcaption>
</figure>
<p>该数据结构和shell输出的设备信息正好对应。</p>
<h2 id="不使用库读取输入设备信息">2. 不使用库读取输入设备信息</h2>
<h3 id="获取输入设备基本信息">2.1 获取输入设备基本信息</h3>
<p>简单了解一下针对输入设备的使用ioctl()获取设备信息：</p>
<h4 id="获取input_id结构体">2.1.1 获取input_id结构体</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span></span><br><span class="line">err = ioctl(fd, EVIOCGID, &amp;id);</span><br></pre></td></tr></table></figure>
<p>一般ioctl()函数在成功时返回0，失败时返回-1；在个别情况下，返回值也包含有效信息（例如读取到的字节数）。继续向下寻找<code>EVIOCGID</code>的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* /include/linux/input.h         */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVIOCGID		_IOR(<span class="string">&#x27;E&#x27;</span>, 0x02, struct input_id)	<span class="comment">/* get device ID */</span></span></span><br><span class="line"><span class="comment">/* /include/asm-generic/ioctl.h    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC(dir,type,nr,size) \</span></span><br><span class="line"><span class="meta">	(((dir)  &lt;&lt; _IOC_DIRSHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((type) &lt;&lt; _IOC_TYPESHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((nr)   &lt;&lt; _IOC_NRSHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((size) &lt;&lt; _IOC_SIZESHIFT))</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>dir</code>：为<code>_IOC_READ</code>表示APP要读数据，为<code>_IOC_WRITE</code>表示APP要写数据</li>
<li><code>size</code>：表示ioctl能传输数据的<strong>最大字节数</strong></li>
<li><code>type、nr</code> 的含义由具体的驱动程序决定</li>
</ul>
<h4 id="获取evbit数组支持哪几类事件">2.1.2
获取evbit数组(支持哪几类事件)</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> evbit[<span class="number">2</span>];</span><br><span class="line">len = ioctl(fd, EVIOCGBIT(<span class="number">0</span>, <span class="keyword">sizeof</span>(evbit)), &amp;evbit);   <span class="comment">// sizeof返回的是字节数</span></span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; len &lt;= <span class="keyword">sizeof</span>(evbit))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;support ev type: &quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		byte = ((<span class="type">unsigned</span> <span class="type">char</span> *)evbit) [i];</span><br><span class="line">		<span class="keyword">for</span> (bit = <span class="number">0</span>; bit &lt; <span class="number">8</span>; bit++)</span><br><span class="line">			<span class="keyword">if</span> (byte &amp; (<span class="number">1</span>&lt;&lt;bit)) </span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, ev_names[i*<span class="number">8</span> + bit]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据宏定义<code>EV_MAX=0x1f</code>理论上来说，一个int足矣存放下所有事件类型。继续寻找<code>EVIOCGBIT</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EVIOCGBIT(ev,len)	_IOC(_IOC_READ, <span class="string">&#x27;E&#x27;</span>, 0x20 + (ev), len) <span class="comment">/* get event bits */</span></span></span><br></pre></td></tr></table></figure>
<p>之所以<code>EVIOCGBIT(0, sizeof(evbit))</code>传入参数0，原因在内核驱动代码中，不过做应用只需要按照如下对应关系传入参数即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REL			0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_ABS			0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_MSC			0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SW			0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_LED			0x11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SND			0x12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REP			0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF			0x15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_PWR			0x16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF_STATUS		0x17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_MAX			0x1f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_CNT			(EV_MAX+1)</span></span><br></pre></td></tr></table></figure>
<h3 id="获取输入设备的事件信息">2.2 获取输入设备的事件信息</h3>
<p>获取输入设备事件信息的四种方式：</p>
<ol type="1">
<li>查询：</li>
<li>休眠-唤醒</li>
<li>POLL/SELECT</li>
<li>异步通知方式</li>
</ol>
<h4 id="查询和休眠-唤醒方式">2.2.1 查询和休眠-唤醒方式</h4>
<ul>
<li>所谓查询就是<strong>以非阻塞方式(O_NONBLOCK)打开设备文件</strong>，在死循环中使用<code>read</code>函数不停的读取文件内容；如果读取到就返回数据，否则就返回失败</li>
<li>而休眠-唤醒则是<strong>以阻塞方式打开设备文件</strong>。如果文件中没有数据，则APP就会在内核态休眠，有数据时驱动程序会把
APP 唤醒，read 函数恢复执行并返回数据给 APP</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">3</span> &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;noblock&quot;</span>))</span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR | O_NONBLOCK);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	len = read(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="keyword">sizeof</span>(event))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\n&quot;</span>, event.type, event.code, event.value);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;read err %d\n&quot;</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pollselect方式">2.2.2 POLL/SELECT方式</h4>
<p>poll()和select()类似，用来等待判断所监视的文件是否准备好了文件I/O。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Type used for the number of file descriptors.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">nfds_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当成功时返回一个正数，表示具有非零revents字段的数量（每个事件对应revents中的1bit）。返回0表示超时；出现错误时返回-1，并设置errno</p></li>
<li><p>poll可以监视的文件事件类型有：</p></li>
</ul>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="header">
<th>事件类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>POLLIN</strong></td>
<td>有数据可读</td>
</tr>
<tr class="even">
<td>POLLRDNORM</td>
<td>等同于 POLLIN</td>
</tr>
<tr class="odd">
<td>POLLRDBAND</td>
<td>Priority band data can be read，有优先级较较高的“band data”可读
Linux 系统中很少使用这个事件</td>
</tr>
<tr class="even">
<td>POLLPRI</td>
<td>高优先级数据可读</td>
</tr>
<tr class="odd">
<td><strong>POLLOUT</strong></td>
<td>可以写数据</td>
</tr>
<tr class="even">
<td>POLLWRNORM</td>
<td>等同于 POLLOUT</td>
</tr>
<tr class="odd">
<td>POLLWRBAND</td>
<td>Priority data may be written</td>
</tr>
<tr class="even">
<td>POLLERR</td>
<td>发生了错误</td>
</tr>
<tr class="odd">
<td>POLLHUP</td>
<td>挂起</td>
</tr>
<tr class="even">
<td>POLLNVAL</td>
<td>无效的请求，一般是 fd 未 open</td>
</tr>
</tbody>
</table>
<p>核心代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line"><span class="type">nfds_t</span> nfds = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">fds[<span class="number">0</span>].fd = fd;</span><br><span class="line">fds[<span class="number">0</span>].events  = POLLIN;</span><br><span class="line">fds[<span class="number">0</span>].revents = <span class="number">0</span>;   <span class="comment">// 先置位，防止随机值干扰</span></span><br><span class="line">ret = poll(fds, nfds, <span class="number">5000</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (fds[<span class="number">0</span>].revents == POLLIN)</span><br><span class="line">		<span class="keyword">while</span> (read(fd, &amp;event, <span class="keyword">sizeof</span>(event)) == <span class="keyword">sizeof</span>(event))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\n&quot;</span>, event.type, event.code, event.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;time out\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;poll err\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="异步通知方式">2.2.3 异步通知方式</h4>
<p>上面三种方式都是<strong>同步方式</strong>，APP只能等待驱动程序发送数据，这期间不能做其他事情。而<strong>异步通知方式</strong>就是APP可以做其他事情，驱动有数据之后会给APP发信号，APP收到信息执行相应的信号处理函数，类似于中断</p>
<p>考虑异步通知的实现细节：</p>
<ol type="1">
<li><p>信号的类型是什么？</p>
<p>在<code>include/uapi/asm-generic/signal.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIGHUP		 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGINT		 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGQUIT		 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGILL		 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGTRAP		 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGABRT		 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGIOT		 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGBUS		 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGFPE		 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGKILL		 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGUSR1		10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGSEGV		11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGUSR2		12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGPIPE		13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGALRM		14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGTERM		15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGSTKFLT	16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGCHLD		17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGCONT		18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGSTOP		19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGTSTP		20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGTTIN		21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGTTOU		22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGURG		23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGXCPU		24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGXFSZ		25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGVTALRM	26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGPROF		27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGWINCH	28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGIO		29</span></span><br></pre></td></tr></table></figure>
<p>一般IO事件常用信号类型是<code>SIGIO</code>，表示有IO事件需要处理</p></li>
<li><p>APP收到信号之后，应该调用什么函数进行处理？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>
<p>使用signal()函数将将信号关联到信号处理程序</p></li>
<li><p>APP和驱动程序之间如何建立联系？</p>
<p>APP中可以打开设备文件；驱动程序需要得知APP的进程号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">int fcntl(int fd, int cmd, ... /* arg */ );</span><br></pre></td></tr></table></figure>
<ul>
<li>fcntl()用来执行由<code>cmd</code>参数描述的一种针对文件fd的操作。arg参数是否需要，是什么类型由<code>cmd</code>决定</li>
<li>例如<code>cmd</code>的值为<code>F_SETOWN (int)</code>，表示设置文件fd上的<code>SIGIO</code>和<code>SIGURG</code>信号的进程ID/进程组ID为arg的值。最常用的做法是调用进程将自己指定为所有者<code>getpid()</code></li>
<li>返回值：对于<code>F_SENTOWN</code>成功返回0，错误返回-1</li>
</ul></li>
<li><p>驱动程序使能异步通知功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FASYNC  O_ASYNC</span></span><br><span class="line"></span><br><span class="line">flags = fcntl(fd, F_GETFL);</span><br><span class="line">fcntl(fd, F_SETFL, flags | FASYNC);  <span class="comment">// 设置FASYNC位，使能异步通知功能</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>F_GETFL (void)</code>：将文件访问模式和文件状态标志作为返回值进行返回，<code>arg</code>参数为void</li>
<li><code>F_SETFL (int)</code>：将文件状态标志设置为arg参数的值。忽略访问模式位<code>O_RDONLY, O_WRONLY, O_RDWR</code>和文件创建标志位<code>O_CREAT,O_EXCL,O_NOCTTY,O_TRUNC</code>，该命令仅能修改<code>O_APPEND, O_ASYNC, O_DIRECT, O_NOATIME, O_NONBLOCK</code></li>
</ul></li>
</ol>
<p>核心代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_sig_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">	<span class="keyword">while</span> (read(fd, &amp;event, <span class="keyword">sizeof</span>(event)) == <span class="keyword">sizeof</span>(event))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\n&quot;</span>, event.type, event.code, event.value);		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册信号处理函数 */</span></span><br><span class="line">signal(SIGIO, my_sig_handler);</span><br><span class="line"><span class="comment">/* 打开驱动程序 */</span></span><br><span class="line">fd = open(argv[<span class="number">1</span>], O_RDWR | O_NONBLOCK);	</span><br><span class="line"><span class="comment">/* 把APP的进程号告诉驱动程序 */</span></span><br><span class="line">fcntl(fd, F_SETOWN, getpid());</span><br><span class="line"><span class="comment">/* 使能&quot;异步通知&quot; */</span></span><br><span class="line">flags = fcntl(fd, F_GETFL);</span><br><span class="line">fcntl(fd, F_SETFL, flags | FASYNC);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;main loop count = %d\n&quot;</span>, count++);</span><br><span class="line">	sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>驱动程序的必要基础</title>
    <url>/2024/01/09/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BF%85%E8%A6%81%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="休眠与唤醒">1. 休眠与唤醒</h2>
<h3 id="使用示例">1.1 使用示例</h3>
<p>使用休眠-唤醒机制来编写按键驱动程序：</p>
<ol type="1">
<li>APP 调用 read 等函数试图读取数据，比如读取按键；</li>
<li>APP
进入内核态，也就是调用驱动中的对应函数，发现有数据则复制到用户空间并马上返回；</li>
<li>如果 APP 在内核态，也就是在驱动程序中发现没有数据，则 APP
休眠，进程/线程状态改为非 Running；</li>
<li>当有数据时，比如当按下按键时，驱动程序的中断服务程序被调用，它会记录数据、将
APP 的进程/线程状态修改为 Running；</li>
<li>调度器调度 APP
继续运行它的内核态代码，也就是驱动程序中的函数，复制数据到用户空间并马上返回。</li>
</ol>
<p>如下图所示：</p>
<figure>
<img src="../images/驱动程序的必要基础/image-20240109100440021.png"
alt="image-20240109100440021" />
<figcaption aria-hidden="true">image-20240109100440021</figcaption>
</figure>
<h3 id="内核函数">1.2 内核函数</h3>
<blockquote>
<p>参考内核源码：include.h</p>
</blockquote>
<h4 id="休眠函数">1.2.1 休眠函数</h4>
<table>
<colgroup>
<col style="width: 48%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>wait_event_interruptible(wq, condition)</td>
<td>休眠，直到 condition 为真；
休眠期间是可被打断的，可以被信号打断</td>
</tr>
<tr class="even">
<td>wait_event(wq, condition)</td>
<td>休眠，直到 condition 为真； 退出的唯一条件是 condition
为真，信号也不好使</td>
</tr>
<tr class="odd">
<td>wait_event_interruptible_timeout(wq, condition, timeout)</td>
<td>休眠，直到 condition 为真或超时；
休眠期间是可被打断的，可以被信号打断</td>
</tr>
<tr class="even">
<td>wait_event_timeout(wq, condition, timeout)</td>
<td>休眠，直到 condition 为真； 退出的唯一条件是 condition
为真，信号也不好使</td>
</tr>
</tbody>
</table>
<ul>
<li><p>wq 是指 waitqueue，等待队列，休眠时除了把程序状态改为非 RUNNING
之外，还要把进程/进程放入 wq 中，以后中断服务程序要从 wq
中把它取出来唤醒。声明等待队列头的源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __WAIT_QUEUE_HEAD_INITIALIZER(name) &#123;				\</span></span><br><span class="line"><span class="meta">	.lock		= __SPIN_LOCK_UNLOCKED(name.lock),		\</span></span><br><span class="line"><span class="meta">	.task_list	= &#123; &amp;(name).task_list, &amp;(name).task_list &#125; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WAIT_QUEUE_HEAD(name) \</span></span><br><span class="line"><span class="meta">	wait_queue_head_t name = __WAIT_QUEUE_HEAD_INITIALIZER(name)</span></span><br></pre></td></tr></table></figure>
<p>只需要调用宏 <code>DECLARE_WAIT_QUEUE_HEAD</code>
就可以将一个变量修饰为等待队列头</p></li>
<li><p>condition 可以是一个变量，也可以是任何表达式。表示“一直等待，直到
condition 为 TRUE ”。</p></li>
</ul>
<h4 id="唤醒函数">1.2.2 唤醒函数</h4>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>wake_up_interruptible(x)</td>
<td>唤醒 x
队列中状态为“TASK_INTERRUPTIBLE”的线程，只唤醒其中的一个线程</td>
</tr>
<tr class="even">
<td>wake_up_interruptible_nr(x, nr)</td>
<td>唤醒 x 队列中状态为“TASK_INTERRUPTIBLE”的线程，只唤醒其中的 nr
个线程</td>
</tr>
<tr class="odd">
<td>wake_up_interruptible_all(x)</td>
<td>唤醒 x
队列中状态为“TASK_INTERRUPTIBLE”的线程，唤醒其中的所有线程</td>
</tr>
<tr class="even">
<td>wake_up(x)</td>
<td>唤醒 x 队列中状态为 “ TASK_INTERRUPTIBLE ”或
“TASK_UNINTERRUPTIBLE”的线程，只唤醒其中的一个线程</td>
</tr>
<tr class="odd">
<td>wake_up_nr(x, nr)</td>
<td>唤醒 x 队列中状态为“TASK_INTERRUPTIBLE ”或
“TASK_UNINTERRUPTIBLE”的线程，只唤醒其中 nr 个线程</td>
</tr>
<tr class="even">
<td>wake_up_all(x)</td>
<td>唤醒 x 队列中状态为 “ TASK_INTERRUPTIBLE ”或
“TASK_UNINTERRUPTIBLE”的线程，唤醒其中的所有线程</td>
</tr>
</tbody>
</table>
<h3 id="使用休眠-唤醒机制编写按键驱动">1.3
使用休眠-唤醒机制编写按键驱动</h3>
<p>主要步骤如下图：</p>
<figure>
<img src="../images/驱动程序的必要基础/image-20240109103704728.png"
alt="image-20240109103704728" />
<figcaption aria-hidden="true">image-20240109103704728</figcaption>
</figure>
<p>代码：</p>
<p>内核模块init/exit，platform_driver 的
probe/remove，中断的声明和注册，都和之前类似，主要代码是 file_operations
中的操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;   <span class="comment">// 声明等待队列头</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val, key;</span><br><span class="line">	</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);   <span class="comment">// 有数据，唤醒休眠进程/线程</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err, key;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());  <span class="comment">//根据队列是否空，决定是否进入休眠状态，并将进程/线程放入等待队列中</span></span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码中使用 <code>put_key,get_key</code>
等函数封装了循环队列，用以保存 APP 程序未运行时的按键数据。APP
程序仅需要打开设备文件之后，一直读取即可。</p>
<h2 id="poll-机制">2. POLL 机制</h2>
<h3 id="使用示例-1">2.1 使用示例</h3>
<p>使用 POLL 机制来编写按键驱动程序：</p>
<ol type="1">
<li>APP 不知道驱动程序中是否有数据，可以先调用 poll 函数查询一下，poll
函数可以传入<strong>超时时间</strong></li>
<li>APP 进入内核态，调用驱动程序的 poll
函数，如果有数据则立刻返回；否则就休眠一段时间。</li>
<li>当有数据时，比如当按下按键时，驱动程序的中断服务程序被调用，它会记录数据、唤醒
APP；或者当超时时间到了之后，内核也会唤醒 APP</li>
<li><strong>APP 根据 poll
函数的返回值就可以知道是否有数据，如果有数据就调用 read
得到数据</strong></li>
</ol>
<p>如下图所示：</p>
<figure>
<img src="../images/驱动程序的必要基础/image-20240109114754933.png"
alt="image-20240109114754933" />
<figcaption aria-hidden="true">image-20240109114754933</figcaption>
</figure>
<p>注意事项：</p>
<ol type="1">
<li>内核函数 <code>sys_poll</code> 封装了实现 poll
机制的步骤，仅需要用户<strong>将线程放入等待队列，并返回判断条件 event
的状态</strong>即可</li>
<li>通过上图中 <code>sys_poll</code> 的伪代码示例，用户提供的
<code>drv_poll</code> 可能会被调用两次，使用内核函数
<code>poll_wait</code> 把线程挂入队列，如果线程已经在队列里
了，它就不会再次挂入，避免重复挂入相同的线程。</li>
</ol>
<h3 id="应用编程">2.2 应用编程</h3>
<p>APP 可以调用 poll 或者 select 函数，这 2
个函数的作用是一致的。poll/select
函数可以监测多个文件，可以监测多种事件：</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 7%" />
<col style="width: 78%" />
</colgroup>
<thead>
<tr class="header">
<th>宏</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>POLLIN</td>
<td>0x0001</td>
<td>表示可读数据，即文件描述符有数据可读</td>
</tr>
<tr class="even">
<td>POLLPRI</td>
<td>0x0002</td>
<td>表示有紧急数据可读，通常用于表示带外（out-of-band）数据的到达</td>
</tr>
<tr class="odd">
<td>POLLOUT</td>
<td>0x0004</td>
<td>表示可写数据，即文件描述符可以接受写入数据</td>
</tr>
<tr class="even">
<td>POLLERR</td>
<td>0x0008</td>
<td>表示发生错误，文件描述符处于错误状态</td>
</tr>
<tr class="odd">
<td>POLLHUP</td>
<td>0x0010</td>
<td>表示挂起，即文件描述符被挂起连接</td>
</tr>
<tr class="even">
<td>POLLNVAL</td>
<td>0x0020</td>
<td>表示文件描述符非法，即未打开的文件描述符</td>
</tr>
<tr class="odd">
<td>POLLRDNORM</td>
<td>0x0040</td>
<td>等同于 POLLIN</td>
</tr>
<tr class="even">
<td>POLLRDBAND</td>
<td>0x0080</td>
<td>Priority band data can be read，有优先级较较高的“band data”可读</td>
</tr>
<tr class="odd">
<td>POLLWRNORM</td>
<td>0x0100</td>
<td>等同于 POLLOUT</td>
</tr>
<tr class="even">
<td>POLLWRBAND</td>
<td>0x0200</td>
<td>Priority data may be written</td>
</tr>
</tbody>
</table>
<p><strong>系统调用</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>返回值：</p>
<ul>
<li>成功返回正数，表示就绪的文件描述符的数量，每个就绪的文件描述符的具体就绪事件则通过revents
字段来表示。内核中 poll 机制的实现主要是对所有传入文件调用驱动提供的
file_operations.poll
函数；<strong>循环调用一边之后，如果存在产生事件的文件则直接返回，否则进入休眠（APP
中可根据返回数量来循环检查是哪些文件产生相应事件）；当超时时间到或者中断唤醒后进行第二轮循环调用。</strong></li>
<li>返回0表示调用超时，并且没有准备好任何文件描述符。</li>
<li>出现错误时，返回 -1</li>
</ul></li>
<li><p>events 表示请求的事件，revents 表示返回的事件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mask = f.file-&gt;f_op-&gt;poll(f.file, pwait);</span><br><span class="line"><span class="comment">/* Mask out unneeded events. */</span> 			</span><br><span class="line">mask &amp;= pollfd-&gt;events | POLLERR | POLLHUP;</span><br></pre></td></tr></table></figure>
<p>内核中会将 file_operations.poll 函数返回的事件 mask 和请求的事件
events相与，<code>POLLERR | POLLHUP</code> 是两个严重事件，所以无论
APP有没有请求，只要这两个事件发生就一定会返回</p></li>
</ul>
<p><strong>主要代码</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line"><span class="type">int</span> timeout_ms = <span class="number">5000</span>;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">fds[<span class="number">0</span>].fd = fd;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">ret = poll(fds, <span class="number">1</span>, timeout_ms);</span><br><span class="line"><span class="keyword">if</span> ((ret == <span class="number">1</span>) &amp;&amp; (fds[<span class="number">0</span>].revents &amp; POLLIN))</span><br><span class="line">&#123;</span><br><span class="line">    read(fd, &amp;val, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get button : 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="驱动编程">2.3 驱动编程</h3>
<p>实现 poll 机制，只需要在 file_operations.poll 函数中做两件事情：</p>
<ol type="1">
<li>将线程放入等待队列（调用 poll_wait
函数可以自动将线程放入，并且不会重复放入）</li>
<li>返回正确的 POLL 事件 <strong>（事件列表如 2.2
节，如果没有任何事件发生，则返回 0 ）</strong></li>
</ol>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其余部分与 1.3 节中的代码一致。</p>
<blockquote>
<p>注：(POLLIN | POLLRDNORM) 或 (POLLOUT | POLLWRNORM)
一般一起返回，之所以需要加上 POLLRDNORM 和 POLLWRNORM 是为了兼容某些
APP</p>
</blockquote>
<h2 id="异步通知">3.异步通知</h2>
<p>使用 POLL 机制来编写按键驱动程序：</p>
<ol type="1">
<li>APP 使用 <code>signal</code>
函数注册信号量对应的处理函数，并打开自己的设备文件。</li>
<li>APP 调用 <code>fcntl</code> 将自己的进程号写入内核文件系统，然后调用
<code>fcntl</code> 为设备文件添加 <code>FASYNC</code>
标志位；此后，APP可以处理其他工作，直到收到驱动发送的信号。</li>
<li>驱动应提供 <code>file_operations.fasync</code>函数，当设备文件 Flag
内的 <code>FASYNC</code>标志位变化时，会导致驱动程序的
<code>fasync</code> 函数被调用</li>
<li><code>faync</code> 函数需要调用内核函数 <code>faync_helper</code>
，它会根据 <code>FASYNC</code> 的值设置
<code>button_async-&gt;fa_file=filp or NULL</code> ，<code>filp</code>
结构体中包含之前 APP 写入的进程号</li>
<li>当触发按键中断之后，可以在中断中提供 <code>kill_fasync</code>
函数发信号</li>
<li>APP 收到信号之后，自动调用信号处理函数，可以在处理函数中调用 read
函数读取按键</li>
</ol>
<p>如下图所示：</p>
<figure>
<img src="../images/驱动程序的必要基础/image-20240110112150973.png"
alt="image-20240110112150973" />
<figcaption aria-hidden="true">image-20240110112150973</figcaption>
</figure>
<h3 id="应用编程-1">3.1 应用编程</h3>
<p><strong>系统调用-signal</strong> ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>主要代码</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_func</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	read(fd, &amp;val, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;get button : 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.注册信号处理函数</span></span><br><span class="line"> 	signal(SIGIO, sig_func);</span><br><span class="line">    <span class="comment">// 2.打开设备文件 </span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 3.在内核sys_fasync函数中写入pid</span></span><br><span class="line">    fcntl(fd, F_SETOWN, getpid());</span><br><span class="line">    <span class="comment">// 4.为设备文件添加 FASYNC 位</span></span><br><span class="line">    flags = fcntl(fd, F_GETFL);</span><br><span class="line">    fcntl(fd, F_SETFL, flags | FASYNC);</span><br><span class="line">    <span class="comment">// 5.处理其他事务</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;www.100ask.net \n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="驱动编程-1">3.2 驱动编程</h3>
<p>可参考 1.3
节，为了实现异步通知机制，仅需要提供<code>file_operations.fasync</code>函数，并在中断函数中调用
<code>kill_fasync</code>函数发送信号进行通知：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// fasync_helper 会分配构造 button_fasync，fasync_struct 结构体中包含 PID</span></span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	<span class="comment">// 发送IO信号，发送IO信号的原因是 POLL_IN 有数据可读</span></span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="阻塞和非阻塞">4.阻塞和非阻塞</h2>
<p>APP 可以基于 POLL 机制进行休眠，也可以在调用 open 函数时传入
O_NONBLOCK
<strong>表示使用非阻塞模式打开文件（默认是阻塞方式）</strong>。POLL
机制的实现需要驱动程序支持，而以非阻塞方式打开文件，同样需要：</p>
<blockquote>
<ol type="1">
<li><p>对于普通文件、块设备文件，O_NONBLOCK 不起作用。</p></li>
<li><p>对于字符设备文件，O_NONBLOCK
起作用的前提是驱动程序针对该标志位做了对应处理。</p></li>
</ol>
</blockquote>
<p>在内核的文件系统层会为设备文件创建一个 <code>struct file</code>
结构体，该结构体中的成员 <code>f_flags</code> 表示设备文件的标志，对于
APP 可以在 open 时以相应的标志打开文件，也可以通过 fcntl
函数来设置设备文件的标志位：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(argv[<span class="number">1</span>], O_RDWR | O_NONBLOCK);   </span><br><span class="line"></span><br><span class="line">flags = fcntl(fd, F_GETFL);</span><br><span class="line">fcntl(fd, F_SETFL, flags &amp; ~O_NONBLOCK);</span><br></pre></td></tr></table></figure>
<p>对于驱动程序可以通过判断 <code>f_flags</code> 是否含有 O_NONBLOCK
标志位，并进行相应操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (file-&gt;f_flags &amp; O_NONBLOCK)</span><br></pre></td></tr></table></figure>
<h3 id="应用程序">4.1 应用程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(argv[<span class="number">1</span>], O_RDWR | O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)    <span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line"><span class="keyword">else</span>                           <span class="built_in">printf</span>(<span class="string">&quot;get button: -1\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">flags = fcntl(fd, F_GETFL);</span><br><span class="line">fcntl(fd, F_SETFL, flags &amp; ~O_NONBLOCK);</span><br><span class="line"><span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)    <span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line"><span class="keyword">else</span>                           <span class="built_in">printf</span>(<span class="string">&quot;while get button: -1\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="驱动程序">4.2 驱动程序</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err, key;</span><br><span class="line">    <span class="comment">// 没有数据且不阻塞时返回错误的一种</span></span><br><span class="line">	<span class="keyword">if</span> (is_key_buf_empty() &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	<span class="comment">// 阻塞方式，则根据有无数据来决定是否休眠</span></span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定时器">5.定时器</h2>
<p>按键操作中存在机械抖动，如果硬件设计中没有电容去抖动的话，那么就需要我们在软件设计上延时一段时间来等待抖动过去，在按键稳定之后再读取电平。实现延时的选择自然就是定时器了。</p>
<h3 id="定时器的内核函数">5.1 定时器的内核函数</h3>
<blockquote>
<p>参考内核源码：include.h</p>
</blockquote>
<ol type="1">
<li><p>设置定时器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setup_timer(timer, fn, data)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> setup_timer(timer, fn, data)					\</span></span><br><span class="line"><span class="meta">	__setup_timer((timer), (fn), (data), 0)</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __setup_timer(_timer, _fn, _data, _flags)			\</span></span><br><span class="line"><span class="meta">	do &#123;								\</span></span><br><span class="line"><span class="meta">		__init_timer((_timer), (_flags));			\</span></span><br><span class="line"><span class="meta">		(_timer)-&gt;function = (_fn);				\</span></span><br><span class="line"><span class="meta">		(_timer)-&gt;data = (_data);				\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __init_timer(_timer, _flags)					\</span></span><br><span class="line"><span class="meta">	init_timer_key((_timer), (_flags), NULL, NULL)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">init_timer_key</span><span class="params">(<span class="keyword">struct</span> timer_list *timer, <span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">		    <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> lock_class_key *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    debug_init(timer);</span><br><span class="line">	do_init_timer(timer, flags, name, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置定时器，主要是初始化 timer_list
结构体，设置其中的处理函数和传入参数，<strong>可将地址作为数据传入</strong>。</p>
<p><code>struct timer_list</code> 结构体内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All fields that change during normal runtime grouped to the</span></span><br><span class="line"><span class="comment">	 * same cacheline</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">entry</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		expires;</span><br><span class="line">	<span class="type">void</span>			(*function)(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		data;</span><br><span class="line">	u32			flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>向内核添加定时器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br></pre></td></tr></table></figure>
<p>调用之前需要设置超时时间 expires；当超时时间到达时，内核会调用函数
<code>timer-&gt;function(timer-&gt;data)</code></p></li>
<li><p>修改超时时间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mod_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer, <span class="type">unsigned</span> <span class="type">long</span> expires)</span></span><br></pre></td></tr></table></figure>
<p>等价于<code>del_timer(timer); timer-&gt;expires = expires; add_timer(timer);</code>
但更加高效；</p>
<p>当修改一个非运行的定时器时返回 0 ，反之返回1</p></li>
<li><p>删除定时器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">del_timer</span><span class="params">(<span class="keyword">struct</span> timer_list *timer)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="定时器的时间单位">5.2 定时器的时间单位</h3>
<p>编译内核时，可以在内核源码根目录下用“ls
-a”看到一个隐藏文件，它就是内核配置文件。打开后可以看到如下这项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG_HZ=100</span><br></pre></td></tr></table></figure>
<p>这表示内核每秒中会发生 100
次系统滴答中断(tick)，这就像人类的心跳一样，这是 Linux
系统的心跳。每发生一次 tick 中断，全局变量 jiffies 就会累加 1</p>
<p>因此，设置超时时间的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">timer.expires = jiffies + xxx;  <span class="comment">// xxx 表示多少个滴答后超时，也就是 xxx*10ms </span></span><br><span class="line">timer.expires = jiffies + <span class="number">2</span>*HZ; <span class="comment">// HZ 等于 CONFIG_HZ，2*HZ 就相当于 2 秒</span></span><br></pre></td></tr></table></figure>
<h3 id="使用定时器编写按键驱动">5.3 使用定时器编写按键驱动</h3>
<p>编程的思路，如下：</p>
<ol type="1">
<li>初始化定时器并设置超时时间为INF，然后添加定时器</li>
<li>当触发按键中断后，修改超时时间为当前时间的 10ms 后</li>
<li>当定时器软中断触发后，在读取稳定的电平，从而判断按键的状态</li>
</ol>
<figure>
<img src="../images/驱动程序的必要基础/image-20240110180354646.png"
alt="image-20240110180354646" />
<figcaption aria-hidden="true">image-20240110180354646</figcaption>
</figure>
<p>为了独立监测每一个按键，我们在按键结构体中为每一个按键都分配一个
<code>struct timer_list</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct gpio_key&#123;</span><br><span class="line">	int gpio;</span><br><span class="line">	struct gpio_desc *gpiod;</span><br><span class="line">	int flag;</span><br><span class="line">	int irq;</span><br><span class="line">	struct timer_list key_timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 probe 函数中初始化每一个按键的定时器，在 remove
函数中删除定时器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setup_timer(&amp;gpio_keys_100ask[i].key_timer, key_timer_expire, &amp;gpio_keys_100ask[i]);</span><br><span class="line">gpio_keys_100ask[i].key_timer.expires = ~<span class="number">0</span>;</span><br><span class="line">add_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line"></span><br><span class="line">del_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br></pre></td></tr></table></figure>
<p>在按键中断处理函数中，修改定时器的超时时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_isr key %d irq happened\n&quot;</span>, gpio_key-&gt;gpio);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定时器软中断处理函数中，读取电平：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_expire</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val, key;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_timer_expire key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中断下半部-tasklet">6.中断下半部 tasklet</h2>
<p>使用软中断 tasklet
实现中断下半部的方式通常用来处理相对不复杂的任务（复杂耗时的会使用工作队列线程化的处理），tasklet
的具体实现机制参见“异常和中断”的第 2.1.3 节。</p>
<h3 id="tasklet-的内核函数">6.1 tasklet 的内核函数</h3>
<blockquote>
<p>参见内核源码：include.h</p>
</blockquote>
<p>中断下半部使用结构体 tasklet_struct 来表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>state 有两位：</p>
<ul>
<li><p>bit0 表示 TASKLET_STATE_SCHED：</p>
<p>等于 1 时表示已经执行了 tasklet_schedule 已经把该 tasklet
放入队列了。</p>
<p>tasklet_schedule 会判断该位，如果已经等于 1 那么它就不会再次把
tasklet 放入队列。</p></li>
<li><p>bit1 表示 TASKLET_STATE_RUN：</p>
<p>等于 1 时，表示正在运行 tasklet 中的 func
函数；函数执行完后内核会把该位清 0。</p></li>
</ul></li>
<li><p>其中的 count 表示该 tasklet 是否使能：等于 0 表示使能了，非 0
表示被禁止了。对于 count 非 0 的 tasklet，里面的 func
函数不会被执行。</p></li>
</ul>
<ol type="1">
<li><p>定义结构体 tasklet_struct</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET(name, func, data) \</span></span><br><span class="line"><span class="meta">struct tasklet_struct name = &#123; NULL, 0, ATOMIC_INIT(0), func, data &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_TASKLET_DISABLED(name, func, data) \</span></span><br><span class="line"><span class="meta">struct tasklet_struct name = &#123; NULL, 0, ATOMIC_INIT(1), func, data &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t, <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 DECLARE_TASKLET 定义的 tasklet 结构体，它是使能的</li>
<li>使用 DECLARE_TASKLET_DISABLED 定义的 tasklet
结构体，它是禁止的；使用之前要先调用 tasklet_enable 使能它</li>
<li>使用 tasklet_init 定义的结构体也是使能的</li>
</ul></li>
<li><p>使能/失能 tasklet</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_enable</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>; </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_disable</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>tasklet_enable 把 count 减 1</li>
<li>tasklet_disable 把 count 加 1</li>
</ul></li>
<li><p>调度 tasklet</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>把 tasklet 放入链表，并且设置它的 TASKLET_STATE_SCHED 状态为
1。</li>
</ul></li>
<li><p>kill tasklet</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tasklet_kill</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果一个 tasklet 已被放入链表且未被调度，则 tasklet_kill 会将它的
TASKLET_STATE_SCHED 状态清 0</li>
<li>如果一个 tasklet 已被调度，tasklet_kill 会等待它执行完华，再它的
TASKLET_STATE_SCHED 状态清 0</li>
</ul></li>
</ol>
<h3 id="为驱动程序添加-tasklet">6.2 为驱动程序添加 tasklet</h3>
<p>在按键驱动中，并没有多少复杂耗时的操作，不过我们可以象征性的将一些操作放入到
tasklet 的处理函数中。</p>
<p>在 probe 函数中初始化每一个按键的 tasklet 结构体，在 remove 函数中
kill 掉 tasklet 结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tasklet_init(&amp;gpio_keys_100ask[i].tasklet, key_tasklet_func, &amp;gpio_keys_100ask[i]);</span><br><span class="line"></span><br><span class="line">tasklet_kill(&amp;gpio_keys_100ask[i].tasklet);</span><br></pre></td></tr></table></figure>
<p>在按键中断结束时，调度 tasklet：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	tasklet_schedule(&amp;gpio_key-&gt;tasklet);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tasklet 的处理函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_tasklet_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工作队列">7. 工作队列</h2>
<p>前面讲的定时器、下半部 tasklet
都属于软中断，都是在中断上下文中执行的，无法休眠。这些更耗时的工作放在定时器或是下半部中，会使得系统很卡，因此可以使用线程来处理这些耗时的工作，从而解决系统卡顿的问题，因为线程可以休眠。</p>
<p>对于耗时而不是非常耗时的逻辑，我们并不需要自己去创建线程，可以使用“工作队列”
(workqueue)。我们只需要将“工作”放入“工作队列”中，当对应的<strong>内核线程</strong>被调度时就会取出“工作”，执行处理函数。</p>
<p><strong>在多 CPU
的系统下，一个工作队列可以有多个内核线程，可以在一定程度上
缓解这个问题。</strong></p>
<p><strong>缺点</strong>：多个工作是在某个内核线程中依次执行的，前面的工作执行很慢，会使得后面的工作不能及时响应。所以对于非常复杂耗时的工作，可以为其单独开一个线程。</p>
<h3 id="工作队列的内核函数">7.1 工作队列的内核函数</h3>
<blockquote>
<p>参考内核源码：include.h</p>
</blockquote>
<p>work_struct 结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_long_t</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">	<span class="type">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>定义 work</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WORK(n, f)						\</span></span><br><span class="line"><span class="meta">	struct work_struct n = __WORK_INITIALIZER(n, f)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_DELAYED_WORK(n, f)					\</span></span><br><span class="line"><span class="meta">	struct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f, 0)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第 1 个宏是用来定义一个 work_struct 结构体，要指定它的函数</li>
<li>第 2 个宏用来定义一个 delayed_work
结构体，也要指定它的函数。区别在于要让它运行时，可以指定某段时间之后再执行。</li>
</ul>
<p>上面用来直接声明工作队列结构体，如果想要在代码中初始化 work_struct
结构体，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define INIT_WORK(_work, _func)</span><br></pre></td></tr></table></figure></li>
<li><p>使用 work</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work(system_wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 schedule_work 时，就会把 work_struct
结构体放入队列中，并唤醒对应的内核线程。内核线程就会从队列里把
work_struct 结构体取出来，执行里面的函数</p>
<p>返回 false 表示 work 已经在工作队列中，否则返回 true</p></li>
<li><p>其他函数</p>
<table>
<colgroup>
<col style="width: 32%" />
<col style="width: 67%" />
</colgroup>
<thead>
<tr class="header">
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>create_workqueue</td>
<td>在 Linux 系统中已经有了现成的 <code>system_wq</code> 等工作队列，
你当然也可以自己调用 create_workqueue 创建工作队列； 对于 SMP
系统，这个工作队列会有多个内核线程与它对应，创建工作队列时，内核会帮这个工作队列创建多个内核线程</td>
</tr>
<tr class="even">
<td>create_singlethread_workqueue</td>
<td>如果想只有一个内核线程与工作队列对应， 可以用本函数创建工作队列，
创建工作队列时，内核会帮这个工作队列创建一个内核线程</td>
</tr>
<tr class="odd">
<td>destroy_workqueue</td>
<td>销毁工作队列</td>
</tr>
<tr class="even">
<td>schedule_work</td>
<td>调度执行一个具体的 work，执行的 work 将会被挂入 Linux
系统提供的工作队列</td>
</tr>
<tr class="odd">
<td>schedule_delayed_work</td>
<td>延迟一定时间去执行一个具体的任务，功能与 schedule_work
类似，多了一个延迟时间</td>
</tr>
<tr class="even">
<td>queue_work</td>
<td>跟 schedule_work 类似，schedule_work
是在系统默认的工作队列上执行一个 work， queue_work
需要自己指定工作队列</td>
</tr>
<tr class="odd">
<td>queue_delayed_work</td>
<td>跟 schedule_delayed_work 类似，schedule_delayed_work
是在系统默认的工作队列上执行一个 work，queue_delayed_work
需要自己指定工作队列</td>
</tr>
<tr class="even">
<td>flush_work</td>
<td>等待一个 work 执行完毕，如果这个 work
已经被放入队列，那么本函数等它执行完毕，并且返回 true； 如果这个 work
已经执行完毕才调用本函数，那么直接返回 false</td>
</tr>
<tr class="odd">
<td>flush_delayed_work</td>
<td>等待一个 delayed_work 执行完毕，如果这个 delayed_work
已经被放入队列，那么本函数等它执行完毕，并且返回 true； 如果这个
delayed_work 已经执行完毕才调用本函数，那 么直接返回 false</td>
</tr>
</tbody>
</table></li>
</ol>
<h3 id="为驱动程序添加工作队列">7.2 为驱动程序添加工作队列</h3>
<p>在按键驱动中，并没有多少复杂耗时的操作，不过我们可以象征性的将一些操作放入到工作队列的处理函数中。</p>
<p>在 probe 函数中初始化每一个按键的 work_struct 结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INIT_WORK(&amp;gpio_keys_100ask[i].work, key_work_func);</span><br></pre></td></tr></table></figure>
<p>在按键中断结束时，调度 work：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	tasklet_schedule(&amp;gpio_key-&gt;tasklet);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">100</span>);</span><br><span class="line">    schedule_work(&amp;gpio_key-&gt;work);</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>work 的处理函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/current.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_work_func</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用宏 container_of，由 work 的指针反推出 gpio_key 结构体的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> container_of(work, <span class="keyword">struct</span> gpio_key, work);</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">    <span class="comment">// 打印进程的名称和pid号</span></span><br><span class="line">	printk(<span class="string">&quot;key_work_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);</span><br><span class="line">	printk(<span class="string">&quot;key_work_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中断的线程化处理">8.中断的线程化处理</h2>
<p>复杂、耗时的事情，尽量使用内核线程来处理。中断的处理仍然可以认为分为上半部、下半部。上半部用来处理紧急的事情，下半部用一个内核线程来处理。</p>
<h3 id="使用内核线程实现中断下半部">8.1 使用内核线程实现中断下半部</h3>
<p>在按键驱动中，并没有多少复杂耗时的操作，不过我们可以象征性的将一些操作放入到工作队列的处理函数中。</p>
<p>在 probe 函数中注册使用内核线程实现下半部的中断，并在 remove
函数中释放：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = request_threaded_irq(gpio_keys_100ask[i].irq, gpio_key_isr, gpio_key_thread_func, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line"></span><br><span class="line">free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br></pre></td></tr></table></figure>
<p>中断上半部和下半部的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	tasklet_schedule(&amp;gpio_key-&gt;tasklet);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">50</span>);</span><br><span class="line">	schedule_work(&amp;gpio_key-&gt;work);</span><br><span class="line">	<span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_thread_func</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);	</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内核线程的机制">8.2 内核线程的机制</h3>
<p>在 request_threaded_irq
函数中，肯定会创建一个内核线程，以下为关键代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 分配、设置一个 irqaction 结构体</span></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	action-&gt;handler = handler;</span><br><span class="line">	action-&gt;thread_fn = thread_fn;</span><br><span class="line">	action-&gt;flags = irqflags;</span><br><span class="line">	action-&gt;name = devname;</span><br><span class="line">	action-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">	retval = __setup_irq(irq, desc, action); <span class="comment">// 进一步处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该函数中分配了一个 irqaction 结构体，并在 __setup_irq
函数中进一步处理，截取重要代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__setup_irq(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> irq_desc *desc, <span class="keyword">struct</span> irqaction *new)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (new-&gt;thread_fn &amp;&amp; !nested) &#123; 		</span><br><span class="line">        ret = setup_irq_thread(new, irq, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 thread_fn 不为空，则调用 setup_irq_thread
函数来创建一个内核线程，截取代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">setup_irq_thread</span><span class="params">(<span class="keyword">struct</span> irqaction *new, <span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">bool</span> secondary)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!secondary) &#123;</span><br><span class="line">        t = kthread_create(irq_thread, new, <span class="string">&quot;irq/%d-%s&quot;</span>, irq,</span><br><span class="line">                           new-&gt;name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t = kthread_create(irq_thread, new, <span class="string">&quot;irq/%d-s-%s&quot;</span>, irq,</span><br><span class="line">                           new-&gt;name);</span><br><span class="line">        param.sched_priority -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    new-&gt;thread = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后将创建的内核线程付给 thread 成员</p>
<hr />
<p>再来分析中断的执行中是如何唤醒上面创建的内核线程的，并执行 thread_fn
函数的。</p>
<p>在 <code>kernel\irq\handle.c</code> 中，截取部分代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">irqreturn_t</span> __handle_irq_event_percpu(<span class="keyword">struct</span> irq_desc *desc, <span class="type">unsigned</span> <span class="type">int</span> *flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">irqreturn_t</span> retval = IRQ_NONE;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> irq = desc-&gt;irq_data.irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line"></span><br><span class="line">	for_each_action_of_desc(desc, action) &#123;</span><br><span class="line">		<span class="type">irqreturn_t</span> res;</span><br><span class="line"></span><br><span class="line">		trace_irq_handler_entry(irq, action);</span><br><span class="line">		res = action-&gt;handler(irq, action-&gt;dev_id);   <span class="comment">// 调用中断上半部分的处理函数</span></span><br><span class="line">		trace_irq_handler_exit(irq, action, res);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (WARN_ONCE(!irqs_disabled(),<span class="string">&quot;irq %u handler %pF enabled interrupts\n&quot;</span>,</span><br><span class="line">			      irq, action-&gt;handler))</span><br><span class="line">			local_irq_disable();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (res) &#123;</span><br><span class="line">		<span class="keyword">case</span> IRQ_WAKE_THREAD:     <span class="comment">// 需要唤醒 thread 线程的返回值</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Catch drivers which return WAKE_THREAD but</span></span><br><span class="line"><span class="comment">			 * did not set up a thread function</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(!action-&gt;thread_fn)) &#123;</span><br><span class="line">				warn_no_thread(irq, action);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			__irq_wake_thread(desc, action);   <span class="comment">// 唤醒 action-&gt;thread </span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Fall through to add to randomness */</span></span><br><span class="line">		<span class="keyword">case</span> IRQ_HANDLED:       <span class="comment">// 中断正常处理的返回值</span></span><br><span class="line">			*flags |= action-&gt;flags;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thread 线程的处理函数为 irq_thread，在
<code>kernel\irq\handle.c</code> 中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">irq_thread</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (!irq_wait_for_interrupt(action)) &#123;   <span class="comment">// 1. 休眠等待中断</span></span><br><span class="line">		<span class="type">irqreturn_t</span> action_ret;</span><br><span class="line"></span><br><span class="line">		irq_thread_check_affinity(desc, action);</span><br><span class="line"></span><br><span class="line">		action_ret = handler_fn(desc, action);   <span class="comment">// 2. 执行 thread_fn</span></span><br><span class="line">		<span class="keyword">if</span> (action_ret == IRQ_HANDLED)</span><br><span class="line">			<span class="type">atomic_inc</span>(&amp;desc-&gt;threads_handled);</span><br><span class="line">		<span class="keyword">if</span> (action_ret == IRQ_WAKE_THREAD)</span><br><span class="line">			irq_wake_secondary(desc, action);</span><br><span class="line"></span><br><span class="line">		wake_threads_waitq(desc);                <span class="comment">// 3. 唤醒等待 thread_fn 的线程</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体流程如下图：</p>
<figure>
<img src="../images/驱动程序的必要基础/image-20240111201435120.png"
alt="image-20240111201435120" />
<figcaption aria-hidden="true">image-20240111201435120</figcaption>
</figure>
<p>可能由程序在等待 thread_fn 函数被执行，irq_thread 函数最后会调用
wake_threads_waitq 唤醒：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wake_threads_waitq</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (atomic_dec_and_test(&amp;desc-&gt;threads_active))</span><br><span class="line">		wake_up(&amp;desc-&gt;wait_for_threads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait_for_threads 是 <code>wait_queue_head_t</code>
类型，等待队列头内都是休眠的线程。</p>
<p>可以调用 synchronize_irq 来等待 thread_fn 被执行，synchronize_irq
的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	synchronize_irq - wait for pending IRQ handlers (on other CPUs)</span></span><br><span class="line"><span class="comment"> *	@irq: interrupt number to wait for</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	This function waits for any pending IRQ handlers for this interrupt</span></span><br><span class="line"><span class="comment"> *	to complete before returning. If you use this function while</span></span><br><span class="line"><span class="comment"> *	holding a resource the IRQ handler may need you will deadlock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	This function may be called - with care - from IRQ context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">synchronize_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux应用开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Linux</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
