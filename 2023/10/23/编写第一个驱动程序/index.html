<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 编写驱动程序的框架1.1 APP 打开的文件在内核中如何表示APP 打开文件时，可以得到一个整数，这个整数被称为文件句柄。对于 APP 的每一个文件句柄，在内核里面都有一个struct file结构体与之对应: 123456789101112131415161718192021struct file &amp;#123;	union &amp;#123;		struct llist_node	fu_llis">
<meta property="og:type" content="article">
<meta property="og:title" content="编写第一个驱动程序">
<meta property="og:url" content="http://example.com/2023/10/23/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/index.html">
<meta property="og:site_name" content="Krocz&#39;s Blog">
<meta property="og:description" content="1. 编写驱动程序的框架1.1 APP 打开的文件在内核中如何表示APP 打开文件时，可以得到一个整数，这个整数被称为文件句柄。对于 APP 的每一个文件句柄，在内核里面都有一个struct file结构体与之对应: 123456789101112131415161718192021struct file &amp;#123;	union &amp;#123;		struct llist_node	fu_llis">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/image-20231024200354443.png">
<meta property="og:image" content="http://example.com/images/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/image-20231129180502476.png">
<meta property="og:image" content="http://example.com/images/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/image-20231027203241612.png">
<meta property="og:image" content="http://example.com/images/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/image-20231027222251531.png">
<meta property="article:published_time" content="2023-10-23T12:35:19.000Z">
<meta property="article:modified_time" content="2023-12-17T02:16:28.836Z">
<meta property="article:author" content="Krocz">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/image-20231024200354443.png">

<link rel="canonical" href="http://example.com/2023/10/23/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>编写第一个驱动程序 | Krocz's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
  <script src="/live2d-widget/autoload.js"></script>
 <link rel="alternate" href="/atom.xml" title="Krocz's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">

   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/cursor/fireworks.js"></script>



  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Krocz's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">望云登坡</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/23/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Krocz">
      <meta itemprop="description" content="时间不等人，喜欢就去做">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Krocz's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          编写第一个驱动程序
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-23 20:35:19" itemprop="dateCreated datePublished" datetime="2023-10-23T20:35:19+08:00">2023-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-17 10:16:28" itemprop="dateModified" datetime="2023-12-17T10:16:28+08:00">2023-12-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Linux应用开发</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>23 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-编写驱动程序的框架"><a href="#1-编写驱动程序的框架" class="headerlink" title="1. 编写驱动程序的框架"></a>1. 编写驱动程序的框架</h2><h3 id="1-1-APP-打开的文件在内核中如何表示"><a href="#1-1-APP-打开的文件在内核中如何表示" class="headerlink" title="1.1 APP 打开的文件在内核中如何表示"></a>1.1 APP 打开的文件在内核中如何表示</h3><p>APP 打开文件时，可以得到一个整数，这个整数被称为文件句柄。对于 APP 的每一个文件句柄，在内核里面都有一个<code>struct file</code>结构体与之对应:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>	<span class="title">fu_llist</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> 	<span class="title">fu_rcuhead</span>;</span></span><br><span class="line">	&#125; f_u;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span>		<span class="title">f_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">f_inode</span>;</span>	<span class="comment">/* cached value */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>	*<span class="title">f_op</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Protects f_ep_links, f_flags.</span></span><br><span class="line"><span class="comment">	 * Must not be taken from IRQ context.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">spinlock_t</span>		f_lock;</span><br><span class="line">	<span class="type">atomic_long_t</span>		f_count;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> 		f_flags;</span><br><span class="line">	<span class="type">fmode_t</span>			f_mode;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">f_pos_lock</span>;</span></span><br><span class="line">	<span class="type">loff_t</span>			f_pos;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>	<span class="title">f_owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>	*<span class="title">f_cred</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>	<span class="title">f_ra</span>;</span></span><br></pre></td></tr></table></figure>

<p>在APP中调用open函数打开文件时，传入的flags、mode等参数会记录在内核相应的<code>struct file</code>成员<code>f_flags\f_mode</code>中；读写文件的偏移地址也会保存在<code>struct file</code>结构体的<code>f_pos</code>成员中。</p>
<p>并且当APP中调用open函数时，会向下调用系统的sys_open函数，而sys_open函数又会根据主设备号来调用相应驱动的open函数；这些驱动函数的地址会保存在成员<code>file_operations</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">	<span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">	<span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br></pre></td></tr></table></figure>

<p>将上面描述的过程用一张图进行说明：</p>
<p><img src="/../images/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/image-20231024200354443.png" alt="image-20231024200354443"></p>
<h5 id="PS：主设备号"><a href="#PS：主设备号" class="headerlink" title="PS：主设备号"></a>PS：主设备号</h5><p>主设备号是内核模块分配给设备驱动程序的唯一标识符，用于标识特定设备的整数值，它由设备驱动程序进行分配。设备驱动程序通过主设备号将特定的操作转发给相应的驱动程序中断例程和文件操作函数。文件描述符是应用程序与打开的文件之间的连接，而主设备号是<strong>内核用于路由I&#x2F;O请求到正确设备驱动程序的标识符</strong>。</p>
<h3 id="1-2-编写驱动程序的步骤"><a href="#1-2-编写驱动程序的步骤" class="headerlink" title="1.2 编写驱动程序的步骤"></a>1.2 编写驱动程序的步骤</h3><ol>
<li>确定主设备号，可以自己指定主设备号，也可以传入0，让内核给驱动程序分配主设备号</li>
<li>定义自己的 <code>file_operations</code> 结构体实现对应的 <code>drv_open/drv_read/drv_write</code> 等函数，填入 <code>file_operations</code> 结构体 </li>
<li>把 <code>file_operations</code> 结构体告诉内核：使用<code>register_chrdev</code>函数 </li>
<li>谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数 </li>
<li>有入口函数就应该有出口函数：卸载驱动程序时，出口函数调用 <code>unregister_chrdev</code></li>
<li>其他完善：提供设备信息，自动创建设备节点：<code>class_create, device_create</code></li>
</ol>
<h3 id="1-3-驱动程序框架示例"><a href="#1-3-驱动程序框架示例" class="headerlink" title="1.3 驱动程序框架示例"></a>1.3 驱动程序框架示例</h3><p><strong>字符设备驱动程序的框架</strong>：</p>
<p><img src="/../images/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/image-20231129180502476.png" alt="image-20231129180502476"></p>
<p><strong>代码示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asm/uaccess.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/err.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/kdev_t.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/printk.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux/stddef.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_open</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_close</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 确定主设备号   */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major_number = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kernel_buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) ((a &lt; b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 定义自己的file_operations结构体                                          */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = hello_drv_open,</span><br><span class="line">    .read = hello_drv_read,</span><br><span class="line">    .write = hello_drv_write,</span><br><span class="line">    .release = hello_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 实现对应的open/read/write等函数，填入file_operations结构体                   */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_open</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当前所在的源代码文件的文件名 当前所在的函数的名称 代码行号</span></span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    err = copy_to_user(buf, kernel_buf, MIN(size, <span class="number">1024</span>));</span><br><span class="line">    <span class="keyword">return</span> MIN(size, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    err = copy_from_user(kernel_buf, buf, MIN(size, <span class="number">1024</span>));</span><br><span class="line">    <span class="keyword">return</span> MIN(size, <span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_close</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4. 把file_operations结构体告诉内核：注册驱动程序  */</span></span><br><span class="line"><span class="comment">/* 5. 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">hello_device</span>;</span></span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    <span class="comment">// 注册驱动程序</span></span><br><span class="line">    major_number = register_chrdev(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv);</span><br><span class="line">    <span class="comment">// 创建类</span></span><br><span class="line">    hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(IS_ERR(hello_class))   </span><br><span class="line">    &#123;</span><br><span class="line">        unregister_chrdev(major_number, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(hello_class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建设备节点：/dev/hello</span></span><br><span class="line">    hello_device = device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major_number, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(hello_device)) </span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(hello_device);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 6. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数   */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">    device_destroy(hello_class, MKDEV(major_number, <span class="number">0</span>));</span><br><span class="line">    class_destroy(hello_class);</span><br><span class="line">    unregister_chrdev(major_number, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 7. 其他完善：提供设备信息，自动创建设备节点        */</span></span><br><span class="line">module_init(hello_init);  <span class="comment">//将hello_init修饰成驱动程序的入口函数</span></span><br><span class="line">module_exit(hello_exit);  <span class="comment">//将hello_exit修饰成驱动程序的出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);    <span class="comment">//声明遵守GPL协议</span></span><br></pre></td></tr></table></figure>

<p>相应的APP测试程序很简单，使用open()函数打开设备节点“&#x2F;dev&#x2F;hello”，然后调用read()&#x2F;write()读取&#x2F;写入数据即可。</p>
<h4 id="1-3-1-Makefile"><a href="#1-3-1-Makefile" class="headerlink" title="1.3.1 Makefile"></a>1.3.1 Makefile</h4><p>使用如下Makefile将.c文件交叉编译为内核驱动模块.ko文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">KERN_DIR = /home/book/100ask_imx6ull_mini-sdk/Linux-4.9.88</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">   <span class="comment"># 使用make命令在KERN_DIR中构建内核模块，M=$(pwd)表示模块的源码路径为当前目录</span></span><br><span class="line">	make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules </span><br><span class="line">	<span class="variable">$(CROSS_COMPILE)</span>gcc -o hello_drv_test hello_drv_test.c </span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	<span class="comment"># 使用make命令在KERN_DIR中清理构建的内核模块</span></span><br><span class="line">	make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules clean</span><br><span class="line">	rm -rf modules.order</span><br><span class="line">	rm -f hello_drv_test </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将hello_drv.o加入obj-m列表，用于构建内核模块</span></span><br><span class="line">obj-m += hello_drv.o</span><br></pre></td></tr></table></figure>





<h4 id="1-3-2-测试"><a href="#1-3-2-测试" class="headerlink" title="1.3.2 测试"></a>1.3.2 测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insmod hello_drv.ko    //安装内核驱动模块</span><br><span class="line">cat /proc/devices     // 查看/proc/devices文件,该文件列出字符和块设备的主设备号,以及分配到这些设备号的设备名称</span><br><span class="line">lsmod                // 列出所有已安装的内核模块</span><br><span class="line">ls /dev/hello -l     // 查看设备节点是否存在</span><br><span class="line">rmmod hello_drv      // 卸载内核驱动模块</span><br><span class="line">dmesg                // 查看内核输出的打印信息</span><br></pre></td></tr></table></figure>





<h2 id="1-4-Hello驱动程序的中的知识点"><a href="#1-4-Hello驱动程序的中的知识点" class="headerlink" title="1.4 Hello驱动程序的中的知识点"></a>1.4 Hello驱动程序的中的知识点</h2><h4 id="1-4-1-module-init-module-exit-的实现"><a href="#1-4-1-module-init-module-exit-的实现" class="headerlink" title="1.4.1 module_init&#x2F;module_exit 的实现"></a>1.4.1 module_init&#x2F;module_exit 的实现</h4><p>一个驱动程序有入口&#x2F;出口函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(hello_init);  <span class="comment">//将hello_init修饰成驱动程序的入口函数</span></span><br><span class="line">module_exit(hello_exit);  <span class="comment">//将hello_exit修饰成驱动程序的出口函数</span></span><br></pre></td></tr></table></figure>

<p>驱动程序可以被直接编入内核，也可以被编译为ko文件后手工加载。对于这两种方式，<code>module_init/module_exit</code>宏是不一样的，在内核文件<code>include\linux\module.h</code>可以找到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MODULE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_init(x)	__initcall(x);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_exit(x)	__exitcall(x);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* MODULE */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Each module must use one module_init(). */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_init(initfn)					\</span></span><br><span class="line"><span class="meta">	static inline initcall_t __inittest(void)		\</span></span><br><span class="line"><span class="meta">	&#123; return initfn; &#125;					\</span></span><br><span class="line"><span class="meta">	int init_module(void) __attribute__((alias(#initfn)));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is only required if you want to be unloadable. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> module_exit(exitfn)					\</span></span><br><span class="line"><span class="meta">	static inline exitcall_t __exittest(void)		\</span></span><br><span class="line"><span class="meta">	&#123; return exitfn; &#125;					\</span></span><br><span class="line"><span class="meta">	void cleanup_module(void) __attribute__((alias(#exitfn)));</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h5 id="1-编译为ko文件"><a href="#1-编译为ko文件" class="headerlink" title="(1) 编译为ko文件"></a>(1) 编译为ko文件</h5><p>编译驱动程序时，我们执行<code>make modules</code>这样的命令，它在编译 c 文件时会定义宏 <code>MODULE</code>，例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-buildroot-linux-gnueabihf-gcc -DMODULE -c -o hello_drv.o hello_drv.c</span><br></pre></td></tr></table></figure>

<p>那么将else下面的宏展开之后可以得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline initcall_t __inittest(void) \ </span><br><span class="line">&#123; return hello_init; &#125; \ </span><br><span class="line">int init_module(void) __attribute__((alias(&quot;hello_init&quot;)));</span><br><span class="line"></span><br><span class="line">static inline exitcall_t __exittest(void) \ </span><br><span class="line">&#123; return hello_exit; &#125; </span><br><span class="line">\ void cleanup_module(void) __attribute__((alias(&quot;hello_exit&quot;)));</span><br></pre></td></tr></table></figure>

<p>分别定义了 2 个函数：第 1 个函数名为 <code>init_module</code>，它是 <code>hello_init</code> 函数的别名；第 2 个函数名为 <code>cleanup_module</code>，它是 <code>hello_exit</code> 函数的别名。 以后我们使用 <code>insmod</code> 命令加载驱动时，内核都是调用 <code>init_module</code> 函数， 实际上就是调用 <code>hello_init</code> 函数；使用 <code>rmmod</code> 命令卸载驱动时，内核都是调用 <code>cleanup_module</code> 函数，实际上就是调用 <code>hello_exit</code> 函数。</p>
<h5 id="2-编译进内核"><a href="#2-编译进内核" class="headerlink" title="(2) 编译进内核"></a>(2) 编译进内核</h5><p>将#ifndef下面的宏展开之后可以得到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">initcall_t</span> __initcall_hello_init6 __used \ __attribute__((__section__(<span class="string">&quot;.initcall6.init&quot;</span>))) = hello_init; </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">exitcall_t</span> __exitcall_hello_exit __used __section(.exitcall.<span class="built_in">exit</span>) = hello_exit;</span><br></pre></td></tr></table></figure>

<p>其中的<code>initcall_t</code>、<code>exitcall_t</code>就是函数指针类型，所以上述代码就是定义了两个函数指针：第 1 个函数指针名为<code>__initcall_hello_init6</code>，放在段<code>.initcall6.init</code>里；第 2 个函数指针名为<code>__exitcall_hello_exit</code>， 放在段<code>.exitcall.exit</code>里。 </p>
<p>内核启动时，会去段<code>.initcall6.init</code>里取出这些函数指针来执行，所以 驱动程序的入口函数就被执行了。 </p>
<p>一个驱动被编进内核后，它是不会被卸载的，所以段<code>.exitcall.exit</code> 不会被用到，内核启动后会释放这块段空间。</p>
<h4 id="1-4-2-register-chrdev的内部实现"><a href="#1-4-2-register-chrdev的内部实现" class="headerlink" title="1.4.2 register_chrdev的内部实现"></a>1.4.2 register_chrdev的内部实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">				  <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __register_chrdev(major, <span class="number">0</span>, <span class="number">256</span>, name, fops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用<code>__register_chrdev</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __register_chrdev(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">unsigned</span> <span class="type">int</span> baseminor,</span><br><span class="line">		      <span class="type">unsigned</span> <span class="type">int</span> count, <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">		      <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">cd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">cdev</span>;</span></span><br><span class="line">	<span class="type">int</span> err = -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.查看chrdevs相应位置的空间是否被占用</span></span><br><span class="line">	cd = __register_chrdev_region(major, baseminor, count, name);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(cd))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(cd);</span><br><span class="line"></span><br><span class="line">	cdev = cdev_alloc();</span><br><span class="line">	<span class="keyword">if</span> (!cdev)</span><br><span class="line">		<span class="keyword">goto</span> out2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.将cdev结构体注册进入内核</span></span><br><span class="line">	cdev-&gt;owner = fops-&gt;owner;</span><br><span class="line">	cdev-&gt;ops = fops;</span><br><span class="line">	kobject_set_name(&amp;cdev-&gt;kobj, <span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">	err = cdev_add(cdev, MKDEV(cd-&gt;major, baseminor), count);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	cd-&gt;cdev = cdev;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> major ? <span class="number">0</span> : cd-&gt;major;</span><br><span class="line">out:</span><br><span class="line">	kobject_put(&amp;cdev-&gt;kobj);</span><br><span class="line">out2:</span><br><span class="line">	kfree(__unregister_chrdev_region(cd-&gt;major, baseminor, count));</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（1）-register-chrdev-region-major-baseminor-count-name"><a href="#（1）-register-chrdev-region-major-baseminor-count-name" class="headerlink" title="（1）__register_chrdev_region(major, baseminor, count, name)"></a>（1）__register_chrdev_region(major, baseminor, count, name)</h5><p><strong>作用</strong>：查看设备号<code>(major, baseminor)</code>到<code>(major, baseminor+count-1)</code> 有没有被占用，如果未被占用的话，就使用这块区域。</p>
<p>之前为了方便理解简化模型，认为内核里有一个 <code>chrdevs</code> 数组， 根据主设备号 <code>major</code> 在 <code>chrdevs[major]</code> 中放入 <code>file_operations</code> 结构体，以后 <code>open/read/write</code> 某个设备文件时，就是根据主设备号从 <code>chrdevs[major]</code> 中取出 <code>file_operations</code> 结构体，调用里面的 <code>open/read/write</code> 函数指针。</p>
<p>实际上，内核中确实有一个<code>chrdevs</code>数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> major;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> baseminor;</span><br><span class="line">	<span class="type">int</span> minorct;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">cdev</span>;</span>		<span class="comment">/* will die */</span></span><br><span class="line">&#125; *chrdevs[CHRDEV_MAJOR_HASH_SIZE];</span><br></pre></td></tr></table></figure>

<p>但是去访问它的时候，并不是直接使用主设备号 major 来确定数组项，而是使用如下函数来确定数组项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* index in the above */</span> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">major_to_index</span><span class="params">(<span class="type">unsigned</span> major)</span> </span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">return</span> major % CHRDEV_MAJOR_HASH_SIZE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>CHRDEV_MAJOR_HASH_SIZE</code> 等于 255。比如主设备号1、256， 都会使用 <code>chrdevs[1]</code> 。 <code>chrdevs[1]</code> 是一个链表，链表里有多个 <code>char_device_struct</code> 结构体，某个结构体表示主设备号为 1 的设备，某个结构体表示主设备号为 256 的设备，如下图：</p>
<p><img src="/../images/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/image-20231027203241612.png" alt="image-20231027203241612">·</p>
<ol>
<li><p><code>chrdevs[i]</code>数组项是一个链表头，链表中的每一个元素都是<code>char_device_struct</code>结构体，每一个元素都表示一个驱动程序。<code>char_device_struct</code>结构体每一个成员表示如下：</p>
<ul>
<li><code>major</code>：主设备号</li>
<li><code>baseminor</code>：次设备号</li>
<li><code>minorct</code>：个数</li>
<li><code>cdev</code>：在<code>cdev</code>中含有<code>file_operations</code>结构体</li>
</ul>
</li>
<li><p>在上图中，<code>chrdevs[1]</code>中有3个驱动程序：</p>
<ul>
<li>第 1 个 <code>char_device_struct</code> 结构体对应主次设备号<code>(1, 0)、(1, 1)</code>，这 是第 1 个驱动程序。</li>
<li>第 2 个 <code>char_device_struct</code> 结构体对应主次设备号<code>(1, 2)、(1, 2)、......、 (1, 11)</code>，这是第 2 个驱动程序。 </li>
<li>第 3 个 <code>char_device_struct</code> 结构体对应主次设备号<code>(256, 0)</code>，这是第 3 个驱动程序。</li>
</ul>
</li>
</ol>
<h5 id="（2）cdev-add-cdev-MKDEV-cd-major-baseminor-count"><a href="#（2）cdev-add-cdev-MKDEV-cd-major-baseminor-count" class="headerlink" title="（2）cdev_add(cdev, MKDEV(cd-&gt;major, baseminor), count)"></a>（2）cdev_add(cdev, MKDEV(cd-&gt;major, baseminor), count)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	p-&gt;dev = dev;</span><br><span class="line">	p-&gt;count = count;</span><br><span class="line"></span><br><span class="line">	error = kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>,</span><br><span class="line">			 exact_match, exact_lock, p);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">	kobject_get(p-&gt;kobj.parent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数涉及 kobj 的操作，这是一个通用的链表操作函数。它的作用是： 把 <code>cdev</code> 结构体放入 <code>cdev_map</code> 链表中，对应的索引值是<code>dev</code>到<code>dev+count-1</code>。以后可以从 <code>cdev_map</code> 链表中快速地使用索引值取出对应的 <code>cdev</code>。</p>
<p>例如执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = cdev_add(cdev, MKDEV(<span class="number">1</span>, <span class="number">2</span>), <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>其中<code>MKDEV(1,2)</code>构造出一个整数<code>1&lt;&lt;8 | 2</code>；上述代码将结构体<code>cdev</code>放入<code>cdev_map</code>链表中，对应的索引值是<code>0x102</code>到<code>0x102+10</code>；根据<code>(0x102~0x102+10)</code>范围内的10个数值中的任意一个，都可以从<code>cdev_map</code>链表中取出<code>cdev</code>结构体。</p>
<p>APP 打开某个字符设备节点时，进入内核。在内核里根据字符设备节点的主、次设备号，计算出一个数值<code>major&lt;&lt;8 | minor</code>，即 <code>inode-&gt;i_rdev</code>，然后使用这个数值从 <code>cdev_map</code> 中快速得到 <code>cdev</code>，再从 <code>cdev</code> 中得到 <code>file_operations</code> 结构体。</p>
<p>关键函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called every time a character special file is opened</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">new</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;cdev_lock);</span><br><span class="line">	p = inode-&gt;i_cdev;</span><br><span class="line">	<span class="keyword">if</span> (!p) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">kobj</span>;</span></span><br><span class="line">		<span class="type">int</span> idx;</span><br><span class="line">		spin_unlock(&amp;cdev_lock);</span><br><span class="line">		<span class="comment">// 1.根据设备号从cdev_map得到kobj</span></span><br><span class="line">		kobj = kobj_lookup(cdev_map, inode-&gt;i_rdev, &amp;idx);</span><br><span class="line">		<span class="keyword">if</span> (!kobj)</span><br><span class="line">			<span class="keyword">return</span> -ENXIO;</span><br><span class="line">		<span class="comment">// 2.将kobj转换为cdev</span></span><br><span class="line">		new = container_of(kobj, <span class="keyword">struct</span> cdev, kobj);</span><br><span class="line">		spin_lock(&amp;cdev_lock);</span><br></pre></td></tr></table></figure>

<h4 id="1-4-3-class-destroy-device-create浅析"><a href="#1-4-3-class-destroy-device-create浅析" class="headerlink" title="1.4.3 class_destroy&#x2F;device_create浅析"></a>1.4.3 class_destroy&#x2F;device_create浅析</h4><p>驱动程序的核心是 <code>file_operations</code> 结构体：分配、设置、注册它。 <code>class_destroy/device_create</code>函数知识起一些辅助作用：在&#x2F;sys 目录下创建一些目录、文件，这样 Linux 系统中的 APP(比如 udev、mdev)就可以根据这些目录或文件来创建设备节点。</p>
<p>以下代码将会在 &#x2F;sys&#x2F;class 目录下创建一个子目录 hello_class：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>以下代码会在 &#x2F;sys&#x2F;class&#x2F;hello_class 目录下创建一个文件 hello：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/image-20231027222251531.png" alt="image-20231027222251531"></p>
<h4 id="1-4-4-主次设备号"><a href="#1-4-4-主次设备号" class="headerlink" title="1.4.4 主次设备号"></a>1.4.4 主次设备号</h4><p>字符设备的次设备号通常用于区分同一类型的不同设备实例，这些设备在类型上是相同的，但它们是不同的设备实例，通常代表不同的物理设备或虚拟设备，例如：</p>
<ol>
<li><strong>串口设备</strong>：串口设备通常使用字符设备接口来表示。在一台计算机上，你可能会有多个串口，每个串口都有一个唯一的设备文件（例如 <code>/dev/ttyS0</code>, <code>/dev/ttyS1</code>）。这些串口设备都属于相同的类型（串口设备），但是每个串口是不同的设备实例。</li>
<li><strong>磁盘分区</strong>：磁盘设备通常被划分成多个分区，每个分区都可以被视为一个不同的字符设备。这些分区都属于相同的磁盘类型，但每个分区是不同的设备实例。</li>
<li><strong>虚拟终端设备</strong>：虚拟终端设备（例如 <code>/dev/pts/0</code>, <code>/dev/pts/1</code>）用于提供终端会话。每个虚拟终端代表一个不同的终端会话，尽管它们都属于相同的虚拟终端设备类型。</li>
<li><strong>网络设备</strong>：在某些情况下，网络设备也可以表示为字符设备。不同的网络接口（例如 <code>eth0</code>, <code>eth1</code>）属于相同类型的字符设备，但它们是不同的设备实例，每个代表一个不同的网络接口。</li>
</ol>
<p>在这些情况下，主设备号通常用于标识设备类型，而次设备号用于区分不同的设备实例。这使得用户空间程序可以正确识别和与多个设备进行交互，而内核可以根据主设备号和次设备号来路由请求到适当的设备驱动程序。这种灵活性对于操作系统和应用程序来说非常重要，因为它们需要同时处理多个设备实例，每个实例都有不同的特性和状态。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag"># 嵌入式</a>
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/10/22/%E6%98%9F%E9%99%85%E6%8B%93%E8%8D%92%E5%90%8E%E8%AE%B0/" rel="prev" title="星际拓荒后记">
      <i class="fa fa-chevron-left"></i> 星际拓荒后记
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/10/30/LED%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/" rel="next" title="LED驱动程序">
      LED驱动程序 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%BC%96%E5%86%99%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A1%86%E6%9E%B6"><span class="nav-text">1. 编写驱动程序的框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-APP-%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA"><span class="nav-text">1.1 APP 打开的文件在内核中如何表示</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PS%EF%BC%9A%E4%B8%BB%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="nav-text">PS：主设备号</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E7%BC%96%E5%86%99%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-text">1.2 编写驱动程序的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E7%A4%BA%E4%BE%8B"><span class="nav-text">1.3 驱动程序框架示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-Makefile"><span class="nav-text">1.3.1 Makefile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E6%B5%8B%E8%AF%95"><span class="nav-text">1.3.2 测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-Hello%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%AD%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-text">1.4 Hello驱动程序的中的知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-module-init-module-exit-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">1.4.1 module_init&#x2F;module_exit 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%BC%96%E8%AF%91%E4%B8%BAko%E6%96%87%E4%BB%B6"><span class="nav-text">(1) 编译为ko文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BC%96%E8%AF%91%E8%BF%9B%E5%86%85%E6%A0%B8"><span class="nav-text">(2) 编译进内核</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-register-chrdev%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="nav-text">1.4.2 register_chrdev的内部实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89-register-chrdev-region-major-baseminor-count-name"><span class="nav-text">（1）__register_chrdev_region(major, baseminor, count, name)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89cdev-add-cdev-MKDEV-cd-major-baseminor-count"><span class="nav-text">（2）cdev_add(cdev, MKDEV(cd-&gt;major, baseminor), count)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-class-destroy-device-create%E6%B5%85%E6%9E%90"><span class="nav-text">1.4.3 class_destroy&#x2F;device_create浅析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-4-%E4%B8%BB%E6%AC%A1%E8%AE%BE%E5%A4%87%E5%8F%B7"><span class="nav-text">1.4.4 主次设备号</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Krocz"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Krocz</p>
  <div class="site-description" itemprop="description">时间不等人，喜欢就去做</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/krocz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;krocz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1668154689@qq.com" title="E-Mail → mailto:1668154689@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

         

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Krocz</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动 -->
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
