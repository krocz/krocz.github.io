<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 设备树1.1 设备树的引入如果按照上面的方式来让我们的Linux内核支持所有的主控和开发板；也许常用的主控芯片并不是很多，但是基于主控芯片所设计出的开发板就是那就是千千万万了。如果要将所有的开发板的引脚配置编译到内核中，那内核中将充斥大量的高度重复的文件。为此，引入了设备树的概念，设备树用来给内核里的驱动程序指定硬件的信息：  1.2 设备树的语法">
<meta property="og:type" content="article">
<meta property="og:title" content="使用设备树的LED驱动框架">
<meta property="og:url" content="http://example.com/2024/01/02/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="Krocz&#39;s Blog">
<meta property="og:description" content="1. 设备树1.1 设备树的引入如果按照上面的方式来让我们的Linux内核支持所有的主控和开发板；也许常用的主控芯片并不是很多，但是基于主控芯片所设计出的开发板就是那就是千千万万了。如果要将所有的开发板的引脚配置编译到内核中，那内核中将充斥大量的高度重复的文件。为此，引入了设备树的概念，设备树用来给内核里的驱动程序指定硬件的信息：  1.2 设备树的语法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231218155959125.png">
<meta property="og:image" content="http://example.com/images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231220165324421.png">
<meta property="og:image" content="http://example.com/images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231220170050864.png">
<meta property="og:image" content="http://example.com/images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231222200900705.png">
<meta property="og:image" content="http://example.com/images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231222202559378.png">
<meta property="og:image" content="http://example.com/images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231223160427435.png">
<meta property="og:image" content="http://example.com/images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231223153849297.png">
<meta property="og:image" content="http://example.com/images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E9%80%9A%E7%94%A8%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6.png">
<meta property="og:image" content="http://example.com/images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20240102112542082.png">
<meta property="og:image" content="http://example.com/images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20240102113358690.png">
<meta property="og:image" content="http://example.com/images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20240102114920931.png">
<meta property="og:image" content="http://example.com/images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20240102115755062.png">
<meta property="article:published_time" content="2024-01-02T03:02:49.000Z">
<meta property="article:modified_time" content="2024-04-26T09:41:38.265Z">
<meta property="article:author" content="Krocz">
<meta property="article:tag" content="嵌入式">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231218155959125.png">

<link rel="canonical" href="http://example.com/2024/01/02/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>使用设备树的LED驱动框架 | Krocz's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
  <script src="/live2d-widget/autoload.js"></script>
 <link rel="alternate" href="/atom.xml" title="Krocz's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">

   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/cursor/fireworks.js"></script>



  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Krocz's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">望云登坡</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/02/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Krocz">
      <meta itemprop="description" content="时间不等人，喜欢就去做">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Krocz's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          使用设备树的LED驱动框架
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-02 11:02:49" itemprop="dateCreated datePublished" datetime="2024-01-02T11:02:49+08:00">2024-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-26 17:41:38" itemprop="dateModified" datetime="2024-04-26T17:41:38+08:00">2024-04-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9F%A6%E4%B8%9C%E5%B1%B1Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">韦东山Linux驱动开发笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>26 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-设备树"><a href="#1-设备树" class="headerlink" title="1. 设备树"></a>1. 设备树</h2><h3 id="1-1-设备树的引入"><a href="#1-1-设备树的引入" class="headerlink" title="1.1 设备树的引入"></a>1.1 设备树的引入</h3><p>如果按照上面的方式来让我们的Linux内核支持所有的主控和开发板；也许常用的主控芯片并不是很多，但是基于主控芯片所设计出的开发板就是那就是千千万万了。如果要将所有的开发板的引脚配置编译到内核中，那内核中将充斥大量的高度重复的文件。为此，引入了设备树的概念，<strong>设备树用来给内核里的驱动程序指定硬件的信息</strong>：</p>
<p><img src="/../../images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231218155959125.png" alt="image-20231218155959125"></p>
<h3 id="1-2-设备树的语法"><a href="#1-2-设备树的语法" class="headerlink" title="1.2 设备树的语法"></a>1.2 设备树的语法</h3><p>我们需要编写设备树文件(dts: device tree source)，它需要编译为 dtb(device tree blob)文件，内核使用的是 dtb 文件。</p>
<p>下面是一个设备树示例：</p>
<p><img src="/../../images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231220165324421.png" alt="image-20231220165324421"></p>
<p><img src="/../../images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231220170050864.png" alt="image-20231220170050864"></p>
<h4 id="1-2-1-设备树的格式"><a href="#1-2-1-设备树的格式" class="headerlink" title="1.2.1 设备树的格式"></a>1.2.1 设备树的格式</h4><h5 id="（1）DTS文件的格式"><a href="#（1）DTS文件的格式" class="headerlink" title="（1）DTS文件的格式"></a>（1）DTS文件的格式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;                 // 表示版本</span><br><span class="line">[memory reservations]     // 格式为：/memreserver &lt;address&gt; &lt;length&gt;;</span><br><span class="line">/&#123;</span><br><span class="line">	[property definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="（2）node的格式"><a href="#（2）node的格式" class="headerlink" title="（2）node的格式"></a>（2）node的格式</h5><p>设备树中的基本单元，称为“node”，其格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[label:] node-name[@unit-address] &#123;</span><br><span class="line">	[properties definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>label 是标号，可以省略。label 的作用是为了方便地引用 node，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">	uart0: uart@fe001000 &#123;</span><br><span class="line">		compatible=&quot;ns16550&quot;;</span><br><span class="line">		reg=&lt;0xfe001000 0x100&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以使用下面 2 种方法来修改 <code>uart@fe001000</code> 这个 node：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 在根节点之外使用 label 引用 node：</span><br><span class="line">&amp;uart0 &#123;</span><br><span class="line">	status = “disabled”;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 或在根节点之外使用全路径</span><br><span class="line">&amp;&#123;/uart@fe001000&#125; &#123; </span><br><span class="line">	status = “disabled”; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="（3）properties的格式"><a href="#（3）properties的格式" class="headerlink" title="（3）properties的格式"></a>（3）properties的格式</h5><ul>
<li>两种格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[label:] property-name;</span><br><span class="line"></span><br><span class="line">[label:] property-name = value;</span><br></pre></td></tr></table></figure>

<ul>
<li>三种取值：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrays of cells(1 个或多个 32 位数据, 64 位数据使用 2 个 32 位数据表示), </span><br><span class="line">string(字符串), </span><br><span class="line">bytestring(1 个或多个字节)</span><br></pre></td></tr></table></figure>

<ul>
<li>示例：</li>
</ul>
<p><strong>arrays of cells</strong>，cell 就是一个 32 位的数据，用尖括号包围起来。而至于两个32位数据是分别表示两个数值，还是表示一个64bit数据的高低位，则由常用属性<code>#address-cells</code>和<code>#size-cells</code>决定，参见后面的介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interrupts = &lt;17 0xc&gt;;    </span><br><span class="line">clock-frequency = &lt;0x00000001 0x00000000&gt;;</span><br></pre></td></tr></table></figure>

<p><strong>string</strong>，有结束符的字符串，用双引号包围起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = &quot;simple-bus&quot;;</span><br></pre></td></tr></table></figure>

<p><strong>bytestring</strong>，字节序列，用中括号包围起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local-mac-address = [00 00 12 34 56 78]; // 每个byte使用2个16进制数来表示</span><br><span class="line">local-mac-address = [000012345678];      // 每个byte使用2个16进制数来表示</span><br></pre></td></tr></table></figure>

<p><strong>各种值的组合</strong>，用逗号隔开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compatible = &quot;ns16550&quot;, &quot;ns8250&quot;; </span><br><span class="line">example = &lt;0xf00f0000 19&gt;, &quot;a strange property format&quot;;</span><br></pre></td></tr></table></figure>



<h4 id="1-2-2-dts-文件包含-dtsi-文件"><a href="#1-2-2-dts-文件包含-dtsi-文件" class="headerlink" title="1.2.2 dts 文件包含 dtsi 文件"></a>1.2.2 dts 文件包含 dtsi 文件</h4><p>设备树文件不需要我们从零写出来，内核支持了某款芯片比如 imx6ull，在内核的 <code>arch/arm/boot/dts</code> 目录下就有了能用的设备树模板，一般命名为 xxxx.dtsi。“ i”表示“include”，被别的文件引用的。</p>
<p>我们使用某款芯片制作出了自己的单板，所用资源跟 xxxx.dtsi 是大部分相同，小部分不同，所以需要引脚 xxxx.dtsi 并修改。 </p>
<p>dtsi 文件跟 dts 文件的语法是完全一样的。 </p>
<p>dts 中可以包含.h 头文件，也可以包含 dtsi 文件，在.h 头文件中可以定义 一些宏，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/; </span><br><span class="line">#include &lt;dt-bindings/input/input.h&gt; </span><br><span class="line">#include &quot;imx6ull.dtsi&quot; </span><br><span class="line">/ &#123; </span><br><span class="line">...... </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="1-2-3-常用属性"><a href="#1-2-3-常用属性" class="headerlink" title="1.2.3 常用属性"></a>1.2.3 常用属性</h4><ol>
<li><p>#address-cells、#size-cells</p>
<p>#address-cells指示硬件的address要用多少个32位数表示；#size-cells表示硬件所占用的内存size要用多少个32位数来表示。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aips1: aips-bus@<span class="number">02000000</span> &#123;</span><br><span class="line">    compatible = <span class="string">&quot;fsl,aips-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    reg = &lt;<span class="number">0x02000000</span> <span class="number">0x100000</span>&gt;;</span><br><span class="line">    ranges;</span><br></pre></td></tr></table></figure>

<p>对于需要指定大小资源的设备是有用的，比如 RAM 块或者其他可配置大小的硬件资源，需要设置 <code>#address-cells = &lt;1&gt;;</code> 以便描述该设备所使用的内存空间大小。</p>
<blockquote>
<p> AIPS 是 ARM IP Bus 的缩写，它一边与内核 AHB 总线连接，另一边与片上的各种外设连接，AIPS1~4 连接了各种各样的外设。</p>
</blockquote>
<p>对于一些固定大小的外设，如I2C控制器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i2c1: i2c@021a0000 &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;0&gt;;</span><br><span class="line">    compatible = &quot;fsl,imx6ul-i2c&quot;, &quot;fsl,imx21-i2c&quot;;</span><br><span class="line">    reg = &lt;0x021a0000 0x4000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它们占用的内存映射空间通常是固定的，因此不需要在设备树中指定大小。在这种情况下，<code>#size-cells</code>可以被设置为<code>&lt;0&gt;</code>。</p>
<p>其他 <code>#size-cells = &lt;0&gt;</code> 的情况：</p>
<ul>
<li>该节点代表的硬件资源的大小是固定的，不需要通过设备树来指定。</li>
<li>驱动程序将不期望从设备树获取大小信息，因为它已经知道资源的大小或者有其他机制来确定它。</li>
<li>在设备树中，该节点可能仍然包含其他重要信息，比如中断、时钟或状态，但不包括大小信息。</li>
</ul>
</li>
<li><p>compatible</p>
<p>“compatible”表示“兼容”，对于某个 LED，内核中可能有 A、B、C 三个驱动都支持它，那可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">led &#123; </span><br><span class="line">	compatible = “A”, “B”, “C”; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内核启动时，就会为这个 LED 按这样的优先顺序为它找到驱动程序：A、B、C。</p>
<p>根节点下也有 compatible 属性，用来选择哪一个<code>machine desc</code>：一个内核可以支持 machine A，也支持 machine B，<strong>内核启动后会根据根节点的 compatible 属性找到对应的 <code>machine desc </code>结构体，执行其中的初始化函数</strong>。 compatible 的值，建议取这样的形式：”manufacturer,model”，即“厂家名，模块名”。</p>
<p>注：<code>machine desc</code> 的意思就是“机器描述”，学到内核启动流程时才涉及。</p>
</li>
<li><p>model</p>
<p>model 属性与 compatible 属性有些类似，但是有差别。 </p>
<p>compatible 属性是一个字符串列表，表示可以你的硬件兼容 A、B、C 等驱动； </p>
<p>model 用来准确地定义这个硬件是什么，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">	compatible = &quot;samsung,smdk2440&quot;, &quot;samsung,mini2440&quot;; </span><br><span class="line">	model = &quot;jz2440_v3&quot;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它表示这个单板，可以兼容内核中的“smdk2440”，也兼容“mini2440”。 <strong>从 compatible 属性中可以知道它兼容哪些板，但是它到底是什么板？用 model 属性来明确</strong>。</p>
</li>
<li><p>status</p>
<p>dtsi 文件中定义了很多设备，但是在你的板子上某些设备是没有的。这时你可以给这个设备节点添加一个 status 属性，设置为“disabled”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;uart1 &#123; </span><br><span class="line">	status = &quot;disabled&quot;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>“okay”</td>
<td>设备正常运行</td>
</tr>
<tr>
<td>“disabled”</td>
<td>设备不可操作，但是后面可以恢复工作</td>
</tr>
<tr>
<td>“fail”</td>
<td>发生了严重错误，需要修复</td>
</tr>
<tr>
<td>“fail-sss”</td>
<td>发生了严重错误，需要修复；sss表示错误信息</td>
</tr>
</tbody></table>
</li>
<li><p>reg</p>
<p>用来描述一段空间。对于 ARM 系统，寄存器和内存是统一编址的，即访问寄存器时用某块地址，访问内存时用某块地址，在访问方法上没有区别。</p>
<p>reg 属性的值，是一系列的<code>address &amp; size</code>，用多少个 32 位的数来表示 address 和 size，由其父节点的#address-cells、#size-cells 决定，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/; </span><br><span class="line">/&#123; </span><br><span class="line">	#address-cells = &lt;1&gt;; </span><br><span class="line">	#size-cells = &lt;1&gt;; </span><br><span class="line">	memory &#123; </span><br><span class="line">		reg = &lt;0x80000000 0x20000000&gt;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>name(过时了，建议不用)</p>
<p>它的值是字符串，用来表示节点的名字。在跟 platform_driver 匹配时， 优先级最低。 compatible 属性在匹配过程中，优先级最高。</p>
</li>
<li><p>device_type(过时了，建议不用)</p>
<p>它的值是字符串，用来表示节点的类型。在跟 platform_driver 匹配时， 优先级为中。 compatible 属性在匹配过程中，优先级最高。</p>
</li>
</ol>
<h4 id="1-2-4-常用节点（node）"><a href="#1-2-4-常用节点（node）" class="headerlink" title="1.2.4 常用节点（node）"></a>1.2.4 常用节点（node）</h4><ol>
<li><p>根节点</p>
<p>dts文件中必须有一个根节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">model = &quot;SMDK24440&quot;;</span><br><span class="line">compatible = &quot;samsung,smdk2440&quot;;</span><br><span class="line"></span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根节点中必须有这些属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#address-cells // 在它的子节点的 reg 属性中, 使用多少个 u32 整数来描述地址(address) </span><br><span class="line">#size-cells    // 在它的子节点的 reg 属性中, 使用多少个 u32 整数来描述大小(size) </span><br><span class="line">compatible     // 定义一系列的字符串, 用来指定内核中哪个 machine_desc 可以支持本设备 </span><br><span class="line">               // 即这个板子兼容哪些平台 </span><br><span class="line">               // uImage : smdk2410 smdk2440 mini2440 ==&gt; machine_desc </span><br><span class="line">model          // 咱这个板子是什么</span><br><span class="line">               // 比如有 2 款板子配置基本一致, 它们的 compatible 是一样的 </span><br><span class="line">               // 那么就通过 model 来分辨这 2 款板子</span><br></pre></td></tr></table></figure>
</li>
<li><p>CPU节点</p>
<p>一般不需要我们设置，在 dtsi 文件中都定义好了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123; </span><br><span class="line">	#address-cells = &lt;1&gt;; </span><br><span class="line">	#size-cells = &lt;0&gt;; </span><br><span class="line">	cpu0: cpu@0 &#123; </span><br><span class="line">	....... </span><br><span class="line">	&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>memory节点</p>
<p>芯片厂家不可能事先确定你的板子使用多大的内存，所以 memory 节点需要板厂设置，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory &#123;</span><br><span class="line">	reg = &lt;0x80000000 0x20000000&gt;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>chosen节点</p>
<p>我们可以通过设备树文件给内核传入一些参数，这要在chosen节点中设置bootargs属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chosen &#123; </span><br><span class="line">	bootargs = &quot;noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200&quot;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-3-编译、更换设备树"><a href="#1-3-编译、更换设备树" class="headerlink" title="1.3 编译、更换设备树"></a>1.3 编译、更换设备树</h3><ol>
<li><p>一般设备树文件在内核源码目录下<code>arch/arm/boot/dts/</code>（对于64位系统，需要将<code>arm</code>替换为<code>arm64</code>）下。</p>
</li>
<li><p>我们一般不会从零写 dts 文件，而是修改。</p>
</li>
<li><p>当我们修改完设备树文件之后需要将设备树源码文件<code>dts</code>编译为设备树二进制文件<code>dtb</code>。</p>
</li>
<li><p>然后将修改后的<code>dtb</code>文件放到板子的<code>/boot/</code>目录中；重启开发板，在上电过程中进入Bootload，指定板子所使用的设备树文件，从而完成修改、编译和更换设备树的需求。</p>
</li>
</ol>
<h4 id="1-3-1-在内核中直接make"><a href="#1-3-1-在内核中直接make" class="headerlink" title="1.3.1 在内核中直接make"></a>1.3.1 在内核中直接make</h4><p>设置 ARCH、CROSS_COMPILE、PATH 这三个环境变量后，进入 ubuntu 上板子内核源码的根目录，在根目录下执行如下命令编译 dtb 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make dtbs V=1   // V=1表示输出详细信息，可省略</span><br></pre></td></tr></table></figure>

<p>这种编译方式<strong>首先会使用 gcc 对<code>dts</code>文件进行预编译，然后对预编译生成的临时文件使用 dtc 工具进行编译。</strong></p>
<h4 id="1-3-2-手工编译"><a href="#1-3-2-手工编译" class="headerlink" title="1.3.2 手工编译"></a>1.3.2 手工编译</h4><p>除非你对设备树比较了解，否则不建议手工使用 dtc 工具直接编译。 </p>
<p>内核目录下 <code>scripts/dtc/dtc</code> 是设备树的编译工具，直接使用它的话，**包含其他文件时不能使用<code>#include</code>，而必须使用<code>/incldue/</code>**。 编译、反编译的示例命令如下，<code>-I</code>指定输入格式，<code>-O</code>指定输出格式，<code>-o</code>指定输出文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dts -O dtb -o tmp.dtb arch/arm/boot/dts/xxx.dts // 编译 dts 为 dtb </span><br><span class="line">./scripts/dtc/dtc -I dtb -O dts -o tmp.dts arch/arm/boot/dts/xxx.dtb // 反编译 dtb 为 dts</span><br></pre></td></tr></table></figure>



<h4 id="1-3-3-板子启动后查看设备树"><a href="#1-3-3-板子启动后查看设备树" class="headerlink" title="1.3.3 板子启动后查看设备树"></a>1.3.3 板子启动后查看设备树</h4><p>板子启动后执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /sys/firmware/ </span><br></pre></td></tr></table></figure>

<p>在该目录下有目录 <code>devicetree</code> 和文件 <code>fdt</code> ，下面分别对二者进行介绍</p>
<h5 id="（1）目录devicetree"><a href="#（1）目录devicetree" class="headerlink" title="（1）目录devicetree"></a>（1）目录<code>devicetree</code></h5><p><code>/sys/firmware/devicetree</code> 目录下是以目录结构呈现的dtb文件，根节点对应 base 目录，每一个节点对应一个目录，每一个属性对应一个文件。</p>
<p><strong>这些属性的值如果是字符串，可以使用 cat 命令把它打印出来；对于数值， 可以用 hexdump 把它打印出来。</strong></p>
<p>例如 <code>dts</code>中存在以下节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">krocz_led_test&#123;</span><br><span class="line">	led_test_resource = &quot;LED1&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>sys/firmware/devicetree/base/krocz_led_test</code>目录下有：</p>
<p><img src="/../../images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231222200900705.png" alt="image-20231222200900705"></p>
<ul>
<li><code>cat name</code> 显示字符串”krocz_led_test”</li>
<li><code>cat led_test_resource</code> 显示字符串”LED1”</li>
</ul>
<h5 id="（2）文件fdt"><a href="#（2）文件fdt" class="headerlink" title="（2）文件fdt"></a>（2）文件<code>fdt</code></h5><p><code>/sys/firmware/fdt</code> 文件，是 <code>dtb</code> 格式的设备树文件，可以把它复制出来放到 ubuntu 上，使用dtc编译器，执行下面的命令反编译为 <code>dts</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dtb -O dts /目录/fdt -o tmp.dts</span><br></pre></td></tr></table></figure>



<h3 id="1-4-内核对设备树的处理"><a href="#1-4-内核对设备树的处理" class="headerlink" title="1.4 内核对设备树的处理"></a>1.4 内核对设备树的处理</h3><p>从源代码文件 dts 文件开始，设备树的处理过程为：</p>
<p><img src="/../../images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231222202559378.png" alt="image-20231222202559378"></p>
<ol>
<li>dts 在 PC 机上被编译为 dtb 文件； </li>
<li>u-boot 把 dtb 文件传给内核； </li>
<li>内核解析 dtb 文件，把每一个节点都转换为 device_node 结构体； </li>
<li>对于某些 device_node 结构体，会被转换为 platform_device 结构体。</li>
</ol>
<h4 id="1-4-1-dtb-中的每个节点都会被转换-device-node-结构体"><a href="#1-4-1-dtb-中的每个节点都会被转换-device-node-结构体" class="headerlink" title="1.4.1 dtb 中的每个节点都会被转换 device_node 结构体"></a>1.4.1 dtb 中的每个节点都会被转换 device_node 结构体</h4><p>device_node结构体表示每一个节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *type;</span><br><span class="line">	phandle phandle;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *full_name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fwnode_handle</span> <span class="title">fwnode</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">property</span> *<span class="title">properties</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">property</span> *<span class="title">deadprops</span>;</span>	<span class="comment">/* removed properties */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">device_node</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">device_node</span> *<span class="title">child</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">device_node</span> *<span class="title">sibling</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>	<span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _flags;</span><br><span class="line">	<span class="type">void</span>	*data;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SPARC)</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *path_component_name;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unique_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">of_irq_controller</span> *<span class="title">irq_trans</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>device_node</code> 结构体通过以下三个成员来表示设备树中节点的关系：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">parent</span>;</span>  <span class="comment">/* 指向父亲节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">child</span>;</span>   <span class="comment">/* 指向第一个孩子节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">sibling</span>;</span> <span class="comment">/* 指向同级别的下一个节点 */</span></span><br></pre></td></tr></table></figure>

<p>例如一个设备树节点结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \</span><br><span class="line">D   E</span><br></pre></td></tr></table></figure>

<p>在这个例子中，节点 A 的 <code>child</code> 指向 B，节点 B 的 <code>sibling</code> 指向 C，节点 B 的 <code>child</code> 指向 D，节点 D 的 <code>sibling</code> 指向 E。这样，就可以通过 <code>child</code> 和 <code>sibling</code> 字段在设备树中表示节点之间的关系，包括一个节点有多个孩子的情况。</p>
<p><strong>根节点被保存在全局变量 of_root 中，从 of_root 开始可以访问到任意节点。</strong></p>
<p>节点中属性成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>	<span class="title">property</span> *<span class="title">properties</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>	<span class="title">property</span> *<span class="title">deadprops</span>;</span>	<span class="comment">/* removed properties */</span></span><br></pre></td></tr></table></figure>

<p><code>properties</code>成员指向一个链表，表示当前节点的属性列表。这个链表中的每个节点都是一个属性，包含键（name）和值（value）</p>
<p><code>deadprops</code>成员用于表示已被移除（removed）的属性。当设备树中的节点属性被修改或删除时，原有的属性可能会被移动到 <code>deadprops</code> 链表中，以便记录这些已经被移除的属性。这样设计的一个原因是为了在设备树的修改过程中能够追踪先前的属性信息，即便这些属性已经被删除或修改。通过保留这些“死去”的属性，系统可以在需要时回溯到先前的状态，或者进行一些历史记录和调试。</p>
<p>成员 name 和 type对应已经过时废弃的属性 name 和 device_type。节点的其他属性使用结构体<code>property</code>表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>	*name;</span><br><span class="line">	<span class="type">int</span>	length;</span><br><span class="line">	<span class="type">void</span>	*value;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> _flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unique_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> <span class="title">attr</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="1-4-2-哪些-device-node-会被转换为-platform-device"><a href="#1-4-2-哪些-device-node-会被转换为-platform-device" class="headerlink" title="1.4.2 哪些 device_node 会被转换为 platform_device"></a>1.4.2 哪些 device_node 会被转换为 platform_device</h4><ol>
<li><p>根节点下含有 compatile 属性的<strong>子节点</strong></p>
</li>
<li><p>含有特定 compatile 属性的<strong>节点的子节点</strong></p>
<p>如果一个节点的 compatile 属性，它的值包括这 4 者之一：<code>simple-bus</code>，<code>simple-mfd</code>，<code>isa</code>，<code>arm,amba-bus</code>，那么它的子结点( <strong>需含 compatile 属性</strong>)也可以转换为 platform_device。</p>
</li>
<li><p>总线 I2C、SPI 节点下的子节点：<strong>不转换</strong>为 platform_device</p>
<p>某个总线下到子节点，应该交给对应的总线驱动程序来处理, 它们不应该被转换为 platform_device。</p>
</li>
</ol>
<p>例如以下<code>dts</code>文件，每个节点是否会转换为platform_device如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    mytest&#123;                                   <span class="comment">// √</span></span><br><span class="line">        compatile = <span class="string">&quot;mytest&quot;</span>, <span class="string">&quot;simple-bus&quot;</span></span><br><span class="line">		mytest@<span class="number">0</span>&#123;                             <span class="comment">// √</span></span><br><span class="line">            compatile = <span class="string">&quot;mytest_0&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    i2c&#123;                                      <span class="comment">// √</span></span><br><span class="line">        compatile = <span class="string">&quot;samsung,i2c&quot;</span>;</span><br><span class="line">        at24c02&#123;                              <span class="comment">// ×</span></span><br><span class="line">            compatile = <span class="string">&quot;at24c02&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    spi&#123;                                      <span class="comment">// √</span></span><br><span class="line">        compatile = <span class="string">&quot;samsung,spi&quot;</span>;</span><br><span class="line">        flash@<span class="number">0</span>&#123;                              <span class="comment">// ×</span></span><br><span class="line">            compatible = <span class="string">&quot;winbond,w25q32dw&quot;</span>;</span><br><span class="line">            spi-max-frequency = &lt;<span class="number">25000000</span>&gt;;</span><br><span class="line">            reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="1-4-3-device-node-怎么转为-platform-device"><a href="#1-4-3-device-node-怎么转为-platform-device" class="headerlink" title="1.4.3 device_node 怎么转为 platform_device"></a>1.4.3 device_node 怎么转为 platform_device</h4><ul>
<li><p><code>platform_device</code> 中含有 <code>resource</code> 数组，设备树节点中的 reg、interrupts 属性会被转化为 resource；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> num)</span></span><br></pre></td></tr></table></figure>

<p>使用该函数可以取出这些资源：</p>
<ul>
<li>对于设备树节点中的 reg 属性，它对应 IORESOURCE_MEM 类型的资源； </li>
<li>对于设备树节点中的 interrupts 属性，它对应 IORESOURCE_IRQ 类型的资源。</li>
</ul>
</li>
<li><p><code>platform_device.dev.of_node</code> 指向 <code>struct device_node</code>，可以通过该指针来获取<code>of_node-&gt;property</code> 从而获取设备节点中自定义的其他属性。</p>
</li>
</ul>
<h3 id="1-5-完善-platform-device-与-platform-driver-匹配过程"><a href="#1-5-完善-platform-device-与-platform-driver-匹配过程" class="headerlink" title="1.5 完善 platform_device 与 platform_driver 匹配过程"></a>1.5 完善 platform_device 与 platform_driver 匹配过程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">platform_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> =</span> to_platform_device(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">pdrv</span> =</span> to_platform_driver(drv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class="line">	<span class="keyword">if</span> (pdev-&gt;driver_override)</span><br><span class="line">		<span class="keyword">return</span> !<span class="built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt an OF style match first */</span></span><br><span class="line">	<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then try ACPI style match */</span></span><br><span class="line">	<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then try to match against the id table */</span></span><br><span class="line">	<span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-1-最先比较：是否强制选择某个driver"><a href="#1-5-1-最先比较：是否强制选择某个driver" class="headerlink" title="1.5.1 最先比较：是否强制选择某个driver"></a>1.5.1 最先比较：是否强制选择某个driver</h4><p>最先比较 <code>platform_device.driver_override</code> 和 <code>platform_driver.driver.name</code> </p>
<h4 id="1-5-2-然后比较：设备树信息"><a href="#1-5-2-然后比较：设备树信息" class="headerlink" title="1.5.2 然后比较：设备树信息"></a>1.5.2 然后比较：设备树信息</h4><p>比较 <code>platform_device.dev.of_node</code> 和 <code>platform_driver.driver.of_match_table</code> </p>
<p><img src="/../../images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231223160427435.png" alt="image-20231223160427435"></p>
<ol>
<li>如果 of_match_table 中含有 compatible 值，就跟 dev 的 compatile 属性比较，若一致则成功，否则返回失败；</li>
<li>如果 of_match_table 中含有 type 值，就跟 dev 的 device_type 属性比较，若一致则成功，否则返回失败；</li>
<li>如果 of_match_table 中含有 name 值，就跟 dev 的 name 属性比较，若一致则成功，否则返回失败。</li>
</ol>
<p><strong>而设备树中建议不再使用 devcie_type 和 name 属性</strong>，所以基本上只使用设备节点的 compatible 属性来寻找匹配的 platform_driver。</p>
<h4 id="1-5-3-接下来比较：-platform-device-id"><a href="#1-5-3-接下来比较：-platform-device-id" class="headerlink" title="1.5.3 接下来比较： platform_device_id"></a>1.5.3 接下来比较： platform_device_id</h4><p>比较 platform_device.name 和 platform_driver.id_table[i].name， id_table 中可能有多项。</p>
<p>platform_driver.id_table 表示该 drv 支持若干个 device，它里面列出了各个 device 的<code>&#123;.name, .driver_data&#125;</code>， 其中的 name表示该 drv 支持的设备的名字，driver_data 是些提供给该 device 的私有数据。</p>
<h4 id="1-5-4-最后比较：name"><a href="#1-5-4-最后比较：name" class="headerlink" title="1.5.4 最后比较：name"></a>1.5.4 最后比较：name</h4><p>platform_driver.id_table 可能为空， 这时可以根据 platform_driver.driver.name 和 platform_device.name 是否匹配进行比较</p>
<h4 id="1-5-5-匹配过程总结："><a href="#1-5-5-匹配过程总结：" class="headerlink" title="1.5.5 匹配过程总结："></a>1.5.5 匹配过程总结：</h4><p><img src="/../../images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20231223153849297.png" alt="image-20231223153849297"></p>
<h2 id="2-LED驱动程序改造：设备树"><a href="#2-LED驱动程序改造：设备树" class="headerlink" title="2. LED驱动程序改造：设备树"></a>2. LED驱动程序改造：设备树</h2><p><img src="/../../images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E9%80%9A%E7%94%A8%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6.png"></p>
<p>上图是使用设备树的通用驱动框架：</p>
<ul>
<li>开发板的硬件资源使用 board_devicetree.dts 文件描述</li>
<li>chip_drv.c 实现针对某一款主控芯片的硬件操作结构体和平台驱动结构体</li>
<li>universal_drv.c 是兼容所有开发板的通用驱动程序</li>
<li>app_test.c 是应用层的硬件测试程序</li>
</ul>
<p>使用该驱动框架，<strong>实现了通用驱动程序和主控芯片的解耦，主控芯片和开发板的解耦，避免了大量重复的开发板硬件描述文件充斥内核</strong>。</p>
<h3 id="2-1-代码"><a href="#2-1-代码" class="headerlink" title="2.1 代码"></a>2.1 代码</h3><h4 id="2-1-1-设备树"><a href="#2-1-1-设备树" class="headerlink" title="2.1.1 设备树"></a>2.1.1 设备树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define GROUP_PIN(g,p) ((g&lt;&lt;16) | (p))</span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">	krocz_led@0 &#123;</span><br><span class="line">		compatible = &quot;krocz,leddrv&quot;;</span><br><span class="line">		pin = &lt;GROUP_PIN(1, 1)&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	krocz_led@1 &#123;</span><br><span class="line">		compatible = &quot;krocz,leddrv&quot;;</span><br><span class="line">		pin = &lt;GROUP_PIN(5, 3)&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在开发板的设备树文件中添加两个节点，用于实验。</p>
<h4 id="2-1-2-芯片层"><a href="#2-1-2-芯片层" class="headerlink" title="2.1.2 芯片层"></a>2.1.2 芯片层</h4><p><strong>IMX6ULL芯片操作LED的结构体</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_led_init</span><span class="params">(<span class="type">int</span> which)</span>&#123;&#125; <span class="comment">/* 初始化LED, which-哪个LED */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_led_ctl</span><span class="params">(<span class="type">int</span> which, <span class="type">char</span> status)</span>&#123;&#125; <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_led_close</span><span class="params">(<span class="type">void</span>)</span> &#123;&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_board_led_num</span><span class="params">(<span class="type">void</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> <span class="title">chip_imx6ll_led_opr</span> =</span> &#123;</span><br><span class="line">    .init = chip_led_init,</span><br><span class="line">    .ctl = chip_led_ctl,</span><br><span class="line">    .close = chip_led_close,</span><br><span class="line">    .get_led_num = get_board_led_num,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>操作函数具体内容和“LED驱动程序框架”中对应章节中的代码类似，这里就不放了，都是操作寄存器的繁琐代码。</p>
<p><strong>IMX6ULL芯片的LED驱动结构体</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> led_pin;</span><br><span class="line"></span><br><span class="line">    np = pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="keyword">if</span> (!np)   <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">// platform_device 不一定是由device_node转换而来的，of_node可能为空因此需要判断</span></span><br><span class="line"></span><br><span class="line">    err = of_property_read_u32(np, <span class="string">&quot;pin&quot;</span>, &amp;led_pin);</span><br><span class="line">    g_ledpins[g_ledcnt] = led_pin;</span><br><span class="line">    led_class_create_device(g_ledcnt);  <span class="comment">// 创建设备文件</span></span><br><span class="line">    g_ledcnt++;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span>;</span></span><br><span class="line">    <span class="type">int</span> led_pin;</span><br><span class="line"></span><br><span class="line">    np = pdev-&gt;dev.of_node;</span><br><span class="line">    <span class="keyword">if</span> (!np)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    err = of_property_read_u32(np, <span class="string">&quot;pin&quot;</span>, &amp;led_pin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_ledcnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_ledpins[i] == led_pin)</span><br><span class="line">        &#123;</span><br><span class="line">            led_class_destroy_device(i);  <span class="comment">//销毁设备文件</span></span><br><span class="line">            <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; g_ledcnt; j++)</span><br><span class="line">                g_ledpins[j - <span class="number">1</span>] = g_ledpins[j];</span><br><span class="line">            g_ledcnt --;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">krocz_leds</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;krocz,leddrv&quot;</span> &#125;,  <span class="comment">//通过该属性与platform_device进行匹配</span></span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">chip_imx6ull_gpio_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = chip_demo_gpio_probe,</span><br><span class="line">    .remove     = chip_demo_gpio_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;krocz_led_drv&quot;</span>,</span><br><span class="line">        .of_match_table = krocz_leds,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 platform_driver 结构体中制定了和 platform_device匹配时的初始化函数(probe)，以及解绑时的去初始化函数(remove)；通过 of_device_id 结构体指定了该驱动所支持的设备。</p>
<p><strong>最后就是必须的内核模块安装&#x2F;卸载函数</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chip_demo_gpio_drv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    </span><br><span class="line">    err = platform_driver_register(&amp;chip_imx6ull_gpio_driver); </span><br><span class="line">    register_led_operations(&amp;chip_imx6ll_led_opr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">lchip_demo_gpio_drv_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_driver_unregister(&amp;chip_imx6ull_gpio_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(chip_demo_gpio_drv_init);</span><br><span class="line">module_exit(lchip_demo_gpio_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>主要执行 platform_driver 的总线注册和删除</p>
<h4 id="2-1-3-通用LED驱动"><a href="#2-1-3-通用LED驱动" class="headerlink" title="2.1.3 通用LED驱动"></a>2.1.3 通用LED驱动</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">led_class_create_device</span><span class="params">(<span class="type">int</span> minor)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_create(led_class, <span class="literal">NULL</span>, MKDEV(major, minor), <span class="literal">NULL</span>, <span class="string">&quot;100ask_led%d&quot;</span>, minor); <span class="comment">/* /dev/krocz_led0,1,... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_destroy_device</span><span class="params">(<span class="type">int</span> minor)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(led_class, MKDEV(major, minor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_led_operations</span><span class="params">(<span class="keyword">struct</span> led_operations *opr)</span></span><br><span class="line">&#123;</span><br><span class="line">	p_led_opr = opr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(led_class_create_device);</span><br><span class="line">EXPORT_SYMBOL(led_class_destroy_device);</span><br><span class="line">EXPORT_SYMBOL(register_led_operations);</span><br></pre></td></tr></table></figure>

<p>该程序和”LED驱动程序框架“对应章节中的程序相比变化不大。由于设备文件应该在 platform_driver 和 platform_deivce 匹配&#x2F;删除时动态的创建或销毁，所以将设备文件的创建和销毁作为函数提供给下层驱动程序进行调用（<strong>使用EXPORT_SYMBOL宏修饰函数，使其在其他内核模块中可以被调用</strong>）。</p>
<h3 id="2-2-测试"><a href="#2-2-测试" class="headerlink" title="2.2 测试"></a>2.2 测试</h3><h4 id="2-2-1-编译、安装"><a href="#2-2-1-编译、安装" class="headerlink" title="2.2.1 编译、安装"></a>2.2.1 编译、安装</h4><ol>
<li>参考1.3节“编译、更换设备树”，为开发板更换设备树文件</li>
</ol>
<p>更换安装完成之后，可以在<code>/sys/firmware/devicetree/base</code>目录下查看设备树节点（device_node）：</p>
<p><img src="/../../images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20240102112542082.png" alt="image-20240102112542082"></p>
<p>还可以在<code>/sys/bus/platform/devices/</code>目录下查看所有的 platform_device 节点，例如：</p>
<p><img src="/../../images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20240102113358690.png" alt="image-20240102113358690"></p>
<p>程序中 platform_device 和 platform_driver 使用 compatible 属性进行匹配，当匹配成功之后，platform_device 节点中就会出现指向对应驱动节点（platform_driver）的链接文件。</p>
<ol start="2">
<li>编译内核模块并安装内核模块。</li>
</ol>
<p>在<code>/sys/bus/platform/drivers/</code>目录下查看所有的 platform_driver 节点，例如：</p>
<p><img src="/../../images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20240102114920931.png" alt="image-20240102114920931"></p>
<p>虽然我也不知道为什么 driver 匹配的 device 会链接到 <code>/sys/devices/soc0/krocz_led@0</code>上</p>
<p>同时，在安装内核模块<code>chip_imx6ull_gpio.ko</code>时，会在和 platform_device 匹配之后，创建一个设备文件，在目录<code>/dev/</code>下：</p>
<p><img src="/../../images/%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84LED%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20240102115755062.png" alt="image-20240102115755062"></p>
<ol start="3">
<li>运行APP进行测试</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/" rel="tag"># 嵌入式</a>
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/C-C/" rel="tag"># C/C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/01/02/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/LED%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/" rel="prev" title="LED驱动程序框架">
      <i class="fa fa-chevron-left"></i> LED驱动程序框架
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/01/02/%E9%9F%A6%E4%B8%9C%E5%B1%B1%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/Pinctrl%E5%92%8CGPIO%E5%AD%90%E7%B3%BB%E7%BB%9F/" rel="next" title="Pinctrl和GPIO子系统">
      Pinctrl和GPIO子系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="nav-text">1. 设备树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-text">1.1 设备树的引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="nav-text">1.2 设备树的语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-text">1.2.1 设备树的格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89DTS%E6%96%87%E4%BB%B6%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-text">（1）DTS文件的格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89node%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-text">（2）node的格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89properties%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-text">（3）properties的格式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-dts-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-dtsi-%E6%96%87%E4%BB%B6"><span class="nav-text">1.2.2 dts 文件包含 dtsi 文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="nav-text">1.2.3 常用属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-%E5%B8%B8%E7%94%A8%E8%8A%82%E7%82%B9%EF%BC%88node%EF%BC%89"><span class="nav-text">1.2.4 常用节点（node）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%BC%96%E8%AF%91%E3%80%81%E6%9B%B4%E6%8D%A2%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="nav-text">1.3 编译、更换设备树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9B%B4%E6%8E%A5make"><span class="nav-text">1.3.1 在内核中直接make</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-%E6%89%8B%E5%B7%A5%E7%BC%96%E8%AF%91"><span class="nav-text">1.3.2 手工编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-%E6%9D%BF%E5%AD%90%E5%90%AF%E5%8A%A8%E5%90%8E%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="nav-text">1.3.3 板子启动后查看设备树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%9B%AE%E5%BD%95devicetree"><span class="nav-text">（1）目录devicetree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%96%87%E4%BB%B6fdt"><span class="nav-text">（2）文件fdt</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%86%85%E6%A0%B8%E5%AF%B9%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">1.4 内核对设备树的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-dtb-%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E9%83%BD%E4%BC%9A%E8%A2%AB%E8%BD%AC%E6%8D%A2-device-node-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">1.4.1 dtb 中的每个节点都会被转换 device_node 结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-%E5%93%AA%E4%BA%9B-device-node-%E4%BC%9A%E8%A2%AB%E8%BD%AC%E6%8D%A2%E4%B8%BA-platform-device"><span class="nav-text">1.4.2 哪些 device_node 会被转换为 platform_device</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-device-node-%E6%80%8E%E4%B9%88%E8%BD%AC%E4%B8%BA-platform-device"><span class="nav-text">1.4.3 device_node 怎么转为 platform_device</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%AE%8C%E5%96%84-platform-device-%E4%B8%8E-platform-driver-%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-text">1.5 完善 platform_device 与 platform_driver 匹配过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-%E6%9C%80%E5%85%88%E6%AF%94%E8%BE%83%EF%BC%9A%E6%98%AF%E5%90%A6%E5%BC%BA%E5%88%B6%E9%80%89%E6%8B%A9%E6%9F%90%E4%B8%AAdriver"><span class="nav-text">1.5.1 最先比较：是否强制选择某个driver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-%E7%84%B6%E5%90%8E%E6%AF%94%E8%BE%83%EF%BC%9A%E8%AE%BE%E5%A4%87%E6%A0%91%E4%BF%A1%E6%81%AF"><span class="nav-text">1.5.2 然后比较：设备树信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-3-%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%AF%94%E8%BE%83%EF%BC%9A-platform-device-id"><span class="nav-text">1.5.3 接下来比较： platform_device_id</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-4-%E6%9C%80%E5%90%8E%E6%AF%94%E8%BE%83%EF%BC%9Aname"><span class="nav-text">1.5.4 最后比较：name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-5-%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-text">1.5.5 匹配过程总结：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-LED%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%94%B9%E9%80%A0%EF%BC%9A%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="nav-text">2. LED驱动程序改造：设备树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BB%A3%E7%A0%81"><span class="nav-text">2.1 代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="nav-text">2.1.1 设备树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E8%8A%AF%E7%89%87%E5%B1%82"><span class="nav-text">2.1.2 芯片层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E9%80%9A%E7%94%A8LED%E9%A9%B1%E5%8A%A8"><span class="nav-text">2.1.3 通用LED驱动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E6%B5%8B%E8%AF%95"><span class="nav-text">2.2 测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-%E7%BC%96%E8%AF%91%E3%80%81%E5%AE%89%E8%A3%85"><span class="nav-text">2.2.1 编译、安装</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Krocz"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Krocz</p>
  <div class="site-description" itemprop="description">时间不等人，喜欢就去做</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/krocz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;krocz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1668154689@qq.com" title="E-Mail → mailto:1668154689@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

         

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Krocz</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动 -->
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
